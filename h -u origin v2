[1mdiff --git a/.gitignore b/.gitignore[m
[1mindex 0b0232b..aedd79f 100644[m
[1m--- a/.gitignore[m
[1m+++ b/.gitignore[m
[36m@@ -3,6 +3,8 @@[m [mdata.jld[m
 [m
 Examples/[m
 stage_scenario/[m
[32m+[m[32mfonctionality_test/[m
[32m+[m[32m.CondaPkg/[m
 [m
 example/data/ausgrid_5_twostage.jld[m
 [m
[36m@@ -19,6 +21,7 @@[m [mbuild/[m
 # Files generated by invoking Julia with --track-allocation[m
 *.jl.mem[m
 [m
[32m+[m
 # System-specific files and directories generated by the BinaryProvider and BinDeps packages[m
 # They contain absolute paths specific to the host computer, and so should not be committed[m
 deps/deps.jl[m
[1mdiff --git a/Cours/Cours1/TP1.jl b/Cours/Cours1/TP1.jl[m
[1mindex 41000db..5942e91 100644[m
[1m--- a/Cours/Cours1/TP1.jl[m
[1m+++ b/Cours/Cours1/TP1.jl[m
[36m@@ -75,7 +75,7 @@[m [mmicrogrid = Microgrid(parameters = GlobalParameters(nh, ny, ns, renewable_share[m
 # Add the equipment to the microgrid[m
 add!(microgrid, Demand(carrier = Electricity()),[m
                 Solar(),[m
[31m-                Liion(SoC_model = PolynomialLiionEfficiency(), SoH_model = SemiEmpiricalLiion()),[m
[32m+[m[32m                Liion(eff_model = PolynomialLiionEfficiency(), SoH_model = SemiEmpiricalLiion()),[m
                 Grid(carrier = Electricity()))[m
                 [m
 [m
[36m@@ -86,16 +86,16 @@[m [mdata_HP_HC = JLD2.load(joinpath(pwd(), "Cours", "Cours1", "data_light_4_HP_HC.jl[m
 [m
 data_selected = data_HP_HC[m
      [m
[31m-Ï‰_a = Scenarios(microgrid, data_selected; same_year=true, seed=1:ns)[m
[32m+[m[32mÏ‰_a = Scenarios(microgrid, data_fix; same_year=true, seed=[x for x in 1:4])[m
 [m
 Plot_dayly_prices(Ï‰_a; label = "HP HC")[m
 [m
 [m
 [m
 ############# Dimentionnement manuel du rÃ©seau #####################[m
[31m-generations = Dict("Solar" => 10.)[m
[31m-storages = Dict("Liion" => 20.)[m
[31m-subscribed_power = Dict("Electricity" => 10.)[m
[32m+[m[32mgenerations = Dict("Solar" => 0.)[m
[32m+[m[32mstorages = Dict("Liion" => 0.)[m
[32m+[m[32msubscribed_power = Dict("Electricity" => 20.)[m
 [m
 designer = initialize_designer!(microgrid, Manual(generations = generations, storages = storages, subscribed_power = subscribed_power), Ï‰_a)[m
 ###################################################################[m
[1mdiff --git a/Cours/Cours2/TP2.1.jl b/Cours/Cours2/TP2.1.jl[m
[1mindex 0ef4a88..2f3a09e 100644[m
[1m--- a/Cours/Cours2/TP2.1.jl[m
[1m+++ b/Cours/Cours2/TP2.1.jl[m
[36m@@ -3,20 +3,19 @@[m [musing JuMP[m
 using JLD2, FileIO, Cbc, Ipopt #, Gurobi[m
 [m
 [m
[31m-[m
[32m+[m[32musing Gurobi[m
 [m
 [m
 [m
 ##################### Exemple ############################[m
[31m-m = Model(Cbc.Optimizer)[m
[32m+[m[32mm = Model(Gurobi.Optimizer)[m
 [m
 @variable(m, x1, Int) # variable de dÃ©cision 1[m
[31m-@variable(m, 0 >= x2 >= 0., Int) # variable de dÃ©cision 2[m
[32m+[m[32m@variable(m, 4 >= x2 >= 0., Int) # variable de dÃ©cision 2[m
 n=12[m
 @variable(m, affectation[1:n,1:n], Bin) # Une matrice de variable binaire n*n[m
 [m
[31m-[m
[31m-@constraint(m, 2 * m[:x1] + 3 * m[:x2] <= 10 ) # Contrainte 1[m
[32m+[m[32m@constraint(m, 2 * m[:x1] + 3 * m[:x2] <= 12 ) # Contrainte 1[m
 @constraint(m, m[:x1] - m[:x2] >= -2 )# Contrainte 2[m
 @constraint(m, m[:x2] >= 4 )[m
 [m
[36m@@ -152,7 +151,7 @@[m [mmicrogrid = Microgrid(parameters = GlobalParameters(nh, ny, ns, renewable_share[m
 # Le microgrid Ã©tudiÃ©[m
 add!(microgrid, Demand(carrier = Electricity()),[m
                 Solar(),[m
[31m-                Liion(SoC_model = LinearLiionEfficiency(), SoH_model = FixedLifetimeLiion(), couplage = (E=false, R = false)),[m
[32m+[m[32m                Liion(eff_model = FixedLiionEfficiency(), SoH_model = FixedLifetimeLiion(), couplage = (E=false, R = false)),[m
                 Grid(carrier = Electricity()))[m
                 [m
 [m
[36m@@ -169,7 +168,7 @@[m [mdata_selected = data_fix[m
 [m
 [m
 [m
[31m-h_interval = 1:24[m
[32m+[m[32mh_interval = 1:720[m
 [m
 #################### Fonction pour crÃ©er le modÃ¨le ########################[m
 function get_model_1(solver, microgrid, Ï‰_a)[m
[36m@@ -186,12 +185,12 @@[m [mfunction get_model_1(solver, microgrid, Ï‰_a)[m
     #### Configuration des variables dÃ©crivant les composant pour le modÃ¨le de prog mathÃ©matique[m
     liion = microgrid.storages[1][m
 [m
[31m-    Î·_self = liion.SoC_model.Î·_self #Facreur d'auto-dÃ©charge[m
[31m-    Î· = liion.SoC_model.Î·_ch # Rendement[m
[32m+[m[32m    Î·_self = liion.eff_model.Î·_self #Facreur d'auto-dÃ©charge[m
[32m+[m[32m    Î· = liion.eff_model.Î·_ch # Rendement[m
     âˆ†h = 1. # taille du pas d'opÃ©ration[m
     seuil_max = liion.Î±_soc_max # SoC max[m
     seuil_min = liion.Î±_soc_min # SoC min[m
[31m-    C_rate = liion.SoC_model.Î±_p_ch # C-rate max[m
[32m+[m[32m    C_rate = liion.eff_model.Î±_p_ch # C-rate max[m
 [m
     Erated = 20. # CapacitÃ© de la batterie kWh[m
     PV = 10. # Puissance du panneau solaire kWc[m
[36m@@ -214,7 +213,7 @@[m [mend[m
 [m
 [m
 ################## Execution du modÃ¨le #############################[m
[31m-mod1 = get_model_1(Cbc)[m
[32m+[m[32mmod1 = get_model_3(h_interval)[m
 JuMP.optimize!(mod1)[m
 [m
 println("La solution optimale vaut : ", round(objective_value(mod1), digits=2), " â‚¬")[m
[36m@@ -225,6 +224,10 @@[m [mprintln("Le problÃ¨me Ã  Ã©tÃ© rÃ©solu en : ", round(solve_time(mod1), digits=2)[m
 [m
 [m
 [m
[32m+[m[32mmod1 = get_model_3(h_interval)[m
[32m+[m
[32m+[m[32mJuMP.optimize!(mod1)[m
[32m+[m
 [m
 [m
 [m
[36m@@ -239,10 +242,33 @@[m [mprintln("Le problÃ¨me Ã  Ã©tÃ© rÃ©solu en : ", round(solve_time(mod1), digits=2)[m
 ######################### Model 1 ##############################[m
 ################################################################[m
 [m
[31m-function get_model_1(solver)[m
[32m+[m[32mfunction get_model_1(h_interval)[m
[32m+[m
[32m+[m[32m    # Couts associÃ©s au grid[m[41m [m
[32m+[m[32m    cost_in = Ï‰_a.grids[1].cost_in[h_interval,1,1] #Prix d'achat â‚¬/kWh[m
[32m+[m[32m    cost_out = Ï‰_a.grids[1].cost_out[h_interval,1,1] #Prix de vente â‚¬/kWh[m
[32m+[m[32m    cout_depassement = microgrid.grids[1].cost_exceed[1,1] # Cout de dÃ©passement de la puissance souscrite au rÃ©seau â‚¬/h[m
[32m+[m
[32m+[m[32m    # Variables d'environement (imposÃ©es)[m
[32m+[m[32m    p_load = Ï‰_a.demands[1].power[h_interval,1,1] # Demande en kWh[m
[32m+[m[32m    p_gen = Ï‰_a.generations[1].power[h_interval,1,1] # Puissance par unitÃ© de kWc installÃ©[m[41m [m
[32m+[m
[32m+[m[32m    #### Configuration des variables dÃ©crivant les composant pour le modÃ¨le de prog mathÃ©matique[m
[32m+[m[32m    liion = microgrid.storages[1][m
[32m+[m
[32m+[m[32m    Î·_self = liion.eff_model.Î·_self #Facreur d'auto-dÃ©charge[m
[32m+[m[32m    Î· = liion.eff_model.Î·_ch # Rendement[m
[32m+[m[32m    âˆ†h = 1. # taille du pas d'opÃ©ration[m
[32m+[m[32m    seuil_max = liion.Î±_soc_max # SoC max[m
[32m+[m[32m    seuil_min = liion.Î±_soc_min # SoC min[m
[32m+[m[32m    C_rate = liion.eff_model.Î±_p_ch # C-rate max[m
[32m+[m
[32m+[m[32m    Erated = 20. # CapacitÃ© de la batterie kWh[m
[32m+[m[32m    PV = 10. # Puissance du panneau solaire kWc[m
[32m+[m[32m    grid_seuil = 10. # puissance souscrite au rÃ©seau kW[m
 [m
     #DÃ©claration du model et du solver[m
[31m-    m1 = Model(solver.Optimizer)[m
[32m+[m[32m    m1 = Model(Gurobi.Optimizer)[m
 [m
     #variables de dÃ©cisions[m
     @variable(m1, p_ch[1:length(h_interval)] >= 0.)[m
[36m@@ -289,18 +315,51 @@[m [mend[m
 ######################### Model 2 ##############################[m
 ################################################################[m
 [m
[31m-function get_model_2(solver)[m
[32m+[m[32mfunction get_model_2(h_interval)[m
[32m+[m
[32m+[m[32m    # Couts associÃ©s au grid[m[41m [m
[32m+[m[32m    cost_in = Ï‰_a.grids[1].cost_in[h_interval,1,1] #Prix d'achat â‚¬/kWh[m
[32m+[m[32m    cost_out = Ï‰_a.grids[1].cost_out[h_interval,1,1] #Prix de vente â‚¬/kWh[m
[32m+[m[32m    cout_depassement = microgrid.grids[1].cost_exceed[1,1] # Cout de dÃ©passement de la puissance souscrite au rÃ©seau â‚¬/h[m
[32m+[m
[32m+[m[32m    # Variables d'environement (imposÃ©es)[m
[32m+[m[32m    p_load = Ï‰_a.demands[1].power[h_interval,1,1] # Demande en kWh[m
[32m+[m[32m    p_gen = Ï‰_a.generations[1].power[h_interval,1,1] # Puissance par unitÃ© de kWc installÃ©[m[41m [m
[32m+[m
[32m+[m[32m    #### Configuration des variables dÃ©crivant les composant pour le modÃ¨le de prog mathÃ©matique[m
[32m+[m[32m    liion = microgrid.storages[1][m
[32m+[m
[32m+[m[32m    Î·_self = liion.eff_model.Î·_self #Facreur d'auto-dÃ©charge[m
[32m+[m[32m    Î· = liion.eff_model.Î·_ch # Rendement[m
[32m+[m[32m    âˆ†h = 1. # taille du pas d'opÃ©ration[m
[32m+[m[32m    seuil_max = liion.Î±_soc_max # SoC max[m
[32m+[m[32m    seuil_min = liion.Î±_soc_min # SoC min[m
[32m+[m[32m    C_rate = liion.eff_model.Î±_p_ch # C-rate max[m
[32m+[m
[32m+[m[32m    Erated = 20. # CapacitÃ© de la batterie kWh[m
[32m+[m[32m    PV = 10. # Puissance du panneau solaire kWc[m
[32m+[m[32m    grid_seuil = 10. # puissance souscrite au rÃ©seau kW[m
 [m
     # On ajoute Ã  la fonction de cout une notion de dÃ©passement. On considÃ¨re un seuil de demande horaire au dessus duquel on paye un surcout[m
    [m
     M = 10000. #Valeur big-M pour les contraintes de type "if-else"[m
 [m
     #DÃ©claration du model et du solver[m
[31m-    m2 = Model(solver.Optimizer)[m
[32m+[m[32m    m2 = Model(Gurobi.Optimizer)[m
 [m
     #variables de dÃ©cisions[m
[31m-    @variable(m2, p_ch[1:length(h_interval)] >= 0.)[m
[31m-    @variable(m2, p_dch[1:length(h_interval)] >= 0.)[m
[32m+[m[32m    @variable(m2, p_ch1[1:length(h_interval)] >= 0.)[m
[32m+[m[32m    @variable(m2, p_ch2[1:length(h_interval)] >= 0.)[m
[32m+[m
[32m+[m[32m    @variable(m2, p_dch1[1:length(h_interval)] >= 0.)[m
[32m+[m[32m    @variable(m2, p_dch2[1:length(h_interval)] >= 0.)[m
[32m+[m
[32m+[m
[32m+[m[32m    @variable(m2, z1[1:(length(h_interval))], Bin)[m
[32m+[m[32m    @variable(m2, z2[1:(length(h_interval))], Bin)[m
[32m+[m[32m    eff1 = 0.97[m
[32m+[m[32m    eff2 = 0.93[m
[32m+[m
 [m
     #variables de recours (formulÃ©e comme des variables de dÃ©cisions)[m
     @variable(m2, p_in[1:length(h_interval)] >= 0.)[m
[36m@@ -312,16 +371,27 @@[m [mfunction get_model_2(solver)[m
     #La variable de dÃ©passement[m
     @variable(m2, depassement[1:(length(h_interval))], Bin)[m
 [m
[32m+[m[32m    @constraints(m2, begin[m
[32m+[m[32m        #Toujours un unique morceau actif[m
[32m+[m[32m        [h in 1:length(h_interval)], m2[:z1][h] + m2[:z2][h] == 1[m
[32m+[m
[32m+[m[32m        # Le rendement 1 c'est pour les valeur de C_rate 1/2 de max[m
[32m+[m[32m        [h in 1:length(h_interval)], m2[:p_dch1][h] <= m2[:z1][h] * C_rate * Erated /2[m
[32m+[m[32m        [h in 1:length(h_interval)], m2[:p_ch1][h] <= m2[:z1][h] * C_rate * Erated /2[m
[32m+[m
[32m+[m[32m        [h in 1:length(h_interval)], m2[:p_dch2][h] <= m2[:z2][h] * C_rate * Erated[m
[32m+[m[32m        [h in 1:length(h_interval)], m2[:p_ch2][h] <= m2[:z2][h] * C_rate * Erated[m
[32m+[m
[32m+[m[32m    end)[m
[32m+[m
 [m
     @constraints(m2, begin[m
     #dynamique de l'Ã©tat de la batterie[m
[31m-        [h in 1:length(h_interval)], m2[:soc][h+1] == m2[:soc][h] * (1-Î·_self * âˆ†h) - (m2[:p_dch][h] / Î· - m2[:p_ch][h] * Î·) * âˆ†h[m
[32m+[m[32m        [h in 1:length(h_interval)], m2[:soc][h+1] == m2[:soc][h] * (1-Î·_self * âˆ†h) - (m2[:p_dch1][h] / eff1 + m2[:p_dch2][h] / eff2 - m2[:p_ch1][h] * eff1 - m2[:p_ch2][h] * eff2) * âˆ†h[m
     #bornes du soc[m
         [h in 1:(length(h_interval)+1)], m2[:soc][h] <= seuil_max * Erated[m
         [h in 1:(length(h_interval)+1)], m2[:soc][h] >= seuil_min * Erated[m
[31m-    #Borne de puissance[m
[31m-        [h in 1:length(h_interval)], m2[:p_ch][h] <= Erated * C_rate[m
[31m-        [h in 1:length(h_interval)], m2[:p_dch][h] <= Erated * C_rate[m
[32m+[m
     #initialisation et pÃ©riodicitÃ©[m
         m2[:soc][1] == 0.5 * Erated[m
         m2[:soc][end] >= m2[:soc][1][m
[36m@@ -329,7 +399,7 @@[m [mfunction get_model_2(solver)[m
 [m
             [m
     @constraints(m2, begin[m
[31m-        [h in 1:length(h_interval)],  p_load[h] - (p_gen[h] * PV) + m2[:p_ch][h] - m2[:p_dch][h] - m2[:p_in][h] + m2[:p_out][h] == 0[m
[32m+[m[32m        [h in 1:length(h_interval)],  p_load[h] - (p_gen[h] * PV) + m2[:p_ch1][h] + m2[:p_ch2][h] - m2[:p_dch1][h] - m2[:p_dch2][h] - m2[:p_in][h] + m2[:p_out][h] == 0[m
     end)[m
 [m
     @constraints(m2, begin[m
[36m@@ -352,7 +422,30 @@[m [mend[m
 ######################### Model 3 ##############################[m
 ################################################################[m
 [m
[31m-function get_model_3()[m
[32m+[m[32mfunction get_model_3(h_interval)[m
[32m+[m
[32m+[m[32m     # Couts associÃ©s au grid[m[41m [m
[32m+[m[32m     cost_in = Ï‰_a.grids[1].cost_in[h_interval,1,1] #Prix d'achat â‚¬/kWh[m
[32m+[m[32m     cost_out = Ï‰_a.grids[1].cost_out[h_interval,1,1] #Prix de vente â‚¬/kWh[m
[32m+[m[32m     cout_depassement = microgrid.grids[1].cost_exceed[1,1] # Cout de dÃ©passement de la puissance souscrite au rÃ©seau â‚¬/h[m
[32m+[m[41m [m
[32m+[m[32m     # Variables d'environement (imposÃ©es)[m
[32m+[m[32m     p_load = Ï‰_a.demands[1].power[h_interval,1,1] # Demande en kWh[m
[32m+[m[32m     p_gen = Ï‰_a.generations[1].power[h_interval,1,1] # Puissance par unitÃ© de kWc installÃ©[m[41m [m
[32m+[m[41m [m
[32m+[m[32m     #### Configuration des variables dÃ©crivant les composant pour le modÃ¨le de prog mathÃ©matique[m
[32m+[m[32m     liion = microgrid.storages[1][m
[32m+[m[41m [m
[32m+[m[32m     Î·_self = liion.eff_model.Î·_self #Facreur d'auto-dÃ©charge[m
[32m+[m[32m     Î· = liion.eff_model.Î·_ch # Rendement[m
[32m+[m[32m     âˆ†h = 1. # taille du pas d'opÃ©ration[m
[32m+[m[32m     seuil_max = liion.Î±_soc_max # SoC max[m
[32m+[m[32m     seuil_min = liion.Î±_soc_min # SoC min[m
[32m+[m[32m     C_rate = liion.eff_model.Î±_p_ch # C-rate max[m
[32m+[m[41m [m
[32m+[m[32m     Erted = 20. # CapacitÃ© de la batterie kWh[m
[32m+[m[32m     PV = 10. # Puissance du panneau solaire kWc[m
[32m+[m[32m     grid_seuil = 10. # puissance souscrite au rÃ©seau kW[m
         [m
     # On ajoute Ã  la fonction de cout une notion de dÃ©passement. On considÃ¨re un seuil de demande horaire au dessus duquel on paye un surcout[m
     M = 10000. #Valeur big-M pour les contraintes de type "if-else"[m
[36m@@ -360,7 +453,7 @@[m [mfunction get_model_3()[m
     #DÃ©claration du model et du solver[m
     m3 = Model(Gurobi.Optimizer)[m
     set_attribute(m3, "non_convex", 2)[m
[31m-    set_attribute(m3, "TimeLimit", 200)[m
[32m+[m[32m    set_optimizer_attribute(m3, "MIPGap", 10^(-1))[m
 [m
 [m
     #variables de dÃ©cisions[m
[36m@@ -371,36 +464,43 @@[m [mfunction get_model_3()[m
     @variable(m3, p_in[1:length(h_interval)] >= 0.)[m
     @variable(m3, p_out[1:length(h_interval)] >= 0.)[m
 [m
[32m+[m[32m    @variable(m3, Î·_ch[1:length(h_interval)] >= 0.)[m
[32m+[m[32m    @variable(m3, Î·_dch[1:length(h_interval)] >= 0.)[m
[32m+[m
     # variables d'Ã©tat, formulÃ© comme un variable de dÃ©cisions mais contraintes.[m
     @variable(m3, soc[1:(length(h_interval)+1)])[m
 [m
     #La variable de dÃ©passement[m
     @variable(m3, depassement[1:(length(h_interval))], Bin)[m
 [m
[31m-    @variable(m3, Î·_ch[1:(length(h_interval))])[m
[31m-    @variable(m3, Î·_dch[1:(length(h_interval))])[m
 [m
[32m+[m[32m    @variable(m3, Erated[1:(length(h_interval)+1)] >= 0)[m[41m    [m
 [m
 [m
     @constraints(m3, begin[m
     #dynamique de l'Ã©tat de la batterie[m
[31m-        [h in 1:length(h_interval)], m3[:soc][h+1] == m3[:soc][h] * (1-Î·_self * âˆ†h) - (m3[:p_dch][h] * m3[:Î·_dch][h] - m3[:p_ch][h] * m3[:Î·_ch][h]) * âˆ†h[m
[32m+[m[32m    [h in 1:length(h_interval)], m3[:soc][h+1] == m3[:soc][h] * (1-Î·_self * âˆ†h) - (m3[:p_dch][h] * m3[:Î·_dch][h] - m3[:p_ch][h] * m3[:Î·_ch][h]) * âˆ†h[m
[32m+[m[32m    #dynamique du soh[m[41m [m
[32m+[m[32m    [h in 1:length(h_interval)], m3[:Erated][h+1] == m3[:Erated][h] - (m3[:p_dch][h] * m3[:Î·_dch][h] + m3[:p_ch][h] * m3[:Î·_ch][h]) * 0.002[m
     #bornes du soc[m
[31m-        [h in 1:(length(h_interval)+1)], m3[:soc][h] <= seuil_max * Erated[m
[31m-        [h in 1:(length(h_interval)+1)], m3[:soc][h] >= seuil_min * Erated[m
[32m+[m[32m        [h in 1:(length(h_interval)+1)], m3[:soc][h] <= seuil_max * m3[:Erated][h][m
[32m+[m
[32m+[m[32m        [h in 1:(length(h_interval)+1)], m3[:soc][h] >= seuil_min * m3[:Erated][h][m
[32m+[m
     #Borne de puissance[m
[31m-        [h in 1:length(h_interval)], m3[:p_ch][h] <= Erated * C_rate[m
[31m-        [h in 1:length(h_interval)], m3[:p_dch][h] <= Erated * C_rate[m
[32m+[m[32m        [h in 1:length(h_interval)], m3[:p_ch][h] <=  m3[:Erated][h] * C_rate[m
[32m+[m[32m        [h in 1:length(h_interval)], m3[:p_dch][h] <=  m3[:Erated][h] * C_rate[m
     #initialisation et pÃ©riodicitÃ©[m
[31m-        m3[:soc][1] == 0.5 * Erated[m
[32m+[m[32m        m3[:soc][1] == 0.5 * m3[:Erated][1][m
         m3[:soc][end] >= m3[:soc][1][m
 [m
[31m-        [h in 1:length(h_interval)], m3[:Î·_ch][h] == 1 - (m3[:p_ch][h])/(Erated * C_rate * 5) [m
[31m-        [h in 1:length(h_interval)], m3[:Î·_dch][h] == 1 + (m3[:p_dch][h])/(Erated * C_rate * 5) [m
[32m+[m[32m        m3[:Erated][1] == Erted[m
[32m+[m
[32m+[m[32m        [h in 1:length(h_interval)], m3[:Î·_dch][h] == 2.05 - m3[:Erated][h]/Erted[m[41m  [m
[32m+[m[32m        [h in 1:length(h_interval)], m3[:Î·_ch][h] == m3[:Erated][h]/Erted - 0.05[m
 [m
     end)[m
 [m
[31m-            [m
     @constraints(m3, begin[m
         [h in 1:length(h_interval)],  p_load[h] - (p_gen[h] * PV) + m3[:p_ch][h] - m3[:p_dch][h] - m3[:p_in][h] + m3[:p_out][h] == 0[m
     end)[m
[36m@@ -419,18 +519,80 @@[m [mend[m
 ######################################################################################[m
 [m
 [m
[32m+[m[32mh_interval = 1:144[m
[32m+[m
[32m+[m[32mmod1 = get_model_1(h_interval)[m
[32m+[m[32mJuMP.optimize!(mod1)[m
[32m+[m
[32m+[m[32mprintln("La solution optimale vaut : ", round(objective_value(mod1), digits=2), " â‚¬")[m
[32m+[m[32mprintln("Le problÃ¨me Ã  Ã©tÃ© rÃ©solu en : ", round(solve_time(mod1), digits=2), " secondes")[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32mmod2 = get_model_2(h_interval)[m
[32m+[m[32mJuMP.optimize!(mod2)[m
 [m
[32m+[m[32mprintln("La solution optimale vaut : ", round(objective_value(mod2), digits=2), " â‚¬")[m
[32m+[m[32mprintln("Le problÃ¨me Ã  Ã©tÃ© rÃ©solu en : ", round(solve_time(mod2), digits=2), " secondes")[m
 [m
 [m
 [m
[32m+[m[32mmod3 = get_model_3(h_interval)[m
[32m+[m[32mJuMP.optimize!(mod3)[m
 [m
[32m+[m[32mprintln("La solution optimale vaut : ", round(objective_value(mod3), digits=2), " â‚¬")[m
[32m+[m[32mprintln("Le problÃ¨me Ã  Ã©tÃ© rÃ©solu en : ", round(solve_time(mod3), digits=2), " secondes")[m
 [m
[32m+[m[32mT1 = [][m
[32m+[m[32mT2 = [][m
[32m+[m[32mT3 = [][m
 [m
[32m+[m[32mminlp_exec = true[m
 [m
[32m+[m[32mfor h_max in 24:24:(24*15)[m
[32m+[m[32m    h_interval = 1:h_max[m
[32m+[m
[32m+[m[32m    mod1 = get_model_1(h_interval)[m
[32m+[m[32m    JuMP.optimize!(mod1)[m
[32m+[m[41m    [m
[32m+[m[32m    println("La solution optimale vaut : ", round(objective_value(mod1), digits=2), " â‚¬")[m
[32m+[m[32m    println("Le problÃ¨me Ã  Ã©tÃ© rÃ©solu en : ", round(solve_time(mod1), digits=2), " secondes")[m
[32m+[m
[32m+[m[32m    push!(T1, solve_time(mod1))[m
[32m+[m[41m    [m
[32m+[m[32m    mod2 = get_model_2(h_interval)[m
[32m+[m[32m    JuMP.optimize!(mod2)[m
[32m+[m[41m    [m
[32m+[m[32m    println("La solution optimale vaut : ", round(objective_value(mod2), digits=2), " â‚¬")[m
[32m+[m[32m    println("Le problÃ¨me Ã  Ã©tÃ© rÃ©solu en : ", round(solve_time(mod2), digits=2), " secondes")[m
[32m+[m[41m    [m
[32m+[m[32m    push!(T2, solve_time(mod2))[m
[32m+[m
[32m+[m[32m    if solve_time(mod3) > 100[m
[32m+[m[32m        minlp_exec = false[m
[32m+[m[32m    end[m
[32m+[m
[32m+[m[32m    if minlp_exec[m
[32m+[m[32m        mod3 = get_model_3(h_interval)[m
[32m+[m[32m        JuMP.optimize!(mod3)[m
[32m+[m[41m        [m
[32m+[m[32m        println("La solution optimale vaut : ", round(objective_value(mod3), digits=2), " â‚¬")[m
[32m+[m[32m        println("Le problÃ¨me Ã  Ã©tÃ© rÃ©solu en : ", round(solve_time(mod3), digits=2), " secondes")[m
[32m+[m
[32m+[m[32m        push!(T3, solve_time(mod3))[m
[32m+[m[32m    else[m
[32m+[m[32m        push!(T3, 100)[m
[32m+[m[32m    end[m
[32m+[m
[32m+[m[32mend[m
 [m
 [m
 [m
[32m+[m[32mdays = [x for x in 1:365][m
 [m
[32m+[m[32md = Dict("LP"=>T1, "MILP"=>T2, "MINLP"=>T3, "days"=> days)[m
[32m+[m[32mCSV.write("duration.csv", d)[m
 [m
 [m
 [m
[36m@@ -488,7 +650,7 @@[m [mmicrogrid = Microgrid(parameters = GlobalParameters(nh, ny, ns, renewable_share[m
 # Add the equipment to the microgrid[m
 add!(microgrid, Demand(carrier = Electricity()),[m
                 Solar(),[m
[31m-                Liion(SoC_model = LinearLiionEfficiency(), SoH_model = SemiEmpiricalLiion(), couplage = (E=false, R = false)),[m
[32m+[m[32m                Liion(eff_model = FixedLiionEfficiency(), SoH_model = SemiEmpiricalLiion(), couplage = (E=false, R = false)),[m
                 Grid(carrier = Electricity()))[m
                 [m
 [m
[36m@@ -514,12 +676,12 @@[m [mp_gen = Ï‰_a.generations[1].power[h_interval,1,1][m
 [m
 liion = microgrid.storages[1][m
 [m
[31m-Î·_self = liion.SoC_model.Î·_self[m
[31m-Î· = liion.SoC_model.Î·_ch[m
[32m+[m[32mÎ·_self = liion.eff_model.Î·_self[m
[32m+[m[32mÎ· = liion.eff_model.Î·_ch[m
 âˆ†h = 1.[m
 seuil_max = liion.Î±_soc_max[m
 seuil_min = liion.Î±_soc_min[m
[31m-C_rate = liion.SoC_model.Î±_p_ch[m
[32m+[m[32mC_rate = liion.eff_model.Î±_p_ch[m
 [m
 [m
 Erated = 20.[m
[1mdiff --git a/Cours/Cours2/TP2.2.jl b/Cours/Cours2/TP2.2.jl[m
[1mindex 92f3464..9694502 100644[m
[1m--- a/Cours/Cours2/TP2.2.jl[m
[1m+++ b/Cours/Cours2/TP2.2.jl[m
[36m@@ -11,7 +11,7 @@[m [mmicrogrid = Microgrid(parameters = GlobalParameters(nh, ny, ns, renewable_share[m
 # Add the equipment to the microgrid[m
 add!(microgrid, Demand(carrier = Electricity()),[m
                 Solar(),[m
[31m-                Liion(SoC_model = PolynomialLiionEfficiency(), SoH_model = SemiEmpiricalLiion()),[m
[32m+[m[32m                Liion(eff_model = PolynomialLiionEfficiency(), SoH_model = SemiEmpiricalLiion()),[m
                 Grid(carrier = Electricity()))[m
                 [m
 using JLD2, FileIO[m
[1mdiff --git a/Cours/post-cours/Multi-obj.jl b/Cours/post-cours/Multi-obj.jl[m
[1mindex 6b3d0bf..87a0362 100644[m
[1m--- a/Cours/post-cours/Multi-obj.jl[m
[1m+++ b/Cours/post-cours/Multi-obj.jl[m
[36m@@ -42,9 +42,9 @@[m [mplotlyjs()[m
 [m
 microgrid = Microgrid(parameters = GlobalParameters(nh, ny, ns, renewable_share = .5))[m
 [m
[31m-fc =  FuelCell(;V_J_ini = V_J_FC, SoH_model = PowerAgingFuelCell(;deg_params=deg, StartStop = true))[m
[32m+[m[32mfc =  FuelCell(;V_J_ini = V_J_FC, SoH_model = PowerAgingFuelCell(;deg_params=deg, start_stop = true))[m
 elyz = Electrolyzer(;V_J_ini = V_J_Elyz)[m
[31m-liion =  Liion(SoC_model = PolynomialLiionEfficiency(), SoH_model = SemiEmpiricalLiion())[m
[32m+[m[32mliion =  Liion(eff_model = PolynomialLiionEfficiency(), SoH_model = SemiEmpiricalLiion())[m
 # Add the equipment to the microgrid[m
 add!(microgrid, Demand(carrier = Electricity()),[m
                 Solar(),[m
[1mdiff --git a/Cours/post-cours/auxiliaire.jl b/Cours/post-cours/auxiliaire.jl[m
[1mindex 501a173..0898baf 100644[m
[1m--- a/Cours/post-cours/auxiliaire.jl[m
[1m+++ b/Cours/post-cours/auxiliaire.jl[m
[36m@@ -131,7 +131,7 @@[m [mend[m
 [m
 ### Preallocation[m
 function preallocate!(elyz::Electrolyzer, nh::Int64, ny::Int64, ns::Int64)[m
[31m-    elyz.EffModel.powerMax = convert(SharedArray,zeros(nh+1, ny+1, ns)) ;  elyz.EffModel.powerMax[1,1,:] .= elyz.EffModel.powerMax_ini[m
[32m+[m[32m    elyz.eff_model.powerMax = convert(SharedArray,zeros(nh+1, ny+1, ns)) ;  elyz.eff_model.powerMax[1,1,:] .= elyz.eff_model.powerMax_ini[m
     elyz.Î· = convert(SharedArray,zeros(nh+1, ny+1, ns))[m
   [m
     elyz.carrier = [Electricity(), Heat(), Hydrogen()][m
[36m@@ -143,14 +143,14 @@[m [mfunction preallocate!(elyz::Electrolyzer, nh::Int64, ny::Int64, ns::Int64)[m
   [m
     elyz.SoH_model.V_J_ini = convert(SharedArray, zeros(3, length(elyz.V_J_ini[1,:]))) #J, V, P[m
     elyz.SoH_model.V_J = convert(SharedArray, zeros(3, length(elyz.V_J_ini[1,:]), ns)) #J, V, P[m
[31m-    elyz.EffModel.V_J = convert(SharedArray, zeros(3, length(elyz.V_J_ini[1,:]), ns)) #J, V, P[m
[32m+[m[32m    elyz.eff_model.V_J = convert(SharedArray, zeros(3, length(elyz.V_J_ini[1,:]), ns)) #J, V, P[m
   [m
[31m-    if elyz.EffModel isa LinearElectrolyzerEfficiency[m
[31m-        elyz.EffModel.a_Î· =  convert(SharedArray, zeros(ns))[m
[31m-        elyz.EffModel.b_Î· = convert(SharedArray, zeros(ns))[m
[32m+[m[32m    if elyz.eff_model isa LinearElectrolyzerEfficiency[m
[32m+[m[32m        elyz.eff_model.a_Î· =  convert(SharedArray, zeros(ns))[m
[32m+[m[32m        elyz.eff_model.b_Î· = convert(SharedArray, zeros(ns))[m
     end[m
 [m
[31m-    elyz.EffModel.compresseur.pression_H2 = convert(SharedArray, zeros(ns))[m
[32m+[m[32m    elyz.eff_model.compresseur.pression_H2 = convert(SharedArray, zeros(ns))[m
 [m
     return elyz[m
 end[m
[36m@@ -192,7 +192,7 @@[m [mfunction share_info_bw_assets!(h::Int64, y::Int64, s::Int64, mg::Microgrid)[m
     id_elyz = findfirst(a isa Electrolyzer for a in mg.converters)[m
     id_tank = findfirst(a isa H2Tank for a in mg.storages)[m
     if !isnothing(id_elyz) && !isnothing(id_tank)[m
[31m-        mg.converters[id_elyz].EffModel.compresseur.pression_H2[s] = get_pression(mg.storages[id_tank], h,y,s)[m
[32m+[m[32m        mg.converters[id_elyz].eff_model.compresseur.pression_H2[s] = get_pression(mg.storages[id_tank], h,y,s)[m
     end[m
 end[m
 [m
[36m@@ -294,7 +294,7 @@[m [mdeg = create_deg_params(datas_deg_FC, current_densities, V_J_FC, J_ref, obj_hour[m
 [m
 microgrid = Microgrid(parameters = GlobalParameters(nh, ny, ns, renewable_share = .5))[m
 [m
[31m-elyz = Electrolyzer(;V_J_ini = V_J_Elyz, EffModel = PolarizationElectrolyzerEfficiency2())[m
[32m+[m[32melyz = Electrolyzer(;V_J_ini = V_J_Elyz, eff_model = PolarizationElectrolyzerEfficiency2())[m
 fc = FuelCell(;V_J_ini = V_J_FC, SoH_model = PowerAgingFuelCell(;deg_params=deg))[m
 [m
 # Add the equipment to the microgrid[m
[1mdiff --git a/Project.toml b/Project.toml[m
[1mindex 31d23bc..7b8c586 100644[m
[1m--- a/Project.toml[m
[1m+++ b/Project.toml[m
[36m@@ -4,12 +4,14 @@[m [mauthors = ["Hugo <hugo.radet@gmail.com> and contributors"][m
 version = "0.1.0"[m
 [m
 [deps][m
[32m+[m[32mAlpine = "07493b3f-dabb-5b16-a503-4139292d7dd4"[m
 AmplNLWriter = "7c4d4715-977e-5154-bfe0-e096adeac482"[m
 BenchmarkTools = "6e4b80f9-dd63-53aa-95a3-0cdb28fa8baf"[m
 Bonmin_jll = "29cba6d7-6840-5cf2-a2fa-9bdfccfe29ea"[m
 CSV = "336ed68f-0bac-5ca0-87d4-7b16caf5d00b"[m
 Cbc = "9961bab8-2fa3-5c5a-9d89-47fab24efd76"[m
 Clustering = "aaaa29a8-35af-508c-8bc3-b662a17a0fe5"[m
[32m+[m[32mCombinatorics = "861a8166-3701-5b0c-9a16-15d98fcdc6aa"[m
 Conda = "8f4d0f93-b110-5947-807f-2305c1781a2d"[m
 DataFrames = "a93c6f00-e57d-5684-b7b6-d8193f3e46c0"[m
 Dates = "ade2ca70-3891-5945-98fb-dc099432e06a"[m
[36m@@ -25,9 +27,10 @@[m [mGurobi = "2e9cd046-0924-5485-92f1-d5272153d98b"[m
 ImageShow = "4e3cecfd-b093-5904-9786-8bbb286a6a31"[m
 InspectDR = "d0351b0e-4b05-5898-87b3-e2a8edfddd1d"[m
 Interpolations = "a98d9a8b-a2ab-59e6-89dd-64a1c18fca59"[m
[32m+[m[32mInvertedIndices = "41ab1584-1d38-5bbf-9106-f11c6c58b48f"[m
 JLD = "4138dd39-2aa7-5051-a626-17a0bb65d9c8"[m
 JuMP = "4076af6c-e467-56ae-b986-b466b2749572"[m
[31m-Lathe = "38d8eb38-e7b1-11e9-0012-376b6c802672"[m
[32m+[m[32mJuniper = "2ddba703-00a4-53a7-87a5-e8b9971dde84"[m
 LinearAlgebra = "37e2e46d-f89d-539d-b4ee-838fcccc9c8e"[m
 MultivariateStats = "6f286f6a-111f-5878-ab1e-185364afe411"[m
 NSGAII = "0faa7b20-5579-4646-b419-11e3eab23b57"[m
[1mdiff --git a/docs/src/assets/liion/liion_electro_chimique.jl b/docs/src/assets/liion/liion_electro_chimique.jl[m
[1mindex 89076ff..f7aa47b 100644[m
[1m--- a/docs/src/assets/liion/liion_electro_chimique.jl[m
[1m+++ b/docs/src/assets/liion/liion_electro_chimique.jl[m
[36m@@ -5,7 +5,7 @@[m
 #[1] Modeling of Lithium-Ion Battery Degradation for Cell Life Assessment[m
 #Authors : Bolun Xu, Student Member, IEEE, Alexandre Oudalov, Andreas Ulbig, Member, IEEE, GÃ¶ran Andersson, Fellow, IEEE, and Daniel S. Kirschen, Fellow, IEEE[m
 [m
[31m-soc_model_names = ["tremblay_dessaint", "linear", "vermeer", "artificial"][m
[32m+[m[32meff_model_names = ["tremblay_dessaint", "linear", "vermeer", "artificial"][m
 [m
 mutable struct Electro_chimique_params[m
    alpha_sei::Float64[m
[36m@@ -55,7 +55,7 @@[m [mThe structure have a lot of parameters but most of them are set to default value[m
   - `SoH_threshold::Float64`: SoH level to replace the battery (default : 0.8)[m
   - `couplage::NamedTuple`: Named tuple with two boolean values to indicate if the SoH should influence the other parameters (E stand for capacity coupling and R for efficiency coupling)[m
   - `temperature::Float64`: Temperature of the battery (no temprature model is implemented for the battery).[m
[31m-  - `soc_model::String`: Model name for State of Charge (SoC) computation. Available models are listed [m
[32m+[m[32m  - `eff_model::String`: Model name for State of Charge (SoC) computation. Available models are listed[m[41m [m
   - `calendar::Bool`: Whether to include calendar aging in the SoH computation  (default : true)[m
   - `soc_ini::Float64`: Initial State of Charge (SoC) for the beginning of the simulation (default : 0.5)[m
   - `soh_ini::Float64`: Initial State of Health (SoH) for the beginning of the simulation (default : 1)[m
[36m@@ -64,7 +64,7 @@[m [mThe structure have a lot of parameters but most of them are set to default value[m
 [m
 ## Example [m
 ```julia[m
[31m-Liion_electro_chimique(update_by_year = 12, soc_model = "linear", couplage = (E=true, R=true))[m
[32m+[m[32mLiion_electro_chimique(update_by_year = 12, eff_model = "linear", couplage = (E=true, R=true))[m
 ```[m
 """[m
    mutable struct Liion_electro_chimique <: AbstractLiion[m
[36m@@ -87,7 +87,7 @@[m [mLiion_electro_chimique(update_by_year = 12, soc_model = "linear", couplage = (E=[m
 	temperature::Float64[m
 [m
    	#Model dynamics[m
[31m-   	soc_model::String #model name[m
[32m+[m[41m   [m	[32meff_model::String #model name[m
 [m
    	# Initial conditions[m
    	Erated_ini::Float64  # capacitÃ© de la batterie en Wh[m
[36m@@ -128,15 +128,15 @@[m [mLiion_electro_chimique(update_by_year = 12, soc_model = "linear", couplage = (E=[m
    		SoH_threshold = 0.8,[m
    		couplage = (E = true, R = false),[m
 		temperature = 298,[m
[31m-   		soc_model = "linear",[m
[32m+[m[41m   [m		[32meff_model = "linear",[m
    		Erated_ini = 1e-6,[m
    		soc_ini = 0.5,[m
    		soh_ini = 1.,[m
    		update_by_year = 12,[m
 		artificial_soc_profil = zeros(8760,1)) =  verification_liion_params(Î±_p_ch, Î±_p_dch, Î·_ch, Î·_dch, Î·_self, Î±_soc_min, Î±_soc_max, lifetime, nCycle, bounds,[m
[31m-   			SoH_threshold, couplage, soc_model, Erated_ini, soc_ini, soh_ini, update_by_year, artificial_soc_profil) ?[m
[32m+[m[41m   [m			[32mSoH_threshold, couplage, eff_model, Erated_ini, soc_ini, soh_ini, update_by_year, artificial_soc_profil) ?[m
    			new(Î±_p_ch, Î±_p_dch, Î·_ch, Î·_dch, Î·_self, Î±_soc_min, Î±_soc_max, lifetime, nCycle, bounds,[m
[31m-   			SoH_threshold, couplage, temperature, soc_model, Erated_ini, soc_ini, soh_ini, update_by_year, artificial_soc_profil) : nothing[m
[32m+[m[41m   [m			[32mSoH_threshold, couplage, temperature, eff_model, Erated_ini, soc_ini, soh_ini, update_by_year, artificial_soc_profil) : nothing[m
 [m
 end[m
 [m
[36m@@ -145,7 +145,7 @@[m [mend[m
      liion.Erated = convert(SharedArray,zeros(ny+1, ns)) ; liion.Erated[1,:] .= liion.Erated_ini[m
      liion.carrier = Electricity()[m
      liion.carrier.power = convert(SharedArray,zeros(nh, ny, ns))[m
[31m-	 if liion.soc_model == "artificial"[m
[32m+[m	[32m if liion.eff_model == "artificial"[m
 		 liion.soc = convert(SharedArray,reshape(repeat(liion.artificial_soc_profil,ns), (nh+1,ny+1,ns)))[m
 	 else[m
 		 liion.soc = convert(SharedArray,zeros(nh+1, ny+1, ns)) ; liion.soc[1,1,:] .= liion.soc_ini[m
[36m@@ -163,11 +163,11 @@[m [mend[m
  ### Operation dynamic[m
 function compute_operation_dynamics!(h::Int64, y::Int64, s::Int64, liion::Liion_electro_chimique, decision::Float64, Î”h::Int64)[m
 [m
[31m-	if liion.soc_model == "tremblay_dessaint"[m
[32m+[m	[32mif liion.eff_model == "tremblay_dessaint"[m
 		liion.soc[h+1,y,s], liion.voltage[h+1,y,s], liion.carrier.power[h,y,s], liion.current[h,y,s] = compute_operation_soc_tremblay_dessaint(liion, (Erated = liion.Erated[y,s], soc = liion.soc[h,y,s], soh = liion.soh[h,y,s]),  liion.voltage[h,y,s], decision, Î”h)[m
[31m-	elseif  liion.soc_model == "linear"[m
[32m+[m	[32melseif  liion.eff_model == "linear"[m
 		liion.soc[h+1,y,s], liion.carrier.power[h,y,s] = compute_operation_soc_linear(liion, (Erated = liion.Erated[y,s], soc = liion.soc[h,y,s], soh = liion.soh[h,y,s]), decision, Î”h)[m
[31m-	elseif liion.soc_model == "artificial"[m
[32m+[m	[32melseif liion.eff_model == "artificial"[m
 [m
 	end[m
 [m
[36m@@ -332,7 +332,7 @@[m [mend[m
 [m
  function verification_liion_params(Î±_p_ch::Float64, Î±_p_dch::Float64, Î·_ch::Float64, Î·_dch::Float64, Î·_self::Float64,[m
  	Î±_soc_min::Float64, Î±_soc_max::Float64, lifetime::Int64, nCycle::Float64, bounds::NamedTuple{(:lb, :ub), Tuple{Float64, Float64}},[m
[31m- 	SoH_threshold::Float64, couplage::NamedTuple{(:E,:R), Tuple{Bool,Bool}}, soc_model::String, Erated_ini::Float64, soc_ini::Float64,[m
[32m+[m[41m [m	[32mSoH_threshold::Float64, couplage::NamedTuple{(:E,:R), Tuple{Bool,Bool}}, eff_model::String, Erated_ini::Float64, soc_ini::Float64,[m
  	soh_ini::Float64, update_by_year::Int64, artificial_soc_profil::Array{Float64,2})[m
 [m
  	validation = true[m
[36m@@ -348,8 +348,8 @@[m [mend[m
  		validation = false[m
  	end[m
 [m
[31m- 	if !(soc_model in soc_model_names)[m
[31m- 		error(soc_model ," is not an authorized Liion state of charge model. you need to pick one from the following list : ", soc_model_names)[m
[32m+[m[41m [m	[32mif !(eff_model in eff_model_names)[m
[32m+[m[41m [m		[32merror(eff_model ," is not an authorized Liion state of charge model. you need to pick one from the following list : ", eff_model_names)[m
  		validation = false[m
  	end[m
 [m
[1mdiff --git a/docs/src/assets/liion/liion_energy_exchanged.jl b/docs/src/assets/liion/liion_energy_exchanged.jl[m
[1mindex a6b15ae..32b52e0 100644[m
[1m--- a/docs/src/assets/liion/liion_energy_exchanged.jl[m
[1m+++ b/docs/src/assets/liion/liion_energy_exchanged.jl[m
[36m@@ -18,14 +18,14 @@[m [mThe structure have a lot of parameters but most of them are set to default value[m
 - `nCycle::Float64`: Number of cycle before reaching EOL (should be found in the cycle to failure curve)[m
 - `SoH_threshold::Float64`: SoH level to replace the battery (default : 0.8)[m
 - `couplage::NamedTuple`: Named tuple with two boolean values to indicate if the SoH should influence the other parameters (E stand for capacity coupling and R for efficiency coupling)[m
[31m-- `soc_model::String`: Model name for State of Charge (SoC) computation. Available models are listed [m
[32m+[m[32m- `eff_model::String`: Model name for State of Charge (SoC) computation. Available models are listed[m[41m [m
 - `calendar::Bool`: Whether to include calendar aging in the SoH computation  (default : true)[m
 - `soc_ini::Float64`: Initial State of Charge (SoC) for the beginning of the simulation (default : 0.5)[m
 - `soh_ini::Float64`: Initial State of Health (SoH) for the beginning of the simulation (default : 1)[m
 [m
 ## Example [m
 ```julia[m
[31m-Liion_energy_exchanged(;calendar = true, nCycle = fatigue_data.cycle[findfirst(fatigue_data.DoD .> (0.6))], soc_model = "polynomial", couplage = (E=true, R=true))[m
[32m+[m[32mLiion_energy_exchanged(;calendar = true, nCycle = fatigue_data.cycle[findfirst(fatigue_data.DoD .> (0.6))], eff_model = "polynomial", couplage = (E=true, R=true))[m
 ```[m
 [m
 Here the `nCycle` is selected from the cycle to failure curve using 60% DoD.[m
[36m@@ -48,7 +48,7 @@[m [mHere the `nCycle` is selected from the cycle to failure curve using 60% DoD.[m
  	couplage::NamedTuple{(:E, :R), Tuple{Bool, Bool}}  #a boolean tuple to tell wether or not the soh should influence the other parameters.[m
 [m
  	#Model dynamics[m
[31m- 	soc_model::String #model name[m
[32m+[m[41m [m	[32meff_model::String #model name[m
     calendar::Bool[m
 [m
  	# Initial conditions[m
[36m@@ -85,15 +85,15 @@[m [mHere the `nCycle` is selected from the cycle to failure curve using 60% DoD.[m
  		bounds = (lb = 0., ub = 1000.),[m
  		SoH_threshold = 0.8,[m
  		couplage = (E = true, R = false),[m
[31m- 		soc_model = "linear",[m
[32m+[m[41m [m		[32meff_model = "linear",[m
         calendar = true,[m
  		Erated_ini = 1e-6,[m
  		soc_ini = 0.5,[m
  		soh_ini = 1.,[m
         artificial_soc_profil = zeros(8760,1)) =  verification_liion_params(Î±_p_ch, Î±_p_dch, Î·_ch, Î·_dch, Î·_self, Î±_soc_min, Î±_soc_max, lifetime, nCycle, bounds,[m
[31m-            SoH_threshold, couplage, soc_model, calendar, Erated_ini, soc_ini, soh_ini, artificial_soc_profil) ?[m
[32m+[m[32m            SoH_threshold, couplage, eff_model, calendar, Erated_ini, soc_ini, soh_ini, artificial_soc_profil) ?[m
  			new(Î±_p_ch, Î±_p_dch, Î·_ch, Î·_dch, Î·_self, Î±_soc_min, Î±_soc_max, lifetime, nCycle, bounds,[m
[31m- 			SoH_threshold, couplage, soc_model, calendar, Erated_ini, soc_ini, soh_ini, artificial_soc_profil) : nothing[m
[32m+[m[41m [m			[32mSoH_threshold, couplage, eff_model, calendar, Erated_ini, soc_ini, soh_ini, artificial_soc_profil) : nothing[m
 [m
  end[m
 [m
[36m@@ -102,7 +102,7 @@[m [mfunction preallocate!(liion::Liion_energy_exchanged, nh::Int64, ny::Int64, ns::I[m
     liion.Erated = convert(SharedArray,zeros(ny+1, ns)) ; liion.Erated[1,:] .= liion.Erated_ini[m
     liion.carrier = Electricity()[m
     liion.carrier.power = convert(SharedArray,zeros(nh, ny, ns))[m
[31m-    if liion.soc_model == "artificial"[m
[32m+[m[32m    if liion.eff_model == "artificial"[m
         liion.soc = convert(SharedArray,reshape(repeat(liion.artificial_soc_profil,ns), (nh+1,ny+1,ns)))[m
     else[m
         liion.soc = convert(SharedArray,zeros(nh+1, ny+1, ns)) ; liion.soc[1,1,:] .= liion.soc_ini[m
[36m@@ -122,7 +122,7 @@[m [mend[m
 function compute_operation_dynamics!(h::Int64, y::Int64, s::Int64, liion::Liion_energy_exchanged, decision::Float64, Î”h::Int64)[m
 [m
     #Cycle part[m
[31m-    if liion.soc_model == "artificial"[m
[32m+[m[32m    if liion.eff_model == "artificial"[m
         liion.soh[h+1,y,s] = liion.soh[h,y,s] - (liion.Erated[y,s] * (abs(liion.soc[h+1,y,s] - liion.soc[h,y,s])))  / (2. * liion.nCycle * liion.Erated[y,s] * (liion.Î±_soc_max - liion.Î±_soc_min) )[m
     else[m
         liion.soc[h+1,y,s], liion.carrier.power[h,y,s] = compute_operation_soc_linear(liion, (Erated = liion.Erated[y,s], soc = liion.soc[h,y,s], soh = liion.soh[h,y,s]), decision, Î”h)[m
[36m@@ -170,7 +170,7 @@[m [mend[m
 [m
   ### Investment dynamic[m
   function compute_investment_dynamics!(y::Int64, s::Int64, liion::Liion_energy_exchanged, decision::Union{Float64, Int64})[m
[31m-      if liion.soc_model == "artificial"[m
[32m+[m[32m      if liion.eff_model == "artificial"[m
           liion.Erated[y+1,s], _, liion.soh[1,y+1,s], liion.voltage[1,y+1,s] = compute_investment_dynamics(liion, (Erated = liion.Erated[y,s], soc = liion.soc[end,y,s], soh = liion.soh[end,y,s], voltage = liion.voltage[end,y,s]), decision)[m
       else[m
           liion.Erated[y+1,s], liion.soc[1,y+1,s], liion.soh[1,y+1,s], liion.voltage[1,y+1,s] = compute_investment_dynamics(liion, (Erated = liion.Erated[y,s], soc = liion.soc[end,y,s], soh = liion.soh[end,y,s], voltage = liion.voltage[end,y,s]), decision)[m
[36m@@ -208,7 +208,7 @@[m [mend[m
 [m
  function verification_liion_params(Î±_p_ch::Float64, Î±_p_dch::Float64, Î·_ch::Float64, Î·_dch::Float64, Î·_self::Float64,[m
  	Î±_soc_min::Float64, Î±_soc_max::Float64, lifetime::Int64, nCycle::Float64, bounds::NamedTuple{(:lb, :ub), Tuple{Float64, Float64}},[m
[31m- 	SoH_threshold::Float64, couplage::NamedTuple{(:E,:R), Tuple{Bool,Bool}}, soc_model::String, calendar::Bool, Erated_ini::Float64, soc_ini::Float64,[m
[32m+[m[41m [m	[32mSoH_threshold::Float64, couplage::NamedTuple{(:E,:R), Tuple{Bool,Bool}}, eff_model::String, calendar::Bool, Erated_ini::Float64, soc_ini::Float64,[m
  	soh_ini::Float64, artificial_soc_profil::Array{Float64,2})[m
 [m
  	validation = true[m
[36m@@ -224,8 +224,8 @@[m [mend[m
  		validation = false[m
  	end[m
 [m
[31m- 	if !(soc_model in soc_model_names)[m
[31m- 		error(soc_model ," is not an authorized Liion state of charge model. you need to pick one from the following list : ", soc_model_names)[m
[32m+[m[41m [m	[32mif !(eff_model in eff_model_names)[m
[32m+[m[41m [m		[32merror(eff_model ," is not an authorized Liion state of charge model. you need to pick one from the following list : ", eff_model_names)[m
  		validation = false[m
  	end[m
 [m
[1mdiff --git a/docs/src/assets/liion/liion_fixed_lifetime.jl b/docs/src/assets/liion/liion_fixed_lifetime.jl[m
[1mindex 84fea93..46c095a 100644[m
[1m--- a/docs/src/assets/liion/liion_fixed_lifetime.jl[m
[1m+++ b/docs/src/assets/liion/liion_fixed_lifetime.jl[m
[36m@@ -20,13 +20,13 @@[m [mThe structure have a lot of parameters but most of them are set to default value[m
 - `Î±_soc_max::Float64`: Maximum threshold of charge (normalized) (default : 0.8)[m
 - `SoH_threshold::Float64`: SoH level to replace the battery (default : 0.8)[m
 - `couplage::NamedTuple`: Named tuple with two boolean values to indicate if the SoH should influence the other parameters (E stand for capacity coupling and R for efficiency coupling)[m
[31m-- `soc_model::String`: Model name for State of Charge (SoC) computation. Available models are listed [m
[32m+[m[32m- `eff_model::String`: Model name for State of Charge (SoC) computation. Available models are listed[m[41m [m
 - `soc_ini::Float64`: Initial State of Charge (SoC) for the beginning of the simulation (default : 0.5)[m
 - `soh_ini::Float64`: Initial State of Health (SoH) for the beginning of the simulation (default : 1)[m
 [m
 ## Example [m
 ```julia[m
[31m-Liion_fixed_lifetime(;soc_model = "polynomial", couplage = (E=true, R=true))[m
[32m+[m[32mLiion_fixed_lifetime(;eff_model = "polynomial", couplage = (E=true, R=true))[m
 ```[m
 [m
 """[m
[36m@@ -48,7 +48,7 @@[m [mLiion_fixed_lifetime(;soc_model = "polynomial", couplage = (E=true, R=true))[m
  	couplage::NamedTuple{(:E, :R), Tuple{Bool, Bool}}  #a boolean tuple to tell wether or not the soh should influence the other parameters.[m
 [m
  	#Model dynamics[m
[31m- 	soc_model::String #model name[m
[32m+[m[41m [m	[32meff_model::String #model name[m
 [m
  	# Initial conditions[m
  	Erated_ini::Float64  # capacitÃ© de la batterie en Wh[m
[36m@@ -82,13 +82,13 @@[m [mLiion_fixed_lifetime(;soc_model = "polynomial", couplage = (E=true, R=true))[m
  		bounds = (lb = 0., ub = 1000.),[m
  		SoH_threshold = 0.8,[m
  		couplage = (E = true, R = false),[m
[31m- 		soc_model = "linear",[m
[32m+[m[41m [m		[32meff_model = "linear",[m
  		Erated_ini = 1e-6,[m
  		soc_ini = 0.5,[m
  		soh_ini = 1.) =  verification_liion_params(Î±_p_ch, Î±_p_dch, Î·_ch, Î·_dch, Î·_self, Î±_soc_min, Î±_soc_max, lifetime, nCycle, bounds,[m
[31m-            SoH_threshold, couplage, soc_model, Erated_ini, soc_ini, soh_ini) ?[m
[32m+[m[32m            SoH_threshold, couplage, eff_model, Erated_ini, soc_ini, soh_ini) ?[m
  			new(Î±_p_ch, Î±_p_dch, Î·_ch, Î·_dch, Î·_self, Î±_soc_min, Î±_soc_max, lifetime, nCycle, bounds,[m
[31m- 			SoH_threshold, couplage, soc_model, Erated_ini, soc_ini, soh_ini) : nothing[m
[32m+[m[41m [m			[32mSoH_threshold, couplage, eff_model, Erated_ini, soc_ini, soh_ini) : nothing[m
 [m
  end[m
 [m
[36m@@ -177,7 +177,7 @@[m [mend[m
 [m
  function verification_liion_params(Î±_p_ch::Float64, Î±_p_dch::Float64, Î·_ch::Float64, Î·_dch::Float64, Î·_self::Float64,[m
  	Î±_soc_min::Float64, Î±_soc_max::Float64, lifetime::Int64, nCycle::Float64, bounds::NamedTuple{(:lb, :ub), Tuple{Float64, Float64}},[m
[31m- 	SoH_threshold::Float64, couplage::NamedTuple{(:E,:R), Tuple{Bool,Bool}}, soc_model::String, Erated_ini::Float64, soc_ini::Float64,[m
[32m+[m[41m [m	[32mSoH_threshold::Float64, couplage::NamedTuple{(:E,:R), Tuple{Bool,Bool}}, eff_model::String, Erated_ini::Float64, soc_ini::Float64,[m
  	soh_ini::Float64)[m
 [m
  	validation = true[m
[36m@@ -193,8 +193,8 @@[m [mend[m
  		validation = false[m
  	end[m
 [m
[31m- 	if !(soc_model in soc_model_names)[m
[31m- 		error(soc_model ," is not an authorized Liion state of charge model. you need to pick one from the following list : ", soc_model_names)[m
[32m+[m[41m [m	[32mif !(eff_model in eff_model_names)[m
[32m+[m[41m [m		[32merror(eff_model ," is not an authorized Liion state of charge model. you need to pick one from the following list : ", eff_model_names)[m
  		validation = false[m
  	end[m
 [m
[1mdiff --git a/docs/src/assets/liion/liion_rainflow.jl b/docs/src/assets/liion/liion_rainflow.jl[m
[1mindex 0e74d77..b686d93 100644[m
[1m--- a/docs/src/assets/liion/liion_rainflow.jl[m
[1m+++ b/docs/src/assets/liion/liion_rainflow.jl[m
[36m@@ -3,7 +3,7 @@[m
  =#[m
 [m
 [m
[31m- soc_model_names = ["tremblay_dessaint", "linear", "vermeer", "artificial"][m
[32m+[m[32m eff_model_names = ["tremblay_dessaint", "linear", "vermeer", "artificial"][m
 [m
 #rainflow ref : Optimal Battery Control Under Cycle Aging Mechanisms in Pay for Performance Settings[m
 # Yuanyuan Shi, Bolun Xu, Yushi Tan, Daniel Kirschen, Baosen Zhang[m
[36m@@ -21,7 +21,7 @@[m [mThe structure have a lot of parameters but most of them are set to default value[m
   - `Î±_soc_max::Float64`: Maximum threshold of charge (normalized) (default : 0.8)[m
   - `SoH_threshold::Float64`: SoH level to replace the battery (default : 0.8)[m
   - `couplage::NamedTuple`: Named tuple with two boolean values to indicate if the SoH should influence the other parameters (E stand for capacity coupling and R for efficiency coupling)[m
[31m-  - `soc_model::String`: Model name for State of Charge (SoC) computation. Available models are listed [m
[32m+[m[32m  - `eff_model::String`: Model name for State of Charge (SoC) computation. Available models are listed[m[41m [m
   - `calendar::Bool`: Whether to include calendar aging in the SoH computation  (default : true)[m
   - `soc_ini::Float64`: Initial State of Charge (SoC) for the beginning of the simulation (default : 0.5)[m
   - `soh_ini::Float64`: Initial State of Health (SoH) for the beginning of the simulation (default : 1)[m
[36m@@ -30,7 +30,7 @@[m [mThe structure have a lot of parameters but most of them are set to default value[m
 [m
 ## example[m
 ```julia[m
[31m-Liion_rainflow(update_by_year = 12, calendar = true, soc_model = "linear", couplage = (E=true, R=true))[m
[32m+[m[32mLiion_rainflow(update_by_year = 12, calendar = true, eff_model = "linear", couplage = (E=true, R=true))[m
 ```[m
 """[m
 mutable struct Liion_rainflow <: AbstractLiion[m
[36m@@ -49,7 +49,7 @@[m [mmutable struct Liion_rainflow <: AbstractLiion[m
 	couplage::NamedTuple{(:E, :R), Tuple{Bool, Bool}}  #a boolean tuple to tell wether or not the soh should influence the other parameters.[m
 [m
 	#Model dynamics[m
[31m-	soc_model::String #model name[m
[32m+[m	[32meff_model::String #model name[m
 	calendar::Bool[m
 [m
 	# Initial conditions[m
[36m@@ -93,7 +93,7 @@[m [mmutable struct Liion_rainflow <: AbstractLiion[m
 		bounds = (lb = 0., ub = 1000.),[m
 		SoH_threshold = 0.8,[m
 		couplage = (E = true, R = false),[m
[31m-		soc_model = "linear",[m
[32m+[m		[32meff_model = "linear",[m
 		calendar = true,[m
 		Erated_ini = 1e-6,[m
 		soc_ini = 0.5,[m
[36m@@ -102,9 +102,9 @@[m [mmutable struct Liion_rainflow <: AbstractLiion[m
 		fatigue_data = DataFrames.DataFrame(CSV.File("example\\data\\fatigue_data2.csv.csv", delim = ";", header = [Symbol("DoD"),Symbol("cycle")], types=Dict(:DoD=>Float64, :cycle=>Float64))),[m
 		artificial_soc_profil = zeros(8760,1)[m
 		) =  verification_liion_params(Î±_p_ch, Î±_p_dch, Î·_ch, Î·_dch, Î·_self, Î±_soc_min, Î±_soc_max, lifetime, nCycle, bounds,[m
[31m-			SoH_threshold, couplage, soc_model, calendar, Erated_ini, soc_ini, soh_ini, update_by_year, artificial_soc_profil) ?[m
[32m+[m			[32mSoH_threshold, couplage, eff_model, calendar, Erated_ini, soc_ini, soh_ini, update_by_year, artificial_soc_profil) ?[m
 			new(Î±_p_ch, Î±_p_dch, Î·_ch, Î·_dch, Î·_self, Î±_soc_min, Î±_soc_max, lifetime, nCycle, bounds,[m
[31m-			SoH_threshold, couplage, soc_model, calendar, Erated_ini, soc_ini, soh_ini, update_by_year, fatigue_data, artificial_soc_profil) : nothing[m
[32m+[m			[32mSoH_threshold, couplage, eff_model, calendar, Erated_ini, soc_ini, soh_ini, update_by_year, fatigue_data, artificial_soc_profil) : nothing[m
 end[m
 [m
 ### Preallocation[m
[36m@@ -112,7 +112,7 @@[m [mfunction preallocate!(liion::Liion_rainflow, nh::Int64, ny::Int64, ns::Int64)[m
 	liion.Erated = convert(SharedArray,zeros(ny+1, ns)) ; liion.Erated[1,:] .= liion.Erated_ini[m
 	liion.carrier = Electricity()[m
 	liion.carrier.power = convert(SharedArray,zeros(nh, ny, ns))[m
[31m-	if liion.soc_model == "artificial"[m
[32m+[m	[32mif liion.eff_model == "artificial"[m
    	 liion.soc = convert(SharedArray,reshape(repeat(liion.artificial_soc_profil,ns), (nh+1,ny+1,ns)))[m
     else[m
    	 liion.soc = convert(SharedArray,zeros(nh+1, ny+1, ns)) ; liion.soc[1,1,:] .= liion.soc_ini[m
[36m@@ -130,11 +130,11 @@[m [mend[m
 ### Operation dynamic[m
 function compute_operation_dynamics!(h::Int64, y::Int64, s::Int64, liion::Liion_rainflow, decision::Float64, Î”h::Int64)[m
 [m
[31m-	if liion.soc_model == "tremblay_dessaint"[m
[32m+[m	[32mif liion.eff_model == "tremblay_dessaint"[m
 		liion.soc[h+1,y,s], liion.voltage[h+1,y,s], liion.carrier.power[h,y,s], liion.current[h,y,s] = compute_operation_soc_tremblay_dessaint(liion, (Erated = liion.Erated[y,s], soc = liion.soc[h,y,s], soh = liion.soh[h,y,s]),  liion.voltage[h,y,s], decision, Î”h)[m
[31m-	elseif  liion.soc_model == "linear"[m
[32m+[m	[32melseif  liion.eff_model == "linear"[m
 		liion.soc[h+1,y,s], liion.carrier.power[h,y,s] = compute_soc_dynamics(liion, (Erated = liion.Erated[y,s], soc = liion.soc[h,y,s], soh = liion.soh[h,y,s]), decision, Î”h)[m
[31m-	elseif liion.soc_model == "artificial"[m
[32m+[m	[32melseif liion.eff_model == "artificial"[m
 [m
 	end[m
 [m
[36m@@ -234,7 +234,7 @@[m [mfunction compute_operation_soh_rainflow(liion::Liion_rainflow, state::NamedTuple[m
 	fatigue = 0[m
 [m
 	for i in 1:length(DoD_seq)[m
[31m-		if DoD_seq[i] > 0.65 && liion.soc_model != "artificial"[m
[32m+[m		[32mif DoD_seq[i] > 0.65 && liion.eff_model != "artificial"[m
 			#println(peak_copy)[m
 		end[m
 		fatigue += 1/(2*Î¦(DoD_seq[i], liion.fatigue_data) ) #Compute fatigue with phy function applied to all the half cycles DoD factor 2 refer to half cycles[m
[36m@@ -302,7 +302,7 @@[m [mend[m
 [m
 function verification_liion_params(Î±_p_ch::Float64, Î±_p_dch::Float64, Î·_ch::Float64, Î·_dch::Float64, Î·_self::Float64,[m
 	Î±_soc_min::Float64, Î±_soc_max::Float64, lifetime::Int64, nCycle::Float64, bounds::NamedTuple{(:lb, :ub), Tuple{Float64, Float64}},[m
[31m-	SoH_threshold::Float64, couplage::NamedTuple{(:E,:R), Tuple{Bool,Bool}}, soc_model::String, calendar::Bool, Erated_ini::Float64, soc_ini::Float64,[m
[32m+[m	[32mSoH_threshold::Float64, couplage::NamedTuple{(:E,:R), Tuple{Bool,Bool}}, eff_model::String, calendar::Bool, Erated_ini::Float64, soc_ini::Float64,[m
 	soh_ini::Float64, update_by_year::Int64, artificial_soc_profil::Array{Float64,2})[m
 [m
 	validation = true[m
[36m@@ -318,8 +318,8 @@[m [mfunction verification_liion_params(Î±_p_ch::Float64, Î±_p_dch::Float64, Î·_ch::F[m
 		validation = false[m
 	end[m
 [m
[31m-	if !(soc_model in soc_model_names)[m
[31m-		error(soc_model ," is not an authorized Liion state of charge model. you need to pick one from the following list : ", soc_model_names)[m
[32m+[m	[32mif !(eff_model in eff_model_names)[m
[32m+[m		[32merror(eff_model ," is not an authorized Liion state of charge model. you need to pick one from the following list : ", eff_model_names)[m
 		validation = false[m
 	end[m
 [m
[1mdiff --git a/docs/src/assets/liion/liion_vermeer.jl b/docs/src/assets/liion/liion_vermeer.jl[m
[1mindex 489a6d5..2010d64 100644[m
[1m--- a/docs/src/assets/liion/liion_vermeer.jl[m
[1m+++ b/docs/src/assets/liion/liion_vermeer.jl[m
[36m@@ -27,7 +27,7 @@[m
 # plot!(quadfit,x[1],x[end],label="Quadratic Fit")[m
 [m
 [m
[31m-soc_model_names = ["tremblay_dessaint", "linear", "vermeer", "artificial"][m
[32m+[m[32meff_model_names = ["tremblay_dessaint", "linear", "vermeer", "artificial"][m
 [m
 mutable struct Vermeer_params[m
    c1::Float64[m
[36m@@ -68,7 +68,7 @@[m [mend[m
 	temperature::Float64[m
 [m
    	#Model dynamics[m
[31m-   	soc_model::String #model name[m
[32m+[m[41m   [m	[32meff_model::String #model name[m
 [m
    	# Initial conditions[m
    	Erated_ini::Float64  # capacitÃ© de la batterie en Wh[m
[36m@@ -105,14 +105,14 @@[m [mend[m
 		Npara = 1,[m
 		Nseries = 1,[m
 		temperature = 293,[m
[31m-   		soc_model = "linear",[m
[32m+[m[41m   [m		[32meff_model = "linear",[m
    		Erated_ini = 1e-6,[m
    		soc_ini = 0.5,[m
    		soh_ini = 1.,[m
    		update_by_year = 1) =  verification_liion_params(Î±_p_ch, Î±_p_dch, Î·_ch, Î·_dch, Î·_self, Î±_soc_min, Î±_soc_max, lifetime, nCycle, bounds,[m
[31m-   			SoH_threshold, couplage, Npara, Nseries, soc_model, Erated_ini, soc_ini, soh_ini) ?[m
[32m+[m[41m   [m			[32mSoH_threshold, couplage, Npara, Nseries, eff_model, Erated_ini, soc_ini, soh_ini) ?[m
    			new(Î±_p_ch, Î±_p_dch, Î·_ch, Î·_dch, Î·_self, Î±_soc_min, Î±_soc_max, lifetime, nCycle, bounds,[m
[31m-   			SoH_threshold, couplage, Npara, Nseries, temperature, soc_model, Erated_ini, soc_ini, soh_ini) : nothing[m
[32m+[m[41m   [m			[32mSoH_threshold, couplage, Npara, Nseries, temperature, eff_model, Erated_ini, soc_ini, soh_ini) : nothing[m
 [m
 end[m
 [m
[36m@@ -135,11 +135,11 @@[m [mend[m
  ### Operation dynamic[m
 function compute_operation_dynamics!(h::Int64, y::Int64, s::Int64, liion::Liion_vermeer, decision::Float64, Î”h::Int64)[m
 [m
[31m-	if liion.soc_model == "vermeer"[m
[32m+[m	[32mif liion.eff_model == "vermeer"[m
 		liion.soc[h+1,y,s], liion.carrier.power[h,y,s] = compute_operation_soc_Vermeer(liion, (Erated = liion.Erated[y,s], soc = liion.soc[h,y,s], soh = liion.soh[h,y,s]), decision, Î”h)[m
[31m-	elseif liion.soc_model == "tremblay_dessaint"[m
[32m+[m	[32melseif liion.eff_model == "tremblay_dessaint"[m
 		liion.soc[h+1,y,s], liion.voltage[h+1,y,s], liion.carrier.power[h,y,s], liion.current[h,y,s] = compute_operation_soc_tremblay_dessaint(liion, (Erated = liion.Erated[y,s], soc = liion.soc[h,y,s], soh = liion.soh[h,y,s]),  liion.voltage[h,y,s], decision, Î”h)[m
[31m-	elseif  liion.soc_model == "linear"[m
[32m+[m	[32melseif  liion.eff_model == "linear"[m
 		liion.soc[h+1,y,s], liion.carrier.power[h,y,s]  = compute_operation_soc_linear(liion, (Erated = liion.Erated[y,s], soc = liion.soc[h,y,s], soh = liion.soh[h,y,s]), decision, Î”h)[m
 	end[m
 [m
[36m@@ -238,7 +238,7 @@[m [mend[m
 [m
  function verification_liion_params(Î±_p_ch::Float64, Î±_p_dch::Float64, Î·_ch::Float64, Î·_dch::Float64, Î·_self::Float64,[m
  	Î±_soc_min::Float64, Î±_soc_max::Float64, lifetime::Int64, nCycle::Float64, bounds::NamedTuple{(:lb, :ub), Tuple{Float64, Float64}},[m
[31m- 	SoH_threshold::Float64, couplage::NamedTuple{(:E,:R), Tuple{Bool,Bool}}, Npara::Int64, Nseries::Int64, soc_model::String, Erated_ini::Float64, soc_ini::Float64,[m
[32m+[m[41m [m	[32mSoH_threshold::Float64, couplage::NamedTuple{(:E,:R), Tuple{Bool,Bool}}, Npara::Int64, Nseries::Int64, eff_model::String, Erated_ini::Float64, soc_ini::Float64,[m
  	soh_ini::Float64)[m
 [m
  	validation = true[m
[36m@@ -254,8 +254,8 @@[m [mend[m
  		validation = false[m
  	end[m
 [m
[31m- 	if !(soc_model in soc_model_names)[m
[31m- 		error(soc_model ," is not an authorized Liion state of charge model. you need to pick one from the following list : ", soc_model_names)[m
[32m+[m[41m [m	[32mif !(eff_model in eff_model_names)[m
[32m+[m[41m [m		[32merror(eff_model ," is not an authorized Liion state of charge model. you need to pick one from the following list : ", eff_model_names)[m
  		validation = false[m
  	end[m
 [m
[1mdiff --git a/docs/src/utils/plots.jl b/docs/src/utils/plots.jl[m
[1mindex 9a17b24..7c585a5 100644[m
[1m--- a/docs/src/utils/plots.jl[m
[1m+++ b/docs/src/utils/plots.jl[m
[36m@@ -89,7 +89,7 @@[m [mfunction plot_operation(mg::Microgrid ; y=2, s=1, smooth = false, xdisplay = "ho[m
     for s in 1:mg.parameters.ns[m
         figure("State-of-health")[m
 [m
[31m-        mg.storages[1].soc_model == "linear" ? soc = "lin" : (mg.storages[1].soc_model == "vermeer" ? soc = "ver" : soc = "t-d")[m
[32m+[m[32m        mg.storages[1].eff_model == "linear" ? soc = "lin" : (mg.storages[1].eff_model == "vermeer" ? soc = "ver" : soc = "t-d")[m
 [m
         if xdisplay == "years"[m
             y_values = vec(mg.storages[1].soh[:, y[1]:mg.parameters.ny, s])[1:24:((y[end] - y[1] +1) * (mg.parameters.nh+1) )][m
[36m@@ -146,7 +146,7 @@[m [mfunction plot_operation(mg::Microgrid ; y=2, s=1, smooth = false, xdisplay = "ho[m
 [m
 [m
     #voltage[m
[31m-    if mg.storages[1].soc_model == "tremblay_dessaint" [m
[32m+[m[32m    if mg.storages[1].eff_model == "tremblay_dessaint"[m[41m [m
         figure("voltage")[m
         Seaborn.plot(1:((mg.parameters.ny -1) * (mg.parameters.nh+1) ), vec(mg.storages[1].voltage[:, 2:mg.parameters.ny, s]), label = string("voltage : ", typeof(mg.storages[1])))[m
         legend()[m
[1mdiff --git a/nouvel_environnement/Project.toml b/nouvel_environnement/Project.toml[m
[1mnew file mode 100644[m
[1mindex 0000000..52736ee[m
[1m--- /dev/null[m
[1m+++ b/nouvel_environnement/Project.toml[m
[36m@@ -0,0 +1,6 @@[m
[32m+[m[32m[deps][m
[32m+[m[32mAbstractTrees = "1520ce14-60c1-5f80-bbc7-55ef81b5835c"[m
[32m+[m[32mBenchmarkTools = "6e4b80f9-dd63-53aa-95a3-0cdb28fa8baf"[m
[32m+[m[32mCombinatorics = "861a8166-3701-5b0c-9a16-15d98fcdc6aa"[m
[32m+[m[32mFlameGraphs = "08572546-2f56-4bcf-ba4e-bab62c3a3f89"[m
[32m+[m[32mInvertedIndices = "41ab1584-1d38-5bbf-9106-f11c6c58b48f"[m
[1mdiff --git a/src/Genesys2.jl b/src/Genesys2.jl[m
[1mindex be419f1..5cc123b 100644[m
[1m--- a/src/Genesys2.jl[m
[1m+++ b/src/Genesys2.jl[m
[36m@@ -29,7 +29,7 @@[m [mabstract type EnergyCarrier end[m
 #Metaheuristic module part[m
 using Distributions, Random, LinearAlgebra, Statistics[m
 using Distributed[m
[31m-using GlobalSensitivity, Test, ProgressMeter[m
[32m+[m[32musing Test, ProgressMeter #GlobalSensitivity[m
 [m
 # Clearing[m
 include(joinpath("optimization","designer", "metaheuristic","clearing","struct.jl"))[m
[36m@@ -46,7 +46,7 @@[m [minclude(joinpath("optimization","designer", "metaheuristic","NSGAII","utils.jl")[m
 [m
 [m
 # Optimisation[m
[31m-using JuMP, Cbc, Metaheuristics, SDDP, Ipopt#, Gurobi[m
[32m+[m[32musing JuMP, Cbc, Metaheuristics, SDDP, Ipopt, Gurobi[m
 # Math[m
 using Statistics, StatsBase, MultivariateStats, Clustering, Distributions, Distances, LinearAlgebra, Interpolations[m
 # Others[m
[1mdiff --git a/src/assets/electrolyzer/electrolyzer.jl b/src/assets/electrolyzer/electrolyzer.jl[m
[1mindex db2f478..73e09cd 100644[m
[1m--- a/src/assets/electrolyzer/electrolyzer.jl[m
[1m+++ b/src/assets/electrolyzer/electrolyzer.jl[m
[36m@@ -32,6 +32,10 @@[m [mend[m
 [m
 mutable struct PolarizationElectrolyzerEfficiency <: AbstractElectrolyzerEffModel[m
   Î±_p::Float64 #Minimum power defined as a share of the maximum Power[m
[32m+[m
[32m+[m[32m  Î·_E_H2::Float64 #The efficiency from Electricity to DiHydrogen[m[41m [m
[32m+[m[32m  Î·_E_H::Float64 #The efficiency from Electricity to Heat[m
[32m+[m
   k_aux::Float64 # Share of the power used by the auxiliaries[m
   couplage::Bool[m
   K::Float64 # Defined as a constant Latent Heat Value * masse molaire * stoechiometric coefficient / 2Faraday constant  [m
[36m@@ -44,11 +48,13 @@[m [mmutable struct PolarizationElectrolyzerEfficiency <: AbstractElectrolyzerEffMode[m
 [m
 [m
   PolarizationElectrolyzerEfficiency(; Î±_p = 0.05,[m
[32m+[m[32m  Î·_E_H2 = 0.7,[m
[32m+[m[32m  Î·_E_H = 0.,[m
    k_aux = 0.15,[m
   couplage = true,[m
   K = (33.33 *  2.016 * 3600)  / (2*96485.3321),  #LHV * M_H2 * Î» * 3600/(2*F)[m
   powerMax_ini = .00001,[m
[31m-  ) = new(Î±_p, k_aux, couplage, K, powerMax_ini)[m
[32m+[m[32m  ) = new(Î±_p, Î·_E_H2, Î·_E_H, k_aux, couplage, K, powerMax_ini)[m
 end[m
 [m
 [m
[36m@@ -59,6 +65,9 @@[m [mmutable struct LinearElectrolyzerEfficiency <: AbstractElectrolyzerEffModel[m
   K::Float64 # Defined as a constant Latent Heat Value * masse molaire * stoechiometric coefficient / 2Faraday constant  [m
   powerMax_ini::Float64[m
 [m
[32m+[m[32m  Î·_E_H2::Float64 #The efficiency from Electricity to DiHydrogen[m[41m [m
[32m+[m[32m  Î·_E_H::Float64 #The efficiency from Electricity to Heat[m
[32m+[m
   powerMax::AbstractArray{Float64,3} #The maximum power that can be demanded to the Electrolyzer[m
 [m
   a_Î·::Vector{Float64} # the slope for the fucntion Î·(P)[m
[36m@@ -68,11 +77,13 @@[m [mmutable struct LinearElectrolyzerEfficiency <: AbstractElectrolyzerEffModel[m
 [m
 [m
   LinearElectrolyzerEfficiency(; Î±_p = 0.05,[m
[31m-   k_aux = 0.15,[m
[31m-  couplage = true,[m
[31m-  K = (33.33 *  2.016 * 3600)  / (2*96485.3321),  #PCI * M_H2 * 3600/(2*F)[m
[31m-  powerMax_ini = .00001,[m
[31m-  ) = new(Î±_p, k_aux, couplage, K, powerMax_ini)[m
[32m+[m[32m    k_aux = 0.15,[m
[32m+[m[32m    couplage = true,[m
[32m+[m[32m    K = (33.33 *  2.016 * 3600)  / (2*96485.3321),  #PCI * M_H2 * 3600/(2*F)[m
[32m+[m[32m    powerMax_ini = .00001,[m
[32m+[m[32m    Î·_E_H2 = 0.7,[m
[32m+[m[32m    Î·_E_H = 0.[m
[32m+[m[32m  ) = new(Î±_p, k_aux, couplage, K, powerMax_ini, Î·_E_H2, Î·_E_H)[m
 end[m
 [m
 [m
[36m@@ -80,7 +91,7 @@[m [mend[m
 #M/A en option[m
 mutable struct FunctHoursAgingElectrolyzer <: AbstractElectrolyzerAgingModel[m
   plot::Bool [m
[31m-  StartStop::Bool[m
[32m+[m[32m  start_stop::Bool[m
   deg_per_hour::Float64 [m
   update_by_year::Int # The frequency (per year) of SoH and V(I) update[m
   J_ref::Float64 # The nominal current density[m
[36m@@ -92,13 +103,16 @@[m [mmutable struct FunctHoursAgingElectrolyzer <: AbstractElectrolyzerAgingModel[m
   coef_a::Float64 #The slope of voltage degradation for each functioning hour[m
   coef_b::Float64 #The ordinate at origin of voltage degradation for each functioning hour[m
 [m
[32m+[m[32m  lifetime::Float64 # Fixed lifetime for MILP applications[m
[32m+[m
[32m+[m
   FunctHoursAgingElectrolyzer(;plot = false,[m
[31m-    StartStop = true,[m
[32m+[m[32m    start_stop = true,[m
     deg_per_hour = 1e-5,[m
     update_by_year = 12,[m
     J_ref = 0.62,[m
     J_base = 0.1[m
[31m-  ) = new(plot, StartStop, deg_per_hour, update_by_year, J_ref, J_base)[m
[32m+[m[32m  ) = new(plot, start_stop, deg_per_hour, update_by_year, J_ref, J_base)[m
 end[m
 [m
 [m
[36m@@ -109,26 +123,31 @@[m [mmutable struct FixedLifetimeElectrolyzer <: AbstractElectrolyzerAgingModel[m
   update_by_year::Int # The frequency (per year) of SoH and V(I) update[m
   J_ref::Float64 # The nominal current density[m
   nHourMax::Int64[m
[32m+[m[32m  lifetime::Int64[m
[32m+[m
[32m+[m[41m  [m
 [m
   V_J_ini::AbstractArray{Float64,2}[m
   V_J::AbstractArray{Float64,3}[m
 [m
   V_nom_ini::Float64[m
 [m
[31m-  FixedLifetimeElectrolyzer(;plot = false,[m
[32m+[m[41m [m
[32m+[m[32m  function FixedLifetimeElectrolyzer(;plot = false,[m
     update_by_year = 12,[m
     J_ref = 0.62,[m
     nHourMax = 20*8760[m
[31m-  ) = new(plot, update_by_year, J_ref, nHourMax)[m
[32m+[m[32m  )[m[41m [m
[32m+[m[32m    lifetime = div(nHourMax, 8760) # Calculate lifetime based on nHourMax[m
[32m+[m[32m    new(plot, update_by_year, J_ref, nHourMax, lifetime)[m
[32m+[m[32m  end[m
 end[m
 [m
 [m
 [m
[31m-[m
[31m-[m
 mutable struct Electrolyzer <: AbstractElectrolyzer[m
 [m
[31m-  EffModel::AbstractElectrolyzerEffModel[m
[32m+[m[32m  eff_model::AbstractElectrolyzerEffModel[m
 	SoH_model::AbstractElectrolyzerAgingModel[m
   couplage::Bool  #a boolean tuple to tell wether or not the soh should influence the other parameters.[m
 [m
[36m@@ -154,15 +173,15 @@[m [mmutable struct Electrolyzer <: AbstractElectrolyzer[m
   # Eco[m
   cost::AbstractArray{Float64,2}[m
 [m
[31m-	Electrolyzer(;EffModel = PolarizationElectrolyzerEfficiency(),[m
[32m+[m	[32mElectrolyzer(;eff_model = PolarizationElectrolyzerEfficiency(),[m
     SoH_model = FunctHoursAgingElectrolyzer(),[m
     couplage = true,[m
     bounds = (lb = 0., ub = 50.),[m
     SoH_threshold = 0.8,[m
[31m-    V_J_ini = nothing,[m
[32m+[m[32m    V_J_ini = Matrix(transpose(Matrix(DataFrames.DataFrame(CSV.File(joinpath("Examples","data","V_J_Elyz.csv"), delim = ",", header = [Symbol("J"),Symbol("V")], types=Dict(:J=>Float64, :V=>Float64)))))),[m
     min_part_load = 0.05,[m
     soh_ini = 1. [m
[31m-  ) = new(EffModel, SoH_model, couplage, bounds, SoH_threshold, V_J_ini, min_part_load, soh_ini)[m
[32m+[m[32m  ) = new(eff_model, SoH_model, couplage, bounds, SoH_threshold, V_J_ini, min_part_load, soh_ini)[m
 [m
 end[m
 [m
[36m@@ -173,7 +192,7 @@[m [mend[m
 [m
 ### Preallocation[m
 function preallocate!(elyz::Electrolyzer, nh::Int64, ny::Int64, ns::Int64)[m
[31m-  elyz.EffModel.powerMax = convert(SharedArray,zeros(nh+1, ny+1, ns)) ;  elyz.EffModel.powerMax[1,1,:] .= elyz.EffModel.powerMax_ini[m
[32m+[m[32m  elyz.eff_model.powerMax = convert(SharedArray,zeros(nh+1, ny+1, ns)) ;  elyz.eff_model.powerMax[1,1,:] .= elyz.eff_model.powerMax_ini[m
   elyz.Î· = convert(SharedArray,zeros(nh+1, ny+1, ns))[m
 [m
   elyz.carrier = [Electricity(), Heat(), Hydrogen()][m
[36m@@ -185,11 +204,16 @@[m [mfunction preallocate!(elyz::Electrolyzer, nh::Int64, ny::Int64, ns::Int64)[m
 [m
   elyz.SoH_model.V_J_ini = convert(SharedArray, zeros(3, length(elyz.V_J_ini[1,:]))) #J, V, P[m
   elyz.SoH_model.V_J = convert(SharedArray, zeros(3, length(elyz.V_J_ini[1,:]), ns)) #J, V, P[m
[31m-  elyz.EffModel.V_J = convert(SharedArray, zeros(3, length(elyz.V_J_ini[1,:]), ns)) #J, V, P[m
[32m+[m[32m  elyz.eff_model.V_J = convert(SharedArray, zeros(3, length(elyz.V_J_ini[1,:]), ns)) #J, V, P[m
[32m+[m
[32m+[m[32m  if elyz.eff_model isa LinearElectrolyzerEfficiency[m
[32m+[m[32m    elyz.eff_model.a_Î· =  convert(SharedArray, zeros(ns))[m
[32m+[m[32m    elyz.eff_model.b_Î· = convert(SharedArray, zeros(ns))[m
[32m+[m[32m  end[m
 [m
[31m-  if elyz.EffModel isa LinearElectrolyzerEfficiency[m
[31m-    elyz.EffModel.a_Î· =  convert(SharedArray, zeros(ns))[m
[31m-    elyz.EffModel.b_Î· = convert(SharedArray, zeros(ns))[m
[32m+[m[32m  if elyz.SoH_model isa FunctHoursAgingElectrolyzer[m
[32m+[m[32m    V_ini = interpolation(elyz.V_J_ini[1,:], elyz.V_J_ini[2,:], elyz.SoH_model.J_ref , true)[m
[32m+[m[32m    elyz.SoH_model.lifetime = (V_ini*0.2) / elyz.SoH_model.deg_per_hour / 8760 / 0.25 # 20% V augmentation with a result in years under the hypothesis of 6h usage a day[m
   end[m
 [m
   return elyz[m
[36m@@ -199,9 +223,9 @@[m [mend[m
 ### Operation dynamic[m
 function compute_operation_dynamics!(h::Int64, y::Int64, s::Int64, elyz::Electrolyzer, decision::Float64, Î”h::Int64)[m
 [m
[31m-  elyz.carrier[1].power[h,y,s], elyz.carrier[2].power[h,y,s], elyz.carrier[3].power[h,y,s] = compute_operation_efficiency(elyz, elyz.EffModel, h ,y ,s , decision)[m
[32m+[m[32m  elyz.carrier[1].power[h,y,s], elyz.carrier[2].power[h,y,s], elyz.carrier[3].power[h,y,s] = compute_operation_efficiency(elyz, elyz.eff_model, h ,y ,s , decision)[m
 [m
[31m-  elyz.soh[h+1,y,s], elyz.EffModel.powerMax[h+1,y,s] = compute_operation_soh(elyz, elyz.SoH_model, h ,y ,s, Î”h)[m
[32m+[m[32m  elyz.soh[h+1,y,s], elyz.eff_model.powerMax[h+1,y,s] = compute_operation_soh(elyz, elyz.SoH_model, h ,y ,s, Î”h)[m
 [m
 end[m
 [m
[36m@@ -209,7 +233,7 @@[m [mend[m
 ### Operation dynamic[m
 function compute_operation_dynamics(elyz::Electrolyzer, h::Int64, y::Int64, s::Int64, decision::Float64, Î”h::Int64)[m
 [m
[31m-  return compute_operation_efficiency(elyz, elyz.EffModel, h ,y ,s , decision)[m
[32m+[m[32m  return compute_operation_efficiency(elyz, elyz.eff_model, h ,y ,s , decision)[m
 [m
 end[m
 [m
[36m@@ -317,20 +341,20 @@[m [mfunction compute_operation_soh(elyz::Electrolyzer, model::FunctHoursAgingElectro[m
 [m
     nextSoH = V_nom/V_nom_ini  [m
 [m
[31m-      if elyz.EffModel.couplage[m
[31m-        nextPowerMax = maximum(model.V_J[3,:,s]) * (1-elyz.EffModel.k_aux)[m
[31m-        elyz.EffModel.V_J[:,:,s] = model.V_J[:,:,s][m
[32m+[m[32m      if elyz.eff_model.couplage[m
[32m+[m[32m        nextPowerMax = maximum(model.V_J[3,:,s]) * (1-elyz.eff_model.k_aux)[m
[32m+[m[32m        elyz.eff_model.V_J[:,:,s] = model.V_J[:,:,s][m
 [m
[31m-          if elyz.EffModel isa LinearFuelCellEfficiency [m
[31m-            update_Î·_lin(elyz, elyz.EffModel, s)[m
[32m+[m[32m          if elyz.eff_model isa LinearFuelCellEfficiency[m[41m [m
[32m+[m[32m            update_Î·_lin(elyz, elyz.eff_model, s)[m
           end[m
 [m
       else[m
[31m-        nextPowerMax = elyz.EffModel.powerMax[h,y,s] [m
[32m+[m[32m        nextPowerMax = elyz.eff_model.powerMax[h,y,s][m[41m [m
       end[m
   else [m
     nextSoH = elyz.soh[h,y,s] [m
[31m-    nextPowerMax = elyz.EffModel.powerMax[h,y,s] [m
[32m+[m[32m    nextPowerMax = elyz.eff_model.powerMax[h,y,s][m[41m [m
   end[m
 [m
   return nextSoH, nextPowerMax[m
[36m@@ -362,21 +386,21 @@[m [mfunction compute_operation_soh(elyz::Electrolyzer, model::FixedLifetimeElectroly[m
     end[m
 [m
 [m
[31m-      if elyz.EffModel.couplage[m
[31m-        nextPowerMax = maximum(model.V_J[3,:,s]) * (1-elyz.EffModel.k_aux)[m
[32m+[m[32m      if elyz.eff_model.couplage[m
[32m+[m[32m        nextPowerMax = maximum(model.V_J[3,:,s]) * (1-elyz.eff_model.k_aux)[m
         nextPowerMin = compute_min_power(elyz, s)[m
[31m-        elyz.EffModel.V_J = model.V_J[m
[32m+[m[32m        elyz.eff_model.V_J = model.V_J[m
 [m
[31m-          if elyz.EffModel isa LinearElectrolyzerEfficiency [m
[31m-            update_Î·_lin(elyz, elyz.EffModel, s)[m
[32m+[m[32m          if elyz.eff_model isa LinearElectrolyzerEfficiency[m[41m [m
[32m+[m[32m            update_Î·_lin(elyz, elyz.eff_model, s)[m
           end[m
 [m
       else[m
[31m-        nextPowerMax = elyz.EffModel.powerMax[h,y,s] [m
[32m+[m[32m        nextPowerMax = elyz.eff_model.powerMax[h,y,s][m[41m [m
       end[m
   else [m
     nextSoH = elyz.soh[h,y,s] [m
[31m-    nextPowerMax = elyz.EffModel.powerMax[h,y,s] [m
[32m+[m[32m    nextPowerMax = elyz.eff_model.powerMax[h,y,s][m[41m [m
   end[m
 [m
   return nextSoH, nextPowerMax[m
[36m@@ -389,13 +413,13 @@[m [mfunction initialize_investments!(s::Int64, elyz::Electrolyzer, decision::NamedTu[m
   elyz.soh[1,1,s] = elyz.soh_ini[m
 [m
 [m
[31m-  elyz.EffModel.V_J[1,:,:] .= elyz.V_J_ini[1,:] [m
[31m-  elyz.EffModel.V_J[2,:,:] .= elyz.V_J_ini[2,:][m
[31m-  elyz.EffModel.V_J[3,:,:] .= elyz.V_J_ini[2,:] .* elyz.V_J_ini[1,:] * elyz.surface * elyz.N_cell[m
[31m-  elyz.EffModel.powerMax[1,1,:] .= maximum(elyz.EffModel.V_J[3,:,:]) * (1-elyz.EffModel.k_aux)[m
[32m+[m[32m  elyz.eff_model.V_J[1,:,:] .= elyz.V_J_ini[1,:][m[41m [m
[32m+[m[32m  elyz.eff_model.V_J[2,:,:] .= elyz.V_J_ini[2,:][m
[32m+[m[32m  elyz.eff_model.V_J[3,:,:] .= elyz.V_J_ini[2,:] .* elyz.V_J_ini[1,:] * elyz.surface * elyz.N_cell[m
[32m+[m[32m  elyz.eff_model.powerMax[1,1,:] .= maximum(elyz.eff_model.V_J[3,:,:]) * (1-elyz.eff_model.k_aux)[m
 [m
[31m-  if elyz.EffModel isa LinearElectrolyzerEfficiency [m
[31m-    update_Î·_lin(elyz, elyz.EffModel, s)[m
[32m+[m[32m  if elyz.eff_model isa LinearElectrolyzerEfficiency[m[41m [m
[32m+[m[32m    update_Î·_lin(elyz, elyz.eff_model, s)[m
   end[m
 [m
   #Initialization of V(J)[m
[36m@@ -405,18 +429,17 @@[m [mfunction initialize_investments!(s::Int64, elyz::Electrolyzer, decision::NamedTu[m
     elyz.SoH_model.V_J .= copy(elyz.SoH_model.V_J_ini)[m
 [m
   if elyz.SoH_model isa FixedLifetimeElectrolyzer[m
[31m-[m
     elyz.SoH_model.V_nom_ini = interpolation(elyz.V_J_ini[1,:], elyz.V_J_ini[2,:], elyz.SoH_model.J_ref , true)[m
 [m
   end[m
 [m
[31m-[m
[32m+[m[41m  [m
   [m
 end[m
 [m
 ### Investment dynamic[m
 function compute_investment_dynamics!(y::Int64, s::Int64, elyz::Electrolyzer,  decision::NamedTuple{(:surface, :N_cell), Tuple{Float64, Int64}})    [m
[31m-  elyz.EffModel.powerMax[1,y+1,s], elyz.soh[1,y+1,s] = compute_investment_dynamics(elyz, (powerMax = elyz.EffModel.powerMax[end,y,s], soh = elyz.soh[end,y,s]), decision, s)[m
[32m+[m[32m  elyz.eff_model.powerMax[1,y+1,s], elyz.soh[1,y+1,s] = compute_investment_dynamics(elyz, (powerMax = elyz.eff_model.powerMax[end,y,s], soh = elyz.soh[end,y,s]), decision, s)[m
 end[m
 [m
 [m
[36m@@ -438,12 +461,12 @@[m [mfunction compute_investment_dynamics(elyz::Electrolyzer, state::NamedTuple{(:pow[m
       soh_next = elyz.soh_ini[m
 [m
       elyz.SoH_model.V_J[:,:,s] = V_J[m
[31m-      elyz.EffModel.V_J[:,:,s] = V_J[m
[32m+[m[32m      elyz.eff_model.V_J[:,:,s] = V_J[m
 [m
[31m-      powerMax_next = maximum(V_J[3,:]) * (1-elyz.EffModel.k_aux)[m
[32m+[m[32m      powerMax_next = maximum(V_J[3,:]) * (1-elyz.eff_model.k_aux)[m
 [m
[31m-      if elyz.EffModel isa LinearFuelCellEfficiency [m
[31m-        update_Î·_lin(elyz, elyz.EffModel, s)[m
[32m+[m[32m      if elyz.eff_model isa LinearFuelCellEfficiency[m[41m [m
[32m+[m[32m        update_Î·_lin(elyz, elyz.eff_model, s)[m
       end[m
 [m
   else[m
[36m@@ -460,9 +483,9 @@[m [mend[m
 #compute the power that correpond to the maximum allowed tension[m
 function compute_min_power(elyz::AbstractElectrolyzer, s::Int64)[m
   [m
[31m-    P_min = elyz.EffModel.Î±_p * maximum(elyz.EffModel.V_J[3,:,s])[m
[32m+[m[32m    P_min = elyz.eff_model.Î±_p * maximum(elyz.eff_model.V_J[3,:,s])[m
   [m
[31m-    P_min_tot = P_min * (1 + elyz.EffModel.k_aux)[m
[32m+[m[32m    P_min_tot = P_min * (1 + elyz.eff_model.k_aux)[m
   [m
   return P_min_tot[m
 end[m
[36m@@ -473,13 +496,13 @@[m [mfunction get_Î·_E(P_brut::Float64, elyz::AbstractElectrolyzer, s::Int64)[m
   if P_brut == 0.[m
     return 0.[m
   end[m
[31m-  P_net = ceil(P_brut / (1 + elyz.EffModel.k_aux); digits=6)[m
[32m+[m[32m  P_net = ceil(P_brut / (1 + elyz.eff_model.k_aux); digits=6)[m
   [m
   #Find the corresponding current from an interpolation from P(I) curve [m
[31m-  j = interpolation(elyz.EffModel.V_J[3,:,s], elyz.EffModel.V_J[1,:,s], P_net, true)[m
[32m+[m[32m  j = interpolation(elyz.eff_model.V_J[3,:,s], elyz.eff_model.V_J[1,:,s], P_net, true)[m
   i = j * elyz.surface * elyz.N_cell[m
 [m
[31m-  return elyz.EffModel.K * i / (P_brut)[m
[32m+[m[32m  return elyz.eff_model.K * i / (P_brut)[m
 [m
 end[m
 [m
[36m@@ -495,8 +518,8 @@[m [mfunction update_Î·_lin(elyz::Electrolyzer, model::LinearElectrolyzerEfficiency,[m
   b_Î· = Î·_P_min - a_Î· * P_min[m
 [m
 [m
[31m-  elyz.EffModel.a_Î·[s] = a_Î·[m
[31m-  elyz.EffModel.b_Î·[s] = b_Î·[m
[32m+[m[32m  elyz.eff_model.a_Î·[s] = a_Î·[m
[32m+[m[32m  elyz.eff_model.b_Î·[s] = b_Î·[m
 [m
 end[m
 [m
[36m@@ -504,11 +527,11 @@[m [mend[m
 [m
 function toStringShort(elyz::Electrolyzer)[m
 [m
[31m-	if elyz.EffModel isa LinearElectrolyzerEfficiency[m
[32m+[m	[32mif elyz.eff_model isa LinearElectrolyzerEfficiency[m
 		efficiency = "x"[m
[31m-	elseif elyz.EffModel isa PolarizationElectrolyzerEfficiency[m
[32m+[m	[32melseif elyz.eff_model isa PolarizationElectrolyzerEfficiency[m
 		efficiency = "V(J)"[m
[31m-  elseif elyz.EffModel isa FixedElectrolyzerEfficiency[m
[32m+[m[32m  elseif elyz.eff_model isa FixedElectrolyzerEfficiency[m
 		efficiency = "fix."[m
 	end[m
 [m
[1mdiff --git a/src/assets/fuelcell/fuelcell.jl b/src/assets/fuelcell/fuelcell.jl[m
[1mindex cac56bf..74952b0 100644[m
[1m--- a/src/assets/fuelcell/fuelcell.jl[m
[1m+++ b/src/assets/fuelcell/fuelcell.jl[m
[36m@@ -79,6 +79,9 @@[m [mmutable struct PolarizationFuelCellEfficiency <: AbstractFuelCellEffModel[m
   powerMax_ini::Float64[m
   V_max::Float64[m
 [m
[32m+[m[32m  Î·_H2_E::Float64 #The efficiency from DiHydrogen to Electricity[m
[32m+[m[32m  Î·_H2_H::Float64 #The efficiency from DiHydrogen to Heat[m
[32m+[m
   powerMax::AbstractArray{Float64,3} #The maximum power that can be demanded to the FuelCell[m
   powerMin::AbstractArray{Float64,3} #The minimum power that can be demanded to the FuelCell[m
 [m
[36m@@ -89,8 +92,10 @@[m [mmutable struct PolarizationFuelCellEfficiency <: AbstractFuelCellEffModel[m
   PolarizationFuelCellEfficiency(; k_aux = 0.15,[m
   K = (33.33 *  2.016 * 1.2 * 3600)  / (2*96485.3321),  #PCI * M_H2 * Î» * 3600/(2*F)[m
   powerMax_ini = .00001,[m
[31m-  V_max = 0.8[m
[31m-  ) = new(k_aux, K, powerMax_ini, V_max)[m
[32m+[m[32m  V_max = 0.8,[m
[32m+[m[32m  Î·_H2_E = 0.4,[m
[32m+[m[32m  Î·_H2_H = 0.4[m
[32m+[m[32m  ) = new(k_aux, K, powerMax_ini, V_max, Î·_H2_E, Î·_H2_H)[m
 end[m
 [m
 """[m
[36m@@ -122,6 +127,10 @@[m [mmutable struct LinearFuelCellEfficiency <: AbstractFuelCellEffModel[m
   powerMax_ini::Float64[m
   V_max::Float64[m
 [m
[32m+[m[32m  Î·_H2_E::Float64 #The efficiency from DiHydrogen to Electricity[m
[32m+[m[32m  Î·_H2_H::Float64 #The efficiency from DiHydrogen to Heat[m
[32m+[m
[32m+[m
   powerMax::AbstractArray{Float64,3} #The maximum power that can be demanded to the FuelCell[m
   powerMin::AbstractArray{Float64,3} #The minimum power that can be demanded to the FuelCell[m
 [m
[36m@@ -134,8 +143,10 @@[m [mmutable struct LinearFuelCellEfficiency <: AbstractFuelCellEffModel[m
   LinearFuelCellEfficiency(; k_aux = 0.15,[m
   K = (33.33 *  2.016 * 1.2 * 3600)  / (2*96485.3321),  #PCI * M_H2 * Î» * 3600/(2*F)[m
   powerMax_ini = .00001,[m
[31m-  V_max = 0.8[m
[31m-  ) = new(k_aux, K, powerMax_ini, V_max)[m
[32m+[m[32m  V_max = 0.8,[m
[32m+[m[32m  Î·_H2_E = 0.4,[m
[32m+[m[32m  Î·_H2_H = 0.4[m
[32m+[m[32m  ) = new(k_aux, K, powerMax_ini, V_max, Î·_H2_E, Î·_H2_H)[m
 end[m
 [m
 [m
[36m@@ -170,31 +181,112 @@[m [mend[m
 [m
 [m
 [m
[31m-#M/A en option[m
[32m+[m[32m"""[m
[32m+[m[32m`PowerAgingFuelCell` models the aging of a fuel cell based on its polarization curve and operational conditions.[m
[32m+[m
[32m+[m[32m# Fields[m
[32m+[m[32m- `plot::Bool`: Indicates if degradation plots should be generated.[m
[32m+[m[32m- `start_stop::Bool`: Enables or disables degradation due to start/stop cycles.[m
[32m+[m[32m- `update_by_year::Int`: Frequency of State of Health (SoH) and polarization curve updates per year.[m
[32m+[m[32m- `J_ref::Float64`: Nominal current density of the fuel cell.[m
[32m+[m[32m- `deg_params::deg_params`: Parameters defining the degradation behavior.[m
[32m+[m[32m- `V_J_ini::AbstractArray{Float64,2}`: Initial voltage-current relationship at the start of the fuel cell's life.[m
[32m+[m[32m- `V_J::AbstractArray{Float64,3}`: Time-evolving voltage-current relationship during the fuel cell's life. (with Power as additional dimension)[m
[32m+[m
[32m+[m[32m# Example[m
[32m+[m[32m```julia[m
[32m+[m[32mfuel_cell = PowerAgingFuelCell(V_J_ini=initial_data_matrix, objective_hours=15000.0)[m
[32m+[m[32m```[m
[32m+[m[32m"""[m
 mutable struct PowerAgingFuelCell <: AbstractFuelCellAgingModel[m
   plot::Bool [m
[31m-  StartStop::Bool[m
[31m-  deg_params::deg_params [m
[32m+[m[32m  start_stop::Bool[m
   update_by_year::Int # The frequency (per year) of SoH and V(I) update[m
   J_ref::Float64 # The nominal current[m
 [m
[32m+[m[32m  deg_params::deg_params[m[41m [m
   V_J_ini::AbstractArray{Float64,2}[m
[32m+[m
   V_J::AbstractArray{Float64,3}[m
 [m
[31m-  PowerAgingFuelCell(;plot = false,[m
[31m-    StartStop = true,[m
[31m-    deg_params = nothing,[m
[32m+[m[32m  function PowerAgingFuelCell(;plot = false,[m
[32m+[m[32m    start_stop = true,[m
     update_by_year = 12,[m
[32m+[m[32m    J_ref = 0.62,[m[41m [m
[32m+[m[32m    V_J_ini = Matrix(transpose(Matrix(DataFrames.DataFrame(CSV.File(joinpath("Examples","data","V_J_PAC.csv"), delim = ",", header = [Symbol("J"),Symbol("V")], types=Dict(:J=>Float64, :V=>Float64)))))),[m
[32m+[m[32m    degParams = nothing,[m
[32m+[m[32m    objective_hours = 15000. #The FuelCell for which we have data is pretty bad so we consider a fuel cell with 15000 hours lifetime at the reference current density.[m
[32m+[m[32m  )[m[41m [m
[32m+[m
[32m+[m[32m    @assert(objective_hours > 0, "objective_hours should be greater than 0")[m
[32m+[m[32m    @assert(update_by_year > 0, "update_by_year should be greater than 0")[m
[32m+[m[32m    @assert(J_ref >= 0, "J_ref should be greater than 0")[m
[32m+[m
[32m+[m[41m    [m
[32m+[m[32m    #Degradation curves Î¼V/h as a function of the current density for different current densities[m
[32m+[m[32m    # See (https://oatao.univ-toulouse.fr/29665/1/Pessot_Alexandra.pdf) fig III.43[m
[32m+[m[32m    P_min = DataFrames.DataFrame(CSV.File(joinpath("Examples","data","P_min.csv"), delim = ",", header = [Symbol("J"),Symbol("V")], types=Dict(:J=>Float64, :V=>Float64)))[m
[32m+[m[32m    P_int = DataFrames.DataFrame(CSV.File(joinpath("Examples","data","P_int.csv"), delim = ",", header = [Symbol("J"),Symbol("V")], types=Dict(:J=>Float64, :V=>Float64)))[m
[32m+[m[32m    P_max = DataFrames.DataFrame(CSV.File(joinpath("Examples","data","P_max.csv"), delim = ",", header = [Symbol("J"),Symbol("V")], types=Dict(:J=>Float64, :V=>Float64)))[m
[32m+[m
[32m+[m[32m    datas_deg_FC = [P_min,P_int,P_max][m
[32m+[m
[32m+[m[32m    # Coresponding current densities (resp. P_min, P_int, P_max)[m
[32m+[m[32m    current_densities = [0.075, 0.42, 0.62][m
[32m+[m
[32m+[m[32m    #The voltage as a function of the current density at the beginning of life[m
[32m+[m[32m    V_J_FC = Matrix(transpose(Matrix(V_J_ini)))[m
[32m+[m[41m   [m
[32m+[m[32m    # RÃ©fÃ©rence current density for this Fuel cell     # See (https://oatao.univ-toulouse.fr/29665/1/Pessot_Alexandra.pdf)[m[41m [m
     J_ref = 0.62[m
[31m-  ) = new(plot, StartStop, deg_params, update_by_year, J_ref)[m
[32m+[m
[32m+[m[32m    degParams = create_deg_params(datas_deg_FC, current_densities, V_J_FC, J_ref, objective_hours)[m
[32m+[m
[32m+[m[32m    return new(plot, start_stop, update_by_year, J_ref, degParams, V_J_FC)[m
[32m+[m[32m  end[m
 end[m
 [m
 [m
 [m
[31m-#M/A en option[m
[32m+[m[32m"""[m
[32m+[m[32m`FunctHoursAgingFuelCell` models the aging of a fuel cell as a function of its operating hours and current density.[m
[32m+[m
[32m+[m[32m# Fields[m
[32m+[m[32m- `plot::Bool`: Indicates if degradation plots should be generated.[m
[32m+[m[32m- `start_stop::Bool`: Enables or disables degradation due to start/stop cycles.[m
[32m+[m[32m- `deg_params::deg_params`: Parameters defining the degradation behavior based on the polarization curve.[m
[32m+[m[32m- `update_by_year::Int`: Frequency of State of Health (SoH) and polarization curve updates per year.[m
[32m+[m[32m- `J_ref::Float64`: Nominal current density of the fuel cell.[m
[32m+[m[32m- `J_base::Float64`: Current density used as a baseline for degradation calculations.[m
[32m+[m[32m- `V_J_ini::AbstractArray{Float64,2}`: Initial voltage-current relationship at the start of the fuel cell's life.[m
[32m+[m[32m- `V_J::AbstractArray{Float64,3}`: Time-evolving voltage-current relationship during the fuel cell's life.[m
[32m+[m[32m- `coef_a::Float64`: Slope of voltage degradation for each operating hour.[m
[32m+[m[32m- `coef_b::Float64`: Ordinate at origin of voltage degradation for each operating hour.[m
[32m+[m
[32m+[m[32m# Constructor Parameters[m
[32m+[m[32m- `plot::Bool=false`: Whether to generate plots for degradation.[m
[32m+[m[32m- `start_stop::Bool=true`: Whether to include degradation caused by start/stop cycles.[m
[32m+[m[32m- `deg_params::deg_params=nothing`: Degradation parameters object (optional).[m
[32m+[m[32m- `update_by_year::Int=12`: Number of updates per year for the SoH and V(I) curves.[m
[32m+[m[32m- `J_ref::Float64=0.62`: Nominal current density.[m
[32m+[m[32m- `J_base::Float64=0.1`: Baseline current density for degradation calculations.[m
[32m+[m[32m- `objective_hours::Float64=15000.0`: Target lifetime in hours at the nominal current density.[m
[32m+[m
[32m+[m[32m# Example[m
[32m+[m[32m```julia[m
[32m+[m[32mfuel_cell = FunctHoursAgingFuelCell([m
[32m+[m[32m    plot=true,[m
[32m+[m[32m    start_stop=false,[m
[32m+[m[32m    J_base=0.1,[m
[32m+[m[32m    objective_hours=20000.0[m
[32m+[m[32m)[m
[32m+[m[32m```[m
[32m+[m[32mThis creates a fuel cell aging model with customized parameters and plots enabled.[m
[32m+[m
[32m+[m[32m"""[m
 mutable struct FunctHoursAgingFuelCell <: AbstractFuelCellAgingModel[m
   plot::Bool [m
[31m-  StartStop::Bool[m
[32m+[m[32m  start_stop::Bool[m
   deg_params::deg_params [m
   update_by_year::Int # The frequency (per year) of SoH and V(I) update[m
   J_ref::Float64 # The nominal current density[m
[36m@@ -206,42 +298,139 @@[m [mmutable struct FunctHoursAgingFuelCell <: AbstractFuelCellAgingModel[m
   coef_a::Float64 #The slope of voltage degradation for each functioning hour[m
   coef_b::Float64 #The ordinate at origin of voltage degradation for each functioning hour[m
 [m
[31m-  FunctHoursAgingFuelCell(;plot = false,[m
[31m-    StartStop = true,[m
[32m+[m[32m  function FunctHoursAgingFuelCell(;plot = false,[m
[32m+[m[32m    start_stop = true,[m
     deg_params = nothing,[m
     update_by_year = 12,[m
     J_ref = 0.62,[m
[31m-    J_base = 0.1[m
[31m-  ) = new(plot, StartStop, deg_params, update_by_year, J_ref, J_base)[m
[32m+[m[32m    J_base = 0.1,[m[41m [m
[32m+[m[32m    objective_hours = 15000.[m
[32m+[m[32m  )[m
[32m+[m
[32m+[m[32m  @assert(objective_hours > 0, "objective_hours should be greater than 0")[m
[32m+[m[32m  @assert(update_by_year > 0, "update_by_year should be greater than 0")[m
[32m+[m[32m  @assert(J_ref >= 0, "J_ref should be greater than 0")[m
[32m+[m
[32m+[m
[32m+[m[32m    #Degradation curves Î¼V/h as a function of the current density for different current densities[m
[32m+[m[32m    # See (https://oatao.univ-toulouse.fr/29665/1/Pessot_Alexandra.pdf) fig III.43[m
[32m+[m[32m    P_min = DataFrames.DataFrame(CSV.File(joinpath("Examples","data","P_min.csv"), delim = ",", header = [Symbol("J"),Symbol("V")], types=Dict(:J=>Float64, :V=>Float64)))[m
[32m+[m[32m    P_int = DataFrames.DataFrame(CSV.File(joinpath("Examples","data","P_int.csv"), delim = ",", header = [Symbol("J"),Symbol("V")], types=Dict(:J=>Float64, :V=>Float64)))[m
[32m+[m[32m    P_max = DataFrames.DataFrame(CSV.File(joinpath("Examples","data","P_max.csv"), delim = ",", header = [Symbol("J"),Symbol("V")], types=Dict(:J=>Float64, :V=>Float64)))[m
[32m+[m
[32m+[m[32m    datas_deg_FC = [P_min,P_int,P_max][m
[32m+[m
[32m+[m[32m    # Coresponding current densities (resp. P_min, P_int, P_max)[m
[32m+[m[32m    current_densities = [0.075, 0.42, 0.62][m
[32m+[m
[32m+[m[32m    #The voltage as a function of the current density at the beginning of life[m
[32m+[m[32m    V_J_FC = Matrix([m
[32m+[m[32m      transpose([m
[32m+[m[32m        Matrix([m
[32m+[m[32m          DataFrames.DataFrame(CSV.File(joinpath("Examples","data","V_J_PAC.csv"), delim = ",", header = [Symbol("J"),Symbol("V")], types=Dict(:J=>Float64, :V=>Float64)))[m
[32m+[m[32m          )))[m
[32m+[m
[32m+[m[32m    # RÃ©fÃ©rence current density for this Fuel cell     # See (https://oatao.univ-toulouse.fr/29665/1/Pessot_Alexandra.pdf)[m[41m [m
[32m+[m[32m    J_ref = 0.62[m
[32m+[m
[32m+[m[32m    degParams = create_deg_params(datas_deg_FC, current_densities, V_J_FC, J_ref, objective_hours)[m
[32m+[m
[32m+[m[32m    return new(plot, start_stop, degParams, update_by_year, J_ref, J_base)[m
[32m+[m[32m  end[m
 end[m
 [m
 [m
 [m
[31m-#M/A en option[m
[32m+[m[32m"""[m
[32m+[m[32m`FixedLifetimeFuelCell` models the aging of a fuel cell with a fixed operational lifetime.[m
[32m+[m
[32m+[m[32m# Fields[m
[32m+[m[32m- `plot::Bool`: Indicates if degradation plots should be generated.[m
[32m+[m[32m- `update_by_year::Int`: Frequency of State of Health (SoH) and polarization curve updates per year.[m
[32m+[m[32m- `J_ref::Float64`: Nominal current density of the fuel cell.[m
[32m+[m[32m- `nHourMax::Int64`: Maximum number of operational hours.[m
[32m+[m[32m- `lifetime::Int64`: Fixed lifetime of the fuel cell in years (derived from `nHourMax`).[m
[32m+[m[32m- `V_J_ini::AbstractArray{Float64,2}`: Initial voltage-current relationship at the start of the fuel cell's life.[m
[32m+[m[32m- `V_J::AbstractArray{Float64,3}`: Time-evolving voltage-current relationship during the fuel cell's life.[m
[32m+[m[32m- `V_nom_ini::Float64`: Nominal voltage at the start of the fuel cell's life (not set in the constructor).[m
[32m+[m
[32m+[m[32m# Constructor Parameters[m
[32m+[m[32m- `plot::Bool=false`: Whether to generate plots for degradation.[m
[32m+[m[32m- `update_by_year::Int=12`: Number of updates per year for the SoH and V(I) curves.[m
[32m+[m[32m- `J_ref::Float64=0.62`: Nominal current density.[m
[32m+[m[32m- `nHourMax::Int64=87600`: Maximum operational hours (default: 10 years).[m
[32m+[m
[32m+[m[32m# Example[m
[32m+[m[32m```julia[m
[32m+[m[32mfuel_cell = FixedLifetimeFuelCell(plot=true, update_by_year=6, J_ref=0.7, nHourMax=43800)[m
[32m+[m[32m```[m
[32m+[m[32mThis creates a fuel cell aging model with a lifetime of 5 years, using the provided nHourMax[m
[32m+[m[32m"""[m
 mutable struct FixedLifetimeFuelCell <: AbstractFuelCellAgingModel[m
   plot::Bool [m
   update_by_year::Int # The frequency (per year) of SoH and V(I) update[m
   J_ref::Float64 # The nominal current density[m
   nHourMax::Int64[m
[32m+[m[32m  lifetime::Float64[m
 [m
   V_J_ini::AbstractArray{Float64,2}[m
   V_J::AbstractArray{Float64,3}[m
 [m
   V_nom_ini::Float64[m
 [m
[31m-  FixedLifetimeFuelCell(;plot = false,[m
[32m+[m[32m  function FixedLifetimeFuelCell(;plot = false,[m
     update_by_year = 12,[m
     J_ref = 0.62,[m
     nHourMax = 87600[m
[31m-  ) = new(plot, update_by_year, J_ref, nHourMax)[m
[32m+[m[32m  )[m[41m [m
[32m+[m[32m    lifetime = div(nHourMax, 8760)[m[41m [m
[32m+[m[32m    new(plot, update_by_year, J_ref, nHourMax, lifetime)[m
[32m+[m[32m  end[m
 end[m
 [m
 [m
 [m
[31m-[m
[32m+[m[32m"""[m
[32m+[m[32m`FuelCell` represents the main structure for modeling fuel cell behavior, including efficiency, aging, and other key parameters.[m
[32m+[m
[32m+[m[32m# Fields[m
[32m+[m[32m- `eff_model::AbstractFuelCellEffModel`: The efficiency model used to calculate fuel cell efficiency.[m
[32m+[m[32m- `SoH_model::AbstractFuelCellAgingModel`: The aging model used to track the State of Health (SoH) of the fuel cell over time.[m
[32m+[m[32m- `couplage::Bool`: Indicates whether the SoH should influence other parameters (e.g., efficiency, output voltage).[m
[32m+[m[32m- `bounds::NamedTuple{(:lb, :ub), Tuple{Float64, Float64}}`: Bounds for operational parameters, such as voltage or power.[m
[32m+[m[32m- `SoH_threshold::Float64`: SoH level at which the fuel cell should be replaced.[m
[32m+[m[32m- `V_J_ini::AbstractArray{Float64,2}`: Initial voltage-current relationship for the fuel cell.[m
[32m+[m[32m- `soh_ini::Float64`: Initial SoH at the start of the simulation (default: 1.0, corresponding to 100% health).[m
[32m+[m[32m- `N_cell::Int64`: Number of cells assembled in the fuel cell stack.[m
[32m+[m[32m- `surface::Float64`: Surface area of the fuel cell stack (unit should be documented if relevant).[m
[32m+[m[32m- `Î·::AbstractArray{Float64,3}`: Efficiency evolution over time (hydrogen to electricity).[m
[32m+[m[32m- `carrier::Vector{EnergyCarrier}`: Vector of energy carriers used by the fuel cell (e.g., hydrogen, oxygen).[m
[32m+[m[32m- `soh::AbstractArray{Float64,3}`: Time-evolving State of Health for the fuel cell.[m
[32m+[m[32m- `cost::AbstractArray{Float64,2}`: Economic metrics associated with fuel cell operation (e.g., cost per hour, maintenance).[m
[32m+[m
[32m+[m[32m# Constructor Parameters[m
[32m+[m[32m- `eff_model::AbstractFuelCellEffModel=PolarizationFuelCellEfficiency()`: Efficiency model to be used.[m
[32m+[m[32m- `SoH_model::AbstractFuelCellAgingModel=PowerAgingFuelCell()`: Aging model to be used.[m
[32m+[m[32m- `couplage::Bool=true`: Whether SoH influences other parameters.[m
[32m+[m[32m- `bounds=(lb=0.0, ub=50.0)`: sizing power bounds for all-in-one design.[m
[32m+[m[32m- `SoH_threshold::Float64=0.9`: SoH replacement threshold (default: 90%).[m
[32m+[m[32m- `V_J_ini::AbstractArray{Float64,2}`: Initial voltage-current data (default loaded from a CSV file).[m
[32m+[m[32m- `soh_ini::Float64=1.0`: Initial SoH at the start of the simulation.[m
[32m+[m
[32m+[m[32m# Example[m
[32m+[m[32m```julia[m
[32m+[m[32mfuel_cell = FuelCell(eff_model=PolarizationFuelCellEfficiency(),[m
[32m+[m[32m                     SoH_model=PowerAgingFuelCell(),[m
[32m+[m[32m                     couplage=true,[m
[32m+[m[32m                     bounds=(lb=0.0, ub=60.0),[m
[32m+[m[32m                     SoH_threshold=0.8,[m
[32m+[m[32m                     soh_ini=1.0)[m
[32m+[m[32m```[m
[32m+[m[32mThis initializes a FuelCell structure with custom sizing power bounds and a lower SoH replacement threshold.[m
[32m+[m[32m"""[m
 mutable struct FuelCell <: AbstractFuelCell[m
 [m
[31m-  EffModel::AbstractFuelCellEffModel[m
[32m+[m[32m  eff_model::AbstractFuelCellEffModel[m
 	SoH_model::AbstractFuelCellAgingModel[m
   couplage::Bool  #a boolean tuple to tell wether or not the soh should influence the other parameters.[m
 [m
[36m@@ -265,14 +454,14 @@[m [mmutable struct FuelCell <: AbstractFuelCell[m
   # Eco[m
   cost::AbstractArray{Float64,2}[m
 [m
[31m-	FuelCell(;EffModel = PolarizationFuelCellEfficiency(),[m
[32m+[m	[32mFuelCell(;eff_model = PolarizationFuelCellEfficiency(),[m
     SoH_model = PowerAgingFuelCell(),[m
     couplage = true,[m
     bounds = (lb = 0., ub = 50.),[m
     SoH_threshold = 0.9,[m
[31m-    V_J_ini = nothing,[m
[32m+[m[32m    V_J_ini = Matrix(transpose(Matrix(DataFrames.DataFrame(CSV.File(joinpath("Examples","data","V_J_PAC.csv"), delim = ",", header = [Symbol("J"),Symbol("V")], types=Dict(:J=>Float64, :V=>Float64)))))),[m
     soh_ini = 1. [m
[31m-  ) = new(EffModel, SoH_model, couplage, bounds, SoH_threshold, V_J_ini, soh_ini)[m
[32m+[m[32m  ) = new(eff_model, SoH_model, couplage, bounds, SoH_threshold, V_J_ini, soh_ini)[m
 [m
 end[m
 [m
[36m@@ -282,8 +471,8 @@[m [mend[m
   ### Preallocation[m
   function preallocate!(fc::FuelCell, nh::Int64, ny::Int64, ns::Int64)[m
 [m
[31m-    fc.EffModel.powerMax = convert(SharedArray,zeros(nh+1, ny+1, ns)) ;  fc.EffModel.powerMax[1,1,:] .= fc.EffModel.powerMax_ini[m
[31m-    fc.EffModel.powerMin = convert(SharedArray,zeros(nh+1, ny+1, ns)) ;  fc.EffModel.powerMin[1,1,:] .= fc.EffModel.powerMax_ini[m
[32m+[m[32m    fc.eff_model.powerMax = convert(SharedArray,zeros(nh+1, ny+1, ns)) ;  fc.eff_model.powerMax[1,1,:] .= fc.eff_model.powerMax_ini[m
[32m+[m[32m    fc.eff_model.powerMin = convert(SharedArray,zeros(nh+1, ny+1, ns)) ;  fc.eff_model.powerMin[1,1,:] .= fc.eff_model.powerMax_ini[m
     fc.Î· = convert(SharedArray,zeros(nh+1, ny+1, ns))[m
     fc.carrier = [Electricity(), Heat(), Hydrogen()][m
     fc.carrier[1].power = convert(SharedArray,zeros(nh, ny, ns))[m
[36m@@ -292,14 +481,16 @@[m [mend[m
     fc.soh = convert(SharedArray,zeros(nh+1, ny+1, ns)) ; fc.soh[1,1,:] .= fc.soh_ini[m
     fc.cost = convert(SharedArray,zeros(ny, ns))[m
 [m
[32m+[m
[32m+[m
     fc.SoH_model.V_J_ini = zeros(3, length(fc.V_J_ini[1,:])) #J, V, P[m
     fc.SoH_model.V_J = zeros(3, length(fc.V_J_ini[1,:]), ns) #J, V, P[m
[31m-    fc.EffModel.V_J = zeros(3, length(fc.V_J_ini[1,:]), ns) #J, V, P[m
[32m+[m[32m    fc.eff_model.V_J = zeros(3, length(fc.V_J_ini[1,:]), ns) #J, V, P[m
 [m
     [m
[31m-    if fc.EffModel isa LinearFuelCellEfficiency[m
[31m-      fc.EffModel.a_Î· =  convert(SharedArray, zeros(ns))[m
[31m-      fc.EffModel.b_Î· = convert(SharedArray, zeros(ns))[m
[32m+[m[32m    if fc.eff_model isa LinearFuelCellEfficiency[m
[32m+[m[32m      fc.eff_model.a_Î· =  convert(SharedArray, zeros(ns))[m
[32m+[m[32m      fc.eff_model.b_Î· = convert(SharedArray, zeros(ns))[m
     end[m
 [m
 [m
[36m@@ -310,9 +501,9 @@[m [mend[m
 ### Operation dynamic[m
 function compute_operation_dynamics!(h::Int64, y::Int64, s::Int64, fc::FuelCell, decision::Float64, Î”h::Int64)[m
 [m
[31m-  fc.carrier[1].power[h,y,s], fc.carrier[2].power[h,y,s], fc.carrier[3].power[h,y,s] = compute_operation_efficiency(fc, fc.EffModel, h ,y ,s , decision, Î”h)[m
[32m+[m[32m  fc.carrier[1].power[h,y,s], fc.carrier[2].power[h,y,s], fc.carrier[3].power[h,y,s] = compute_operation_efficiency(fc, fc.eff_model, h ,y ,s , decision, Î”h)[m
 [m
[31m-  fc.soh[h+1,y,s], fc.EffModel.powerMax[h+1,y,s], fc.EffModel.powerMin[h+1,y,s] = compute_operation_soh(fc, fc.SoH_model, h ,y ,s, Î”h)[m
[32m+[m[32m  fc.soh[h+1,y,s], fc.eff_model.powerMax[h+1,y,s], fc.eff_model.powerMin[h+1,y,s] = compute_operation_soh(fc, fc.SoH_model, h ,y ,s, Î”h)[m
 [m
 end[m
 [m
[36m@@ -320,7 +511,7 @@[m [mend[m
 ### Operation dynamic[m
 function compute_operation_dynamics(fc::FuelCell, h::Int64, y::Int64, s::Int64, decision::Float64, Î”h::Int64)[m
 [m
[31m-  return compute_operation_efficiency(fc, fc.EffModel, h ,y ,s , decision, Î”h)[m
[32m+[m[32m  return compute_operation_efficiency(fc, fc.eff_model, h ,y ,s , decision, Î”h)[m
 [m
 end[m
 [m
[36m@@ -388,7 +579,7 @@[m [mfunction compute_operation_efficiency(fc::FuelCell, model::LinearFuelCellEfficie[m
       [m
       if Î·_E >= 0.46[m
         println("y,h = ", y, ", ", h, "   a_Î· = ", model.a_Î·[s], " , P_tot = ", P_tot, ", b_Î· = ",  model.b_Î·[s] )[m
[31m-        println("configuration = ",typeof(fc.EffModel) , ", ", typeof(fc.SoH_model), ", surface = ", fc.surface, ", Ncell = ", fc.N_cell, ", couple = ", fc.couplage )[m
[32m+[m[32m        println("configuration = ",typeof(fc.eff_model) , ", ", typeof(fc.SoH_model), ", surface = ", fc.surface, ", Ncell = ", fc.N_cell, ", couple = ", fc.couplage )[m
       end[m
 [m
 [m
[36m@@ -424,13 +615,13 @@[m [mfunction compute_operation_soh(fc::FuelCell, model::PowerAgingFuelCell, h::Int64[m
     # get the sequence of intensities[m
     for p in powers[m
         if p .> 1e-6[m
[31m-          if p > maximum(fc.EffModel.V_J[3,:,s])[m
[31m-            println("Power = ", p, " > ", "max P(J) = ", maximum(fc.EffModel.V_J[3,:,s]), " h, y, s = ", h, ", " , y, ", ", s)[m
[31m-            println("configuration = ",typeof(fc.EffModel) , ", ", typeof(fc.SoH_model), ", surface = ", fc.surface, ", Ncell = ", fc.N_cell, ", couplage = ", fc.couplage )[m
[32m+[m[32m          if p > maximum(fc.eff_model.V_J[3,:,s])[m
[32m+[m[32m            println("Power = ", p, " > ", "max P(J) = ", maximum(fc.eff_model.V_J[3,:,s]), " h, y, s = ", h, ", " , y, ", ", s)[m
[32m+[m[32m            println("configuration = ",typeof(fc.eff_model) , ", ", typeof(fc.SoH_model), ", surface = ", fc.surface, ", Ncell = ", fc.N_cell, ", couplage = ", fc.couplage )[m
 [m
             p = floor(maximum(model.V_J[3,:,s]), digits =2)[m
           end[m
[31m-            push!(current_densities, interpolation(fc.EffModel.V_J[3,:,s], fc.EffModel.V_J[1,:,s], p, true))[m
[32m+[m[32m            push!(current_densities, interpolation(fc.eff_model.V_J[3,:,s], fc.eff_model.V_J[1,:,s], p, true))[m
         end[m
     end[m
 [m
[36m@@ -450,7 +641,7 @@[m [mfunction compute_operation_soh(fc::FuelCell, model::PowerAgingFuelCell, h::Int64[m
 [m
     V_nom = interpolation(model.V_J[1,:,s], model.V_J[2,:,s], model.J_ref, true)[m
 [m
[31m-    if model.StartStop[m
[32m+[m[32m    if model.start_stop[m
       start_stop_count = get_start_stops(powers)[m
       model.V_J[2,:,s] .-= model.deg_params.start_stop_coef * V_nom * start_stop_count[m
     end [m
[36m@@ -471,22 +662,22 @@[m [mfunction compute_operation_soh(fc::FuelCell, model::PowerAgingFuelCell, h::Int64[m
     nextSoH = V_nom/V_nom_ini  [m
 [m
     if fc.couplage[m
[31m-      nextPowerMax = maximum(model.V_J[3,:,s]) * (1-fc.EffModel.k_aux)[m
[32m+[m[32m      nextPowerMax = maximum(model.V_J[3,:,s]) * (1-fc.eff_model.k_aux)[m
       nextPowerMin = compute_min_power(fc, s)[m
[31m-      fc.EffModel.V_J[:,:,s] = copy(model.V_J[:,:,s])[m
[32m+[m[32m      fc.eff_model.V_J[:,:,s] = copy(model.V_J[:,:,s])[m
 [m
[31m-      if fc.EffModel isa LinearFuelCellEfficiency [m
[31m-        update_Î·_lin(fc, fc.EffModel, s)[m
[32m+[m[32m      if fc.eff_model isa LinearFuelCellEfficiency[m[41m [m
[32m+[m[32m        update_Î·_lin(fc, fc.eff_model, s)[m
       end[m
 [m
     else[m
[31m-      nextPowerMax = fc.EffModel.powerMax[h,y,s] [m
[31m-      nextPowerMin = fc.EffModel.powerMin[h,y,s] [m
[32m+[m[32m      nextPowerMax = fc.eff_model.powerMax[h,y,s][m[41m [m
[32m+[m[32m      nextPowerMin = fc.eff_model.powerMin[h,y,s][m[41m [m
     end[m
   else [m
     nextSoH = fc.soh[h,y,s] [m
[31m-    nextPowerMax = fc.EffModel.powerMax[h,y,s] [m
[31m-    nextPowerMin = fc.EffModel.powerMin[h,y,s] [m
[32m+[m[32m    nextPowerMax = fc.eff_model.powerMax[h,y,s][m[41m [m
[32m+[m[32m    nextPowerMin = fc.eff_model.powerMin[h,y,s][m[41m [m
   end[m
 [m
   return nextSoH, nextPowerMax, nextPowerMin[m
[36m@@ -516,7 +707,7 @@[m [mfunction compute_operation_soh(fc::FuelCell, model::FunctHoursAgingFuelCell, h::[m
 [m
     V_nom = interpolation(model.V_J[1,:,s], model.V_J[2,:,s], model.J_ref, true)[m
 [m
[31m-    if model.StartStop[m
[32m+[m[32m    if model.start_stop[m
       start_stop_count = get_start_stops(powers)[m
       model.V_J[2,:,s] .-= model.deg_params.start_stop_coef * V_nom * start_stop_count[m
     end [m
[36m@@ -537,22 +728,22 @@[m [mfunction compute_operation_soh(fc::FuelCell, model::FunctHoursAgingFuelCell, h::[m
     nextSoH = V_nom/V_nom_ini  [m
 [m
       if fc.couplage[m
[31m-        nextPowerMax = maximum(model.V_J[3,:,s]) * (1-fc.EffModel.k_aux)[m
[32m+[m[32m        nextPowerMax = maximum(model.V_J[3,:,s]) * (1-fc.eff_model.k_aux)[m
         nextPowerMin = compute_min_power(fc, s)[m
[31m-        fc.EffModel.V_J[:,:,s] = copy(model.V_J[:,:,s])[m
[32m+[m[32m        fc.eff_model.V_J[:,:,s] = copy(model.V_J[:,:,s])[m
 [m
[31m-          if fc.EffModel isa LinearFuelCellEfficiency [m
[31m-            update_Î·_lin(fc, fc.EffModel, s)[m
[32m+[m[32m          if fc.eff_model isa LinearFuelCellEfficiency[m[41m [m
[32m+[m[32m            update_Î·_lin(fc, fc.eff_model, s)[m
           end[m
 [m
       else[m
[31m-        nextPowerMax = fc.EffModel.powerMax[h,y,s] [m
[31m-        nextPowerMin = fc.EffModel.powerMin[h,y,s] [m
[32m+[m[32m        nextPowerMax = fc.eff_model.powerMax[h,y,s][m[41m [m
[32m+[m[32m        nextPowerMin = fc.eff_model.powerMin[h,y,s][m[41m [m
       end[m
   else [m
     nextSoH = fc.soh[h,y,s] [m
[31m-    nextPowerMax = fc.EffModel.powerMax[h,y,s] [m
[31m-    nextPowerMin = fc.EffModel.powerMin[h,y,s] [m
[32m+[m[32m    nextPowerMax = fc.eff_model.powerMax[h,y,s][m[41m [m
[32m+[m[32m    nextPowerMin = fc.eff_model.powerMin[h,y,s][m[41m [m
   end[m
 [m
   return nextSoH, nextPowerMax, nextPowerMin[m
[36m@@ -584,22 +775,22 @@[m [mfunction compute_operation_soh(fc::FuelCell, model::FixedLifetimeFuelCell, h::In[m
 [m
 [m
       if fc.couplage[m
[31m-        nextPowerMax = maximum(model.V_J[3,:,s]) * (1-fc.EffModel.k_aux)[m
[32m+[m[32m        nextPowerMax = maximum(model.V_J[3,:,s]) * (1-fc.eff_model.k_aux)[m
         nextPowerMin = compute_min_power(fc, s)[m
[31m-        fc.EffModel.V_J[:,:,s] = copy(model.V_J[:,:,s])[m
[32m+[m[32m        fc.eff_model.V_J[:,:,s] = copy(model.V_J[:,:,s])[m
 [m
[31m-          if fc.EffModel isa LinearFuelCellEfficiency [m
[31m-            update_Î·_lin(fc, fc.EffModel, s)[m
[32m+[m[32m          if fc.eff_model isa LinearFuelCellEfficiency[m[41m [m
[32m+[m[32m            update_Î·_lin(fc, fc.eff_model, s)[m
           end[m
 [m
       else[m
[31m-        nextPowerMax = fc.EffModel.powerMax[h,y,s] [m
[31m-        nextPowerMin = fc.EffModel.powerMin[h,y,s] [m
[32m+[m[32m        nextPowerMax = fc.eff_model.powerMax[h,y,s][m[41m [m
[32m+[m[32m        nextPowerMin = fc.eff_model.powerMin[h,y,s][m[41m [m
       end[m
   else [m
     nextSoH = fc.soh[h,y,s] [m
[31m-    nextPowerMax = fc.EffModel.powerMax[h,y,s] [m
[31m-    nextPowerMin = fc.EffModel.powerMin[h,y,s] [m
[32m+[m[32m    nextPowerMax = fc.eff_model.powerMax[h,y,s][m[41m [m
[32m+[m[32m    nextPowerMin = fc.eff_model.powerMin[h,y,s][m[41m [m
   end[m
 [m
   return nextSoH, nextPowerMax, nextPowerMin[m
[36m@@ -613,14 +804,14 @@[m [mfunction initialize_investments!(s::Int64, fc::FuelCell, decision::NamedTuple{(:[m
   fc.soh[1,1,s] = fc.soh_ini[m
 [m
 [m
[31m-  fc.EffModel.V_J[1,:,s] = copy(fc.V_J_ini[1,:]) [m
[31m-  fc.EffModel.V_J[2,:,s] = copy(fc.V_J_ini[2,:])[m
[31m-  fc.EffModel.V_J[3,:,s] = fc.V_J_ini[2,:] .* fc.V_J_ini[1,:] * fc.surface * fc.N_cell[m
[31m-  fc.EffModel.powerMax[1,1,s] = maximum(fc.EffModel.V_J[3,:,s]) * (1-fc.EffModel.k_aux)[m
[31m-  fc.EffModel.powerMin[1,1,s] = compute_min_power(fc, s)[m
[32m+[m[32m  fc.eff_model.V_J[1,:,s] = copy(fc.V_J_ini[1,:])[m[41m [m
[32m+[m[32m  fc.eff_model.V_J[2,:,s] = copy(fc.V_J_ini[2,:])[m
[32m+[m[32m  fc.eff_model.V_J[3,:,s] = fc.V_J_ini[2,:] .* fc.V_J_ini[1,:] * fc.surface * fc.N_cell[m
[32m+[m[32m  fc.eff_model.powerMax[1,1,s] = maximum(fc.eff_model.V_J[3,:,s]) * (1-fc.eff_model.k_aux)[m
[32m+[m[32m  fc.eff_model.powerMin[1,1,s] = compute_min_power(fc, s)[m
 [m
[31m-  if fc.EffModel isa LinearFuelCellEfficiency [m
[31m-    update_Î·_lin(fc, fc.EffModel, s)[m
[32m+[m[32m  if fc.eff_model isa LinearFuelCellEfficiency[m[41m [m
[32m+[m[32m    update_Î·_lin(fc, fc.eff_model, s)[m
   end[m
 [m
   #Initialization of V(J)[m
[36m@@ -648,7 +839,7 @@[m [mend[m
 [m
   ### Investment dynamic[m
   function compute_investment_dynamics!(y::Int64, s::Int64, fc::FuelCell,  decision::NamedTuple{(:surface, :N_cell), Tuple{Float64, Int64}})    [m
[31m-    fc.EffModel.powerMax[1,y+1,s], fc.EffModel.powerMin[1,y+1,s], fc.soh[1,y+1,s] = compute_investment_dynamics(fc, (powerMax = fc.EffModel.powerMax[end,y,s], powerMin = fc.EffModel.powerMin[end,y,s], soh = fc.soh[end,y,s]), decision, s)[m
[32m+[m[32m    fc.eff_model.powerMax[1,y+1,s], fc.eff_model.powerMin[1,y+1,s], fc.soh[1,y+1,s] = compute_investment_dynamics(fc, (powerMax = fc.eff_model.powerMax[end,y,s], powerMin = fc.eff_model.powerMin[end,y,s], soh = fc.soh[end,y,s]), decision, s)[m
   end[m
 [m
   [m
[36m@@ -670,14 +861,14 @@[m [mend[m
         soh_next = fc.soh_ini[m
 [m
         fc.SoH_model.V_J[:,:,s] = copy(V_J)[m
[31m-        fc.EffModel.V_J[:,:,s] = copy(V_J)[m
[32m+[m[32m        fc.eff_model.V_J[:,:,s] = copy(V_J)[m
 [m
[31m-        powerMax_next = maximum(V_J[3,:]) * (1-fc.EffModel.k_aux)[m
[32m+[m[32m        powerMax_next = maximum(V_J[3,:]) * (1-fc.eff_model.k_aux)[m
 [m
         powerMin_next = compute_min_power(fc, s)[m
 [m
[31m-        if fc.EffModel isa LinearFuelCellEfficiency [m
[31m-          update_Î·_lin(fc, fc.EffModel, s)[m
[32m+[m[32m        if fc.eff_model isa LinearFuelCellEfficiency[m[41m [m
[32m+[m[32m          update_Î·_lin(fc, fc.eff_model, s)[m
         end[m
 [m
     else[m
[36m@@ -718,14 +909,14 @@[m [mend[m
 function get_Î·_E(P_net::Float64, fc::FuelCell, s::Int64)[m
 [m
   [m
[31m-  P_tot = floor(P_net / (1 - fc.EffModel.k_aux); digits=6)[m
[32m+[m[32m  P_tot = floor(P_net / (1 - fc.eff_model.k_aux); digits=6)[m
 [m
   [m
   #Find the corresponding current from an interpolation from P(I) curve [m
[31m-  j = interpolation(fc.EffModel.V_J[3,:,s], fc.EffModel.V_J[1,:,s], P_tot, true )[m
[32m+[m[32m  j = interpolation(fc.eff_model.V_J[3,:,s], fc.eff_model.V_J[1,:,s], P_tot, true )[m
   i = j * fc.surface[m
 [m
[31m-  return P_net / (fc.EffModel.K * i * fc.N_cell)[m
[32m+[m[32m  return P_net / (fc.eff_model.K * i * fc.N_cell)[m
 [m
 end[m
 [m
[36m@@ -734,11 +925,11 @@[m [mend[m
 [m
 #compute the power that correpond to the maximum allowed tension[m
 function compute_min_power(fc::FuelCell, s::Int64)[m
[31m-  if fc.EffModel isa FixedFuelCellEfficiency[m
[31m-    P_min = fc.EffModel.Î±_p * maximum(fc.EffModel.V_J[3,:,s])[m
[32m+[m[32m  if fc.eff_model isa FixedFuelCellEfficiency[m
[32m+[m[32m    P_min = fc.eff_model.Î±_p * maximum(fc.eff_model.V_J[3,:,s])[m
   else[m
[31m-    P_min_tot = interpolation(fc.EffModel.V_J[2,:,s], fc.EffModel.V_J[3,:,s], fc.EffModel.V_max, false )[m
[31m-    P_min = P_min_tot / (1 + fc.EffModel.k_aux)[m
[32m+[m[32m    P_min_tot = interpolation(fc.eff_model.V_J[2,:,s], fc.eff_model.V_J[3,:,s], fc.eff_model.V_max, false )[m
[32m+[m[32m    P_min = P_min_tot / (1 + fc.eff_model.k_aux)[m
   end[m
   return P_min[m
 end[m
[36m@@ -780,19 +971,19 @@[m [mfunction update_Î·_lin(fc::FuelCell, model::LinearFuelCellEfficiency, s::Int64)[m
  [m
 [m
 [m
[31m-  fc.EffModel.a_Î·[s] = a_Î·[m
[31m-  fc.EffModel.b_Î·[s] = b_Î·[m
[32m+[m[32m  fc.eff_model.a_Î·[s] = a_Î·[m
[32m+[m[32m  fc.eff_model.b_Î·[s] = b_Î·[m
 [m
 end[m
 [m
 [m
 function toStringShort(fc::FuelCell)[m
 [m
[31m-	if fc.EffModel isa LinearFuelCellEfficiency[m
[32m+[m	[32mif fc.eff_model isa LinearFuelCellEfficiency[m
 		efficiency = "x"[m
[31m-	elseif fc.EffModel isa PolarizationFuelCellEfficiency[m
[32m+[m	[32melseif fc.eff_model isa PolarizationFuelCellEfficiency[m
 		efficiency = "V(J)"[m
[31m-  elseif fc.EffModel isa FixedFuelCellEfficiency[m
[32m+[m[32m  elseif fc.eff_model isa FixedFuelCellEfficiency[m
 		efficiency = "fix."[m
 	end[m
 [m
[36m@@ -808,7 +999,8 @@[m [mfunction toStringShort(fc::FuelCell)[m
 end[m
 [m
 [m
[31m-function create_deg_params(datas::Vector{DataFrames.DataFrame}, Js::Vector{Float64}, V_J::Matrix{Float64}, J_ref::Float64, objective_lifetime::Float64; power = 1/2, plot = false)[m
[32m+[m
[32m+[m[32mfunction create_deg_params(datas::Vector{DataFrames.DataFrame}, Js::Vector{Float64}, V_J::Matrix{Float64}, J_ref::Float64, objective_lifetime::Float64; power = 1/2, plot = false, start_stop_coef = 0.0000196)[m
 [m
   #Maximum deg profil in Alexandra Pessot thesis[m
   P_max = datas[3][m
[36m@@ -816,6 +1008,7 @@[m [mfunction create_deg_params(datas::Vector{DataFrames.DataFrame}, Js::Vector{Float[m
   #Get affine coef from input data[m
   as, b = fit_all_curves(datas, Js; plot = plot)[m
 [m
[32m+[m[41m  [m
   #get a,b,c coef to be able to write the degradation as ax^power + bx + c[m
   a_slope, b_slope, c_slope = fit_dot(Js, as, power; plot = plot)[m
 [m
[36m@@ -825,14 +1018,19 @@[m [mfunction create_deg_params(datas::Vector{DataFrames.DataFrame}, Js::Vector{Float[m
   Î”V_tot = V_ini_ref * 0.1[m
 [m
   #Voltage ref loss[m
[32m+[m[32m  a = a_slope * (J_ref ^ power) + b_slope * J_ref + c_slope[m
[32m+[m[32m  V_deg_ref = a * J_ref + b[m
   V_deg_ref = interpolation(P_max.J,  P_max.V, J_ref, true)[m
 [m
   #Adujst the lifetime to fit a target (The FC will be able to be used at its ref current density for the target amount of hour)[m
   current_lifetime = Î”V_tot / (V_deg_ref * 1e-6)[m
 [m
[31m-  adaptation_coefficient = current_lifetime * 1e-6/objective_lifetime[m
[32m+[m[32m  ###########################################################################################[m
[32m+[m[32m  ######################### Attention !!!!!    ##########################################[m
[32m+[m[32m  ###########################################################################################[m
[32m+[m[32m  adaptation_coefficient = current_lifetime * 1e-6/objective_lifetime # Attention Ã  ce 1e-6 qui sert Ã  mettre les deg en microvolt et ne devrait pas Ãªtre ici[m
 [m
[31m-  start_stop_coef = 0.0000196 #0.00196% as stated in Pucheng Pei, Qianfei Chang, Tian Tang,[m
[32m+[m[32m  start_stop_coef = start_stop_coef #0.00196% as stated in Pucheng Pei, Qianfei Chang, Tian Tang,[m
  # A quick evaluating method for automotive fuel cell lifetime (https://doi.org/10.1016/j.ijhydene.2008.04.048)[m
   [m
   return deg_params(a_slope, b_slope, c_slope, power, b, adaptation_coefficient, start_stop_coef)[m
[36m@@ -845,14 +1043,16 @@[m [mend[m
   [m
 [m
 [m
[31m-function fit_all_curves(data, Js; plot = false)[m
[32m+[m[32mfunction fit_all_curves(data, Js; plot = false, silent = true)[m
 [m
   n_data = length(data)[m
   n_data_point = [length(data[i].J) for i in 1:n_data][m
 [m
 [m
[31m-  m2 = Model(Ipopt.Optimizer)[m
[31m-  #set_optimizer_attribute(m2, "TimeLimit", 100)[m
[32m+[m[32m  m2 = Model(Gurobi.Optimizer)[m
[32m+[m[32m  if silent[m
[32m+[m[32m    set_optimizer_attribute(m2, "OutputFlag", 0)[m
[32m+[m[32m  end[m
   [m
   @variable(m2, a[1:n_data] >= 0)[m
   @variable(m2, b >= 0)[m
[36m@@ -866,26 +1066,36 @@[m [mfunction fit_all_curves(data, Js; plot = false)[m
 [m
   JuMP.optimize!(m2)[m
   if plot[m
[31m-    plt = PyPlot.subplot()[m
[32m+[m[32m    plt.rcParams["text.usetex"] = true[m
[32m+[m
[32m+[m[32m    fig, ax = plt.subplots()[m
[32m+[m[32m    fig.set_size_inches( 1920 / fig.dpi, 1080/ fig.dpi)[m
[32m+[m
     for d in 1:n_data[m
[31m-        PyPlot.scatter(data[d].J, data[d].V, label = string(Js[d] , " A/cmÂ² : data"))[m
[31m-        PyPlot.plot(data[d].J, data[d].J .* value.(m2[:a])[d] .+ value(m2[:b]), label = string(Js[d] , " A/cmÂ² : model"))[m
[32m+[m[32m      PyPlot.scatter(data[d].J, data[d].V, label = string(Js[d] , " [A/cmÂ²] : data"))[m
[32m+[m[32m      PyPlot.plot(data[d].J, data[d].J .* value.(m2[:a])[d] .+ value(m2[:b]), label = string(Js[d] , " [A/cmÂ²] : model"))[m
     end[m
[31m-    plt.set_xlabel("Current density (A/cmÂ²)", fontsize=20)[m
[31m-    plt.set_ylabel("Î¼V/h", fontsize=20)[m
[31m-    PyPlot.legend(fontsize = 15)[m
[32m+[m[32m    PyPlot.xlabel("Current density [A/cmÂ²]")[m
[32m+[m[32m    PyPlot.ylabel("\$Î”V\$ [Î¼V/h]")[m
[32m+[m[32m    PyPlot.legend()[m
[32m+[m
[32m+[m[32m    PyPlot.tight_layout()[m
[32m+[m
   end[m
 [m
[32m+[m
   return value.(m2[:a]), value(m2[:b])[m
 end[m
 [m
 [m
[31m-function fit_dot(Js, as, power; plot = false)[m
[32m+[m[32mfunction fit_dot(Js, as, power; plot = false, silent = true)[m
 [m
   n_data_point = length(Js)[m
 [m
[31m-  m2 = Model(Ipopt.Optimizer)[m
[31m-  #set_optimizer_attribute(m2, "TimeLimit", 100)[m
[32m+[m[32m  m2 = Model(Gurobi.Optimizer)[m
[32m+[m[32m  if silent[m
[32m+[m[32m    set_optimizer_attribute(m2, "OutputFlag", 0)[m
[32m+[m[32m  end[m
   [m
   @variable(m2, a)[m
   @variable(m2, b)[m
[36m@@ -901,22 +1111,28 @@[m [mfunction fit_dot(Js, as, power; plot = false)[m
 [m
   JuMP.optimize!(m2)[m
 [m
[31m-  if plot [m
[31m-    p = PyPlot.subplot()[m
[32m+[m[32m  if plot[m
[32m+[m[32m    fig, ax = plt.subplots()[m
[32m+[m[32m    fig.set_size_inches( 1920 / fig.dpi, 1080/ fig.dpi)[m
[32m+[m
[32m+[m[32m    interval = 0:0.01:1[m
[32m+[m[32m    PyPlot.plot(interval, [value(m2[:a])*x^(power)+(value(m2[:b]) * x) + value(m2[:c]) for x in interval], label = string("\$ax^{$power} + bx + c\$"))[m
 [m
[31m-    interval =0:0.01:1[m
[31m-    PyPlot.plot(interval, [value(m2[:a])*x^(power)+(value(m2[:b]) * x) + value(m2[:c]) for x in interval], label = string("ax^", power, " + bx + c"))[m
[32m+[m[32m    PyPlot.xlabel("Current density [A/cmÂ²]")[m
[32m+[m[32m    PyPlot.ylabel("Slope")[m
[32m+[m[32m    PyPlot.legend()[m
[32m+[m[32m    plt.rcParams["text.usetex"] = true[m
[32m+[m
[32m+[m[32m    PyPlot.vlines(0.14, ymin = ax.get_ylim()[1], ymax = ax.get_ylim()[2] , color = "black", linewidth = 2)[m
[32m+[m[32m    ax[:set_ylim]([0,ax.get_ylim()[2]])[m
[32m+[m[32m    ax[:set_xlim]([0,ax.get_xlim()[2]])[m
 [m
[31m-    p.set_xlabel("Current density (A/cmÂ²)", fontsize=20)[m
[31m-    p.set_ylabel("Slope", fontsize=20)[m
[31m-    PyPlot.legend(fontsize = 15)[m
[31m-    [m
     [m
     PyPlot.scatter(Js, as, label = "Fitted slopes coefficients")[m
[31m-    PyPlot.legend(fontsize = 15)[m
[31m-  [m
[31m-  end[m
[32m+[m[32m    PyPlot.legend()[m
 [m
[32m+[m[32m    PyPlot.tight_layout()[m
[32m+[m[32m  end[m
 [m
   return value(m2[:a]), value(m2[:b]), value(m2[:c])[m
 end[m
[1mdiff --git a/src/assets/h2tank.jl b/src/assets/h2tank.jl[m
[1mindex 03489ea..3c6e0ca 100644[m
[1m--- a/src/assets/h2tank.jl[m
[1m+++ b/src/assets/h2tank.jl[m
[36m@@ -1,6 +1,32 @@[m
[31m-#=[m
[31m-    H2 tank storage modelling[m
[31m- =#[m
[32m+[m[32mabstract type AbstractH2TankEffModel end[m
[32m+[m
[32m+[m[32mabstract type AbstractH2TankAgingModel end[m
[32m+[m
[32m+[m[32mmutable struct FixedH2TankEfficiency <: AbstractH2TankEffModel[m
[32m+[m
[32m+[m	[32mÎ·_ch::Float64 #Charging efficiency[m
[32m+[m	[32mÎ·_dch::Float64 #Discharging efficiency[m
[32m+[m	[32mÎ±_p_ch::Float64 #C_rate max[m
[32m+[m	[32mÎ±_p_dch::Float64 #C_rate max[m
[32m+[m	[32mÎ·_self::Float64 #Auto discarge factor[m
[32m+[m[41m	[m
[32m+[m[41m	[m
[32m+[m	[32mFixedH2TankEfficiency(;Î·_ch = 1.,[m
[32m+[m		[32mÎ·_dch = 1.,[m
[32m+[m		[32mÎ±_p_ch = 1.5,[m
[32m+[m		[32mÎ±_p_dch = 1.5,[m
[32m+[m		[32mÎ·_self = 0.0,[m
[32m+[m		[32m) = new(Î·_ch, Î·_dch, Î±_p_ch, Î±_p_dch, Î·_self)[m
[32m+[m
[32m+[m[32mend[m
[32m+[m
[32m+[m[32mmutable struct FixedH2TankLifetime <: AbstractH2TankAgingModel[m
[32m+[m
[32m+[m	[32mlifetime::Int64[m
[32m+[m
[32m+[m	[32mFixedH2TankLifetime(;lifetime = 25) = new(lifetime)[m
[32m+[m[32mend[m
[32m+[m
 [m
  """[m
  mutable struct H2Tank  <: AbstractStorage[m
[36m@@ -28,14 +54,10 @@[m [mA mutable struct representing a hydrogen tank storage model with various paramet[m
 mutable struct H2Tank  <: AbstractStorage[m
    # ParamÃ¨tres[m
    pression_max::Float64 # Pression en Bar[m
[31m-   Î±_p_ch::Float64[m
[31m-   Î±_p_dch::Float64[m
[31m-   Î·_ch::Float64[m
[31m-   Î·_dch::Float64[m
[31m-   Î·_self::Float64[m
[32m+[m[32m   eff_model::AbstractH2TankEffModel # Efficiency model[m
    Î±_soc_min::Float64[m
    Î±_soc_max::Float64[m
[31m-   lifetime::Int64[m
[32m+[m[32m   SoH_model::AbstractH2TankAgingModel # Aging model[m
    bounds::NamedTuple{(:lb, :ub), Tuple{Float64, Float64}}[m
    # Initial conditions[m
    Erated_ini::Float64[m
[36m@@ -50,19 +72,15 @@[m [mmutable struct H2Tank  <: AbstractStorage[m
    # Inner constructor[m
    H2Tank(;[m
       pression_max = 150., # Pression en Bar,[m
[31m-      Î±_p_ch = 0.5,[m
[31m-      Î±_p_dch = 0.5,[m
[31m-      Î·_ch = 1.,[m
[31m-      Î·_dch = 1.,[m
[31m-      Î·_self = 0.,[m
[31m-      Î±_soc_min = 0.,[m
[32m+[m[32m      eff_model = FixedH2TankEfficiency(),[m
[32m+[m[32m      Î±_soc_min = .05 ,[m
       Î±_soc_max = 1.,[m
[31m-      lifetime = 25,[m
[32m+[m[32m      SoH_model = FixedH2TankLifetime(),[m
       bounds = (lb = 0., ub = 10000.),[m
       Erated_ini = 1e-6,[m
       soc_ini = 0.5,[m
       soh_ini = 1.) =[m
[31m-      new(pression_max, Î±_p_ch, Î±_p_dch, Î·_ch, Î·_dch, Î·_self, Î±_soc_min, Î±_soc_max, lifetime, bounds, Erated_ini, soc_ini, soh_ini)[m
[32m+[m[32m      new(pression_max, eff_model, Î±_soc_min, Î±_soc_max, SoH_model, bounds, Erated_ini, soc_ini, soh_ini)[m
 end[m
 [m
 """[m
[36m@@ -95,11 +113,11 @@[m [mCompute the operation dynamics of the hydrogen tank storage for the given state,[m
 """[m
 function compute_operation_dynamics(h2tank::H2Tank, state::NamedTuple{(:Erated, :soc), Tuple{Float64, Float64}}, decision::Float64, Î”h::Int64)[m
   # Control power constraint and correction[m
[31m-  power_dch = max(min(decision, h2tank.Î±_p_dch * state.Erated, h2tank.Î·_dch * (state.soc * (1. - h2tank.Î·_self * Î”h) - h2tank.Î±_soc_min) * state.Erated / Î”h), 0.)[m
[31m-  power_ch = min(max(decision, -h2tank.Î±_p_ch * state.Erated, (state.soc * (1. - h2tank.Î·_self * Î”h) - h2tank.Î±_soc_max) * state.Erated / Î”h / h2tank.Î·_ch), 0.)[m
[32m+[m[32m  power_dch = max(min(decision, h2tank.eff_model.Î±_p_dch * state.Erated, h2tank.eff_model.Î·_dch * (state.soc * (1. - h2tank.eff_model.Î·_self * Î”h) - h2tank.Î±_soc_min) * state.Erated / Î”h), 0.)[m
[32m+[m[32m  power_ch = min(max(decision, -h2tank.eff_model.Î±_p_ch * state.Erated, (state.soc * (1. - h2tank.eff_model.Î·_self * Î”h) - h2tank.Î±_soc_max) * state.Erated / Î”h / h2tank.eff_model.Î·_ch), 0.)[m
   # SoC dynamic[m
   if state.Erated != 0[m
[31m-    soc_next = state.soc * (1. - h2tank.Î·_self * Î”h) - (power_ch * h2tank.Î·_ch + power_dch / h2tank.Î·_dch) * Î”h / state.Erated[m
[32m+[m[32m    soc_next = state.soc * (1. - h2tank.eff_model.Î·_self * Î”h) - (power_ch * h2tank.eff_model.Î·_ch + power_dch / h2tank.eff_model.Î·_dch) * Î”h / state.Erated[m
   else[m
     soc_next = 0[m
   end[m
[1mdiff --git a/src/assets/heater.jl b/src/assets/heater.jl[m
[1mindex 282f097..a3c183e 100644[m
[1m--- a/src/assets/heater.jl[m
[1m+++ b/src/assets/heater.jl[m
[36m@@ -1,3 +1,11 @@[m
[32m+[m[32mabstract type AbstractHeater <: AbstractConverter  end[m
[32m+[m
[32m+[m[32mabstract type AbstractHeaterEffModel end[m
[32m+[m
[32m+[m[32mabstract type AbstractHeaterAgingModel end[m
[32m+[m
[32m+[m
[32m+[m
 #=[m
     Heater modelling[m
  =#[m
[36m@@ -7,8 +15,8 @@[m
 A mutable struct representing a Heater, which is a subtype of `AbstractConverter`.[m
 [m
 # Parameters[m
[31m-- `Î·_E_H::Float64`: The conversion efficiency of the heater.[m
[31m-- `lifetime::Int64`: The expected lifetime of the heater (in years).[m
[32m+[m[32m- `eff_model::AbstractHeaterEffModel`: The model for conversion efficiency of the heater.[m
[32m+[m[32m- `SoH_model::AbstractHeaterAgingModel`: The aging model for the heater. The default model use a fixed expected lifetime for the heater (in years).[m
 - `bounds::NamedTuple{(:lb, :ub), Tuple{Float64, Float64}}`: The lower and upper bounds of the heater's power.[m
 - `powerMax_ini::Float64`: The initial maximum power output of the heater.[m
 - `soh_ini::Float64`: The initial state of health of the heater.[m
[36m@@ -22,13 +30,13 @@[m [mA mutable struct representing a Heater, which is a subtype of `AbstractConverter[m
 ## Example[m
 [m
 ```julia[m
[31m-heater = Heater(Î·_E_H=1.0, lifetime=25, bounds=(lb=30.0, ub=30.0), powerMax_ini=30.0, soh_ini=1.0)[m
[32m+[m[32mheater = Heater(eff_model=ConstEfficiencyHeater(Î·_E_H=1.0), SoH_model=FixedLifetimeHeater(lifetime=25), bounds=(lb=30.0, ub=30.0), powerMax_ini=30.0, soh_ini=1.0)[m
 ```[m
 """[m
[31m-mutable struct Heater <: AbstractConverter[m
[32m+[m[32mmutable struct Heater <: AbstractHeater[m
   # Parameters[m
[31m-  Î·_E_H::Float64[m
[31m-  lifetime::Int64[m
[32m+[m[32m  eff_model::AbstractHeaterEffModel[m
[32m+[m[32m  SoH_model::AbstractHeaterAgingModel[m
   bounds::NamedTuple{(:lb, :ub), Tuple{Float64, Float64}}[m
   # Initial conditions[m
   powerMax_ini::Float64[m
[36m@@ -39,14 +47,30 @@[m [mmutable struct Heater <: AbstractConverter[m
   # Eco[m
   cost::AbstractArray{Float64,2}[m
   # Inner constructor[m
[31m-  Heater(; Î·_E_H = 1.,[m
[31m-          lifetime = 25,[m
[32m+[m[32m  Heater(; eff_model = ConstEfficiencyHeater(),[m
[32m+[m[32m          SoH_model = FixedLifetimeHeater(),[m
           bounds = (lb = 30., ub = 30.),[m
           powerMax_ini = 30.,[m
           soh_ini = 1.) =[m
[31m-          new(Î·_E_H, lifetime, bounds, powerMax_ini)[m
[32m+[m[32m          new(eff_model, SoH_model, bounds, powerMax_ini)[m
 end[m
 [m
[32m+[m[32mmutable struct ConstEfficiencyHeater <: AbstractHeaterEffModel[m
[32m+[m
[32m+[m[32m  Î·_E_H::Float64[m
[32m+[m
[32m+[m[32m  ConstEfficiencyHeater(;Î·_E_H = 1.) = new(Î·_E_H)[m
[32m+[m[32mend[m
[32m+[m
[32m+[m
[32m+[m[32mmutable struct FixedLifetimeHeater <: AbstractHeaterAgingModel[m
[32m+[m
[32m+[m[32m  lifetime::Int64[m
[32m+[m
[32m+[m[32m  FixedLifetimeHeater(;lifetime = 25) = new(lifetime)[m
[32m+[m[32mend[m
[32m+[m
[32m+[m
 ### Preallocation[m
 function preallocate!(heater::Heater, nh::Int64, ny::Int64, ns::Int64)[m
   heater.powerMax = convert(SharedArray,zeros(ny+1, ns)) ; heater.powerMax[1,:] .= heater.powerMax_ini[m
[36m@@ -66,7 +90,7 @@[m [mfunction compute_operation_dynamics(heater::Heater, state::NamedTuple{(:powerMax[m
  # Power constraint and correction[m
  power_E = min(max(decision, -state.powerMax), 0.)[m
  # Power computation[m
[31m- power_H = - heater.Î·_E_H * power_E[m
[32m+[m[32m power_H = - heater.eff_model.Î·_E_H * power_E[m
  return power_E, power_H[m
 end[m
 [m
[1mdiff --git a/src/assets/liion/liion.jl b/src/assets/liion/liion.jl[m
[1mindex 19fa384..38b4efa 100644[m
[1m--- a/src/assets/liion/liion.jl[m
[1m+++ b/src/assets/liion/liion.jl[m
[36m@@ -5,7 +5,7 @@[m [mabstract type AbstractLiionEffModel end[m
 abstract type AbstractLiionAgingModel end[m
 [m
 """[m
[31m-LinearLiionEfficiency <: AbstractLiionEffModel[m
[32m+[m[32mFixedLiionEfficiency <: AbstractLiionEffModel[m
 [m
 A mutable struct that represents a Li-ion battery efficiency model for SoC computation.[m
 This model implement a fixed efficiency that can decrease linearly with battery aging.[m
[36m@@ -21,10 +21,10 @@[m [mThis model implement a fixed efficiency that can decrease linearly with battery[m
 [m
 ## Example [m
 ```julia[m
[31m-LinearLiionEfficiency()[m
[32m+[m[32mFixedLiionEfficiency()[m
 ```[m
 """[m
[31m-mutable struct LinearLiionEfficiency <: AbstractLiionEffModel[m
[32m+[m[32mmutable struct FixedLiionEfficiency <: AbstractLiionEffModel[m
 [m
 	Î·_ch::Float64 #Charging efficiency[m
 	Î·_dch::Float64 #Discharging efficiency[m
[36m@@ -35,7 +35,7 @@[m [mmutable struct LinearLiionEfficiency <: AbstractLiionEffModel[m
 	Î·_self::Float64 #Auto discarge factor[m
 	[m
 	[m
[31m-	LinearLiionEfficiency(;Î·_ch = 0.98,[m
[32m+[m	[32mFixedLiionEfficiency(;Î·_ch = 0.98,[m
 		Î·_dch = 0.98,[m
 		Î·_deg_coef = 0.2303,  # ref : Redondo Iglesias - Efficiency Degradation Model of Lithium-Ion Batteries for Electric Vehicles[m
 		couplage = (E = true, R = true),[m
[36m@@ -72,6 +72,9 @@[m [mPolynomialLiionEfficiency()[m
 """[m
 mutable struct PolynomialLiionEfficiency <: AbstractLiionEffModel[m
 [m
[32m+[m	[32mÎ·_ch::Float64 #Charging efficiency[m
[32m+[m	[32mÎ·_dch::Float64 #Discharging efficiency[m
[32m+[m
 	#Polynom coefficients for the computation of efficiency[m
 	a_Î·_ch::Float64[m
 	b_Î·_ch::Float64[m
[36m@@ -84,10 +87,13 @@[m [mmutable struct PolynomialLiionEfficiency <: AbstractLiionEffModel[m
 	couplage::NamedTuple{(:E, :R), Tuple{Bool, Bool}}  #a boolean tuple to tell wether or not the soh should influence the other parameters.[m
 	Î±_p_ch::Float64 #C_rate max[m
 	Î±_p_dch::Float64 #C_rate max[m
[31m-	Î·_self::Float64 #Auto discarge factor[m
[32m+[m	[32mÎ·_self::Float64 #Auto discarge factor[m[41m [m
 	[m
 	[m
[31m-	PolynomialLiionEfficiency(;a_Î·_ch=	0.0033,[m
[32m+[m	[32mPolynomialLiionEfficiency(;[m
[32m+[m	[32mÎ·_ch = 0.98,[m
[32m+[m	[32mÎ·_dch = 0.98,[m
[32m+[m	[32ma_Î·_ch=	0.0033,[m
 	b_Î·_ch = 0.0297, [m
 	c_Î·_ch = 0.99814,[m
 	a_Î·_dch = 0.002232, [m
[36m@@ -97,7 +103,7 @@[m [mmutable struct PolynomialLiionEfficiency <: AbstractLiionEffModel[m
 	couplage = (E = true, R = false),[m
 	Î±_p_ch = 1.5,[m
 	Î±_p_dch = 1.5,[m
[31m-	Î·_self = 0.0005) = new(a_Î·_ch, b_Î·_ch, c_Î·_ch, a_Î·_dch, b_Î·_dch, c_Î·_dch, Î·_deg_coef, couplage, Î±_p_ch, Î±_p_dch ,Î·_self)[m
[32m+[m	[32mÎ·_self = 0.0005) = new(Î·_ch, Î·_dch, a_Î·_ch, b_Î·_ch, c_Î·_ch, a_Î·_dch, b_Î·_dch, c_Î·_dch, Î·_deg_coef, couplage, Î±_p_ch, Î±_p_dch ,Î·_self)[m
 [m
 end[m
 [m
[36m@@ -110,15 +116,16 @@[m [mThis model calculates aging based on the cumulative energy throughput and additi[m
 [m
 # Parameters:[m
 - `calendar::Bool`: A boolean value to indicate whether to consider calendar aging (default: true)[m
[31m-- `nCycle::Int64`: An adjusted number of cycle to reach the SoH replacement threshold after nCycle_ini cycles (default: 2500)[m
[31m-- `nCycle_ini::Int64`: The total number of cycles achievable before reaching EOL(default: 2500)[m
[32m+[m[32m- `nCycle::Int64`: An adjusted number of cycle to reach the SoH replacement threshold after nCycle_ini cycles (default: 6000)[m
[32m+[m[32m- `nCycle_ini::Int64`: The total number of cycles achievable before reaching EOL(default: 6000).[m[41m [m
 - `Î”cal::Float64`: The calendar aging parameter (default: 1 - exp(-4.14e-10 * 3600))[m
 [m
 ## Example [m
 ```julia[m
 EnergyThroughputLiion(;nCycle_ini = Int(floor(fatigue_data.cycle[findfirst(fatigue_data.DoD .> (0.6))])))```[m
 [m
[31m-supposing that fatigue data is a dataframe with a cycle column and a DoD column[m
[32m+[m[32mThis set the feasible number of cycles corresponding to the number of 60% DoD cycles in the cycle-to-failure curve (named fatigue_data).[m
[32m+[m[32mSupposing that fatigue data is a dataframe with a cycle column and a DoD column[m
 """[m
 mutable struct EnergyThroughputLiion <: AbstractLiionAgingModel[m
 [m
[36m@@ -252,7 +259,7 @@[m [mA mutable struct representing a Li-ion battery model with state of charge (SoC)[m
 [m
 ## Parameters[m
 [m
[31m-- `SoC_model::AbstractLiionEffModel`: Model for state of charge computation.[m
[32m+[m[32m- `eff_model::AbstractLiionEffModel`: Model for state of charge computation.[m
 - `SoH_model::AbstractLiionAgingModel`: Model for aging computation.[m
 - `Î±_soc_min::Float64`: Minimum threshold of charge (normalized).[m
 - `Î±_soc_max::Float64`: Maximum threshold of charge (normalized).[m
[36m@@ -277,19 +284,20 @@[m [mA mutable struct representing a Li-ion battery model with state of charge (SoC)[m
 [m
 ## Example [m
 ```julia[m
[31m-Liion(SoC_model = PolynomialLiionEfficiency(), SoH_model = FixedLifetimeLiion())```[m
[32m+[m[32mLiion(eff_model = PolynomialLiionEfficiency(), SoH_model = FixedLifetimeLiion())```[m
 [m
 """[m
 mutable struct Liion <: AbstractLiion[m
 [m
 	[m
[31m-	SoC_model::AbstractLiionEffModel[m
[32m+[m	[32meff_model::AbstractLiionEffModel[m
 	SoH_model::AbstractLiionAgingModel[m
 [m
 	# Parameters[m
 	Î±_soc_min::Float64 #min threshold of charge (normalized)[m
 	Î±_soc_max::Float64 #max threshold of charge (normalized)[m
 [m
[32m+[m	[32mÎ·_self::Float64[m[41m [m
 	[m
 [m
 	bounds::NamedTuple{(:lb, :ub), Tuple{Float64, Float64}}[m
[36m@@ -312,16 +320,17 @@[m [mmutable struct Liion <: AbstractLiion[m
 	cost::AbstractArray{Float64,2}[m
 [m
 	# Inner constructor[m
[31m-	Liion(; SoC_model = LinearLiionEfficiency(),[m
[32m+[m	[32mLiion(; eff_model = FixedLiionEfficiency(),[m
 		SoH_model = FixedLifetimeLiion(),[m
 		Î±_soc_min = 0.2,[m
 		Î±_soc_max = 0.8,[m
[32m+[m		[32mÎ·_self = 0.0005,[m
 		bounds = (lb = 0., ub = 1000.),[m
 		SoH_threshold = 0.8,[m
 		couplage = (E = true, R = true),[m
 		Erated_ini = 1e-6,[m
 		soc_ini = 0.5,[m
[31m-		soh_ini = 1.) = new(SoC_model, SoH_model, Î±_soc_min, Î±_soc_max, bounds,[m
[32m+[m		[32msoh_ini = 1.) = new(eff_model, SoH_model, Î±_soc_min, Î±_soc_max, Î·_self, bounds,[m
 			SoH_threshold, couplage, Erated_ini, soc_ini, soh_ini) [m
 [m
 end[m
[36m@@ -363,7 +372,7 @@[m [mfunction preallocate!(liion::Liion, nh::Int64, ny::Int64, ns::Int64)[m
 		liion.SoH_model.Sum_fd = convert(SharedArray,zeros(ns))[m
    end[m
 [m
[31m-   liion.SoC_model.couplage = liion.couplage[m
[32m+[m[32m   liion.eff_model.couplage = liion.couplage[m
 [m
    return liion[m
 end[m
[36m@@ -399,7 +408,7 @@[m [mcompute_operation_dynamics!(h, y, s, liion, decision, Î”h)```[m
 """[m
 function compute_operation_dynamics!(h::Int64, y::Int64, s::Int64, liion::Liion, decision::Float64, Î”h::Int64)[m
 [m
[31m-	liion.soc[h+1,y,s], power_ch, power_dch = compute_operation_soc(liion, liion.SoC_model, h ,y ,s , decision, Î”h)[m
[32m+[m	[32mliion.soc[h+1,y,s], power_ch, power_dch = compute_operation_soc(liion, liion.eff_model, h ,y ,s , decision, Î”h)[m
 	[m
 	liion.carrier.power[h,y,s] = power_ch + power_dch [m
 [m
[36m@@ -415,12 +424,12 @@[m [mend[m
 """[m
 # compute_operation_soc[m
 [m
[31m-Compute and update the state of charge (SoC) dynamics based on the input decisions using the LinearLiionEfficiency model.[m
[32m+[m[32mCompute and update the state of charge (SoC) dynamics based on the input decisions using the FixedLiionEfficiency model.[m
 [m
 ## Arguments[m
 [m
 - `liion::Liion`: Li-ion battery model.[m
[31m-- `model::LinearLiionEfficiency`: Linear efficiency model.[m
[32m+[m[32m- `model::FixedLiionEfficiency`: Linear efficiency model.[m
 - `h::Int64`: Operation time step index.[m
 - `y::Int64`: Decision time step index.[m
 - `s::Int64`: Scenario index.[m
[36m@@ -429,7 +438,7 @@[m [mCompute and update the state of charge (SoC) dynamics based on the input decisio[m
 [m
 ## Description[m
 [m
[31m-This function computes and updates the state of charge (SoC) dynamics of the Liion battery model based on the input decisions and the LinearLiionEfficiency model. It considers efficiency, capacity coupling, and efficiency coupling according to the model parameters.[m
[32m+[m[32mThis function computes and updates the state of charge (SoC) dynamics of the Liion battery model based on the input decisions and the FixedLiionEfficiency model. It considers efficiency, capacity coupling, and efficiency coupling according to the model parameters.[m
 [m
 ## Example[m
 [m
[36m@@ -442,7 +451,13 @@[m [mdecision = 0.5[m
 compute_operation_soc(liion, model, h, y, s, decision, Î”h)[m
 ```[m
 """[m
[31m-function compute_operation_soc(liion::Liion, model::LinearLiionEfficiency, h::Int64,  y::Int64,  s::Int64, decision::Float64, Î”h::Int64)[m
[32m+[m[32mfunction compute_operation_soc(liion::Liion, model::FixedLiionEfficiency, h::Int64,  y::Int64,  s::Int64, decision::Float64, Î”h::Int64)[m
[32m+[m[41m	[m
[32m+[m[41m	[m
[32m+[m	[32mif liion.Erated[y,s] == 0[m
[32m+[m		[32mreturn 0,0,0[m
[32m+[m	[32mend[m[41m [m
[32m+[m[41m	[m
 	if decision >= 0 [m
 		Î·_ini = model.Î·_dch [m
 	else[m
[36m@@ -464,7 +479,11 @@[m [mfunction compute_operation_soc(liion::Liion, model::LinearLiionEfficiency, h::In[m
 	@inbounds power_dch = max(min(decision, model.Î±_p_dch * Erated, liion.soh[h,y,s] * liion.Erated[y,s] / Î”h, Î· * (liion.soc[h,y,s] - liion.Î±_soc_min) * Erated / Î”h), 0.)[m
 	@inbounds power_ch = min(max(decision, -model.Î±_p_ch * Erated, -liion.soh[h,y,s] * liion.Erated[y,s] / Î”h, (liion.soc[h,y,s] - liion.Î±_soc_max) * Erated / Î”h / Î·), 0.)[m
 [m
[31m-	return (1-model.Î·_self) * liion.soc[h,y,s] - (power_ch * Î· + power_dch / Î·) * Î”h / Erated, power_ch, power_dch[m
[32m+[m	[32mif Erated == 0[m
[32m+[m		[32mreturn 0[m
[32m+[m	[32melse[m
[32m+[m		[32mreturn (1-model.Î·_self) * liion.soc[h,y,s] - (power_ch * Î· + power_dch / Î·) * Î”h / Erated, power_ch, power_dch[m
[32m+[m	[32mend[m
 [m
 end[m
 [m
[36m@@ -527,7 +546,9 @@[m [mfunction compute_operation_soc(liion::Liion, model::PolynomialLiionEfficiency, h[m
 	power_dch = max(min(decision, model.Î±_p_dch * Erated, liion.soh[h,y,s] * liion.Erated[y,s] / Î”h, Î· * (liion.soc[h,y,s] - liion.Î±_soc_min) * Erated / Î”h), 0.)[m
 	power_ch = min(max(decision, -model.Î±_p_ch * Erated, -liion.soh[h,y,s] * liion.Erated[y,s] / Î”h, (liion.soc[h,y,s] - liion.Î±_soc_max) * Erated / Î”h / Î·), 0.)[m
 [m
[32m+[m
 	return (1-model.Î·_self) * liion.soc[h,y,s] - (power_ch * Î· + power_dch / Î·) * Î”h / Erated, power_ch, power_dch[m
[32m+[m[41m	[m
 [m
 end[m
 [m
[36m@@ -908,7 +929,7 @@[m [mcompute_operation_dynamics(liion, h, y, s, decision, Î”h)[m
 """[m
 function compute_operation_dynamics(liion::Liion, h::Int64, y::Int64, s::Int64, decision::Float64, Î”h::Int64)[m
 	 [m
[31m-	soc_next, power_ch, power_dch = compute_operation_soc(liion, liion.SoC_model, h, y, s, decision, Î”h)[m
[32m+[m	[32msoc_next, power_ch, power_dch = compute_operation_soc(liion, liion.eff_model, h, y, s, decision, Î”h)[m
 	[m
 	return power_dch + power_ch, soc_next[m
  end[m
[36m@@ -1263,9 +1284,9 @@[m [mend[m
 [m
 function toStringShort(liion::Liion)[m
 [m
[31m-	if liion.SoC_model isa LinearLiionEfficiency[m
[32m+[m	[32mif liion.eff_model isa FixedLiionEfficiency[m
 		efficiency = "x"[m
[31m-	elseif liion.SoC_model isa PolynomialLiionEfficiency[m
[32m+[m	[32melseif liion.eff_model isa PolynomialLiionEfficiency[m
 		efficiency = "xÂ²"[m
 	end[m
 [m
[1mdiff --git a/src/assets/microgrid.jl b/src/assets/microgrid.jl[m
[1mindex 00153d4..1131298 100644[m
[1m--- a/src/assets/microgrid.jl[m
[1m+++ b/src/assets/microgrid.jl[m
[36m@@ -116,16 +116,21 @@[m [mfunction preallocate!(mg::Microgrid, designer::AbstractDesigner)[m
     end[m
 [m
     #Different decision type for FuelCells and Electrolyzer[m
[31m-    for a in mg.converters[m
[31m-        if a isa FuelCell[m
[31m-            converter_dict[string(typeof(a))] = (surface = zeros(mg.parameters.ny, mg.parameters.ns), N_cell = zeros(mg.parameters.ny, mg.parameters.ns))[m
[31m-        elseif a isa Electrolyzer[m
[31m-            converter_dict[string(typeof(a))] = (surface = zeros(mg.parameters.ny, mg.parameters.ns), N_cell = zeros(mg.parameters.ny, mg.parameters.ns))[m
[31m-        elseif a isa Heater[m
[31m-            converter_dict[string(typeof(a))] = (power = zeros(mg.parameters.ny, mg.parameters.ns))[m
[32m+[m[32m    if designer isa MILP[m
[32m+[m[32m        for a in mg.converters[m
[32m+[m[32m            converter_dict[string(typeof(a))] = zeros(mg.parameters.ny, mg.parameters.ns)[m
[32m+[m[32m        end[m
[32m+[m[32m    else[m
[32m+[m[32m        for a in mg.converters[m
[32m+[m[32m            if a isa FuelCell[m
[32m+[m[32m                converter_dict[string(typeof(a))] = (surface = zeros(mg.parameters.ny, mg.parameters.ns), N_cell = zeros(mg.parameters.ny, mg.parameters.ns))[m
[32m+[m[32m            elseif a isa Electrolyzer[m
[32m+[m[32m                converter_dict[string(typeof(a))] = (surface = zeros(mg.parameters.ny, mg.parameters.ns), N_cell = zeros(mg.parameters.ny, mg.parameters.ns))[m
[32m+[m[32m            elseif a isa Heater[m
[32m+[m[32m                converter_dict[string(typeof(a))] = (power = zeros(mg.parameters.ny, mg.parameters.ns))[m
[32m+[m[32m            end[m
         end[m
     end[m
[31m-[m
     [m
     for a in mg.grids[m
         subscribed_power_dict[string(typeof(a.carrier))] = zeros(mg.parameters.ny, mg.parameters.ns)[m
[36m@@ -206,4 +211,15 @@[m [mfunction interpolation(serie_a::Vector{Float64}, serie_b::Vector{Float64}, a::Fl[m
     frac = (a - serie_a[id-1]) / (serie_a[id] - serie_a[id-1])[m
     b = frac * (serie_b[id] - serie_b[id-1]) + serie_b[id-1][m
     return b[m
[31m-end[m
\ No newline at end of file[m
[32m+[m[32mend[m
[32m+[m
[32m+[m
[32m+[m[32mfunction get_id_dict(mg::Microgrid)[m
[32m+[m
[32m+[m[32m    id_dict = Dict()[m
[32m+[m[32m    id_dict["storages"] = [typeof(a) for a in mg.storages][m
[32m+[m[32m    id_dict["generations"] = [typeof(a) for a in mg.generations][m
[32m+[m[32m    id_dict["converters"] = [typeof(a) for a in mg.converters][m
[32m+[m[32m    return id_dict[m[41m [m
[32m+[m[32mend[m
[41m+[m
[1mdiff --git a/src/assets/solar.jl b/src/assets/solar.jl[m
[1mindex 72925de..d8ad37d 100644[m
[1m--- a/src/assets/solar.jl[m
[1m+++ b/src/assets/solar.jl[m
[36m@@ -1,3 +1,5 @@[m
[32m+[m[32mabstract type AbstractPVAgingModel end[m
[32m+[m
 #=[m
     Sources modelling[m
  =#[m
[36m@@ -7,13 +9,13 @@[m
 A mutable struct representing a solar power generation source. It contains information about the lifetime, bounds, initial conditions, variables, and costs related to the solar generation.[m
 [m
 # Parameters[m
[31m--`lifetime::Int64 (default: 25)`: The lifetime of the solar power generation system.[m
[32m+[m[32m-`SoH_model::AbstractPVAgingModel (default: FixedLifetimeSolar(25))`: The aging model with a fixed lifetime of the solar power generation system.[m
 -`bounds::NamedTuple{(:lb, :ub), Tuple{Float64, Float64}} (default: (lb = 0., ub = 1000.))`: The lower and upper bounds of the solar power generation system.[m
 -`powerMax_ini::Float64 (default: 0.)`: The initial maximum power output of the solar power generation system.[m
 -`soh_ini::Float64 (default: 1.)`: The initial state of health of the solar power generation system.[m
 """[m
 mutable struct Solar <: AbstractGeneration[m
[31m-  lifetime::Int64[m
[32m+[m[32m  SoH_model::AbstractPVAgingModel[m
   bounds::NamedTuple{(:lb, :ub), Tuple{Float64, Float64}}[m
   # Initial conditions[m
   powerMax_ini::Float64[m
[36m@@ -25,7 +27,13 @@[m [mmutable struct Solar <: AbstractGeneration[m
   # Eco[m
   cost::AbstractArray{Float64,2}[m
   # Inner constructor[m
[31m-  Solar(;lifetime=25, bounds = (lb = 0., ub = 1000.), powerMax_ini = 0., soh_ini = 1.) = new(lifetime, bounds, powerMax_ini, soh_ini)[m
[32m+[m[32m  Solar(;SoH_model=FixedLifetimeSolar(), bounds = (lb = 0., ub = 1000.), powerMax_ini = 0., soh_ini = 1.) = new(SoH_model, bounds, powerMax_ini, soh_ini)[m
[32m+[m[32mend[m
[32m+[m
[32m+[m[32mmutable struct FixedLifetimeSolar <: AbstractPVAgingModel[m
[32m+[m[32m  lifetime::Int64[m
[32m+[m
[32m+[m[32m  FixedLifetimeSolar(;lifetime = 25) = new(lifetime)[m
 end[m
 [m
 """[m
[1mdiff --git a/src/assets/tes.jl b/src/assets/tes.jl[m
[1mindex e7f9d5f..b5e6cfe 100644[m
[1m--- a/src/assets/tes.jl[m
[1m+++ b/src/assets/tes.jl[m
[36m@@ -1,3 +1,9 @@[m
[32m+[m
[32m+[m[32mabstract type AbstractTESEffModel end[m
[32m+[m
[32m+[m[32mabstract type AbstractTESAgingModel end[m
[32m+[m
[32m+[m
 #=[m
     Thermal energy storage modelling[m
  =#[m
[36m@@ -9,12 +15,10 @@[m [mA mutable struct representing a thermal energy storage model with various parame[m
 # Parameters[m
 - `Î±_p_ch::Float64`: Maximum charging power factor[m
 - `Î±_p_dch::Float64`: Maximum discharging power factor[m
[31m-- `Î·_ch::Float64`: Charging efficiency[m
[31m-- `Î·_dch::Float64`: Discharging efficiency[m
[31m-- `Î·_self::Float64`: Self-discharge rate[m
[32m+[m[32m- `eff_model::AbstractTESEffModel`: Efficiency model[m[41m [m
 - `Î±_soc_min::Float64`: Minimum state of charge factor[m
 - `Î±_soc_max::Float64`: Maximum state of charge factor[m
[31m-- `lifetime::Int64`: Storage lifetime in years[m
[32m+[m[32m- `SoH_model::AbstractTESAgingModel`: Storage aging model (fixed lifetime in years)[m
 - `bounds::NamedTuple{(:lb, :ub), Tuple{Float64, Float64}}`: Lower and upper bounds of storage capacity[m
 - `Erated_ini::Float64`: Initial rated storage energy capacity[m
 - `soc_ini::Float64`: Initial state of charge[m
[36m@@ -28,12 +32,14 @@[m [mmutable struct ThermalStorage <: AbstractStorage[m
   # ParamÃ¨tres[m
   Î±_p_ch::Float64[m
   Î±_p_dch::Float64[m
[31m-  Î·_ch::Float64[m
[31m-  Î·_dch::Float64[m
[31m-  Î·_self::Float64[m
[32m+[m
[32m+[m[32m  eff_model::AbstractTESEffModel[m
[32m+[m
   Î±_soc_min::Float64[m
   Î±_soc_max::Float64[m
[31m-  lifetime::Int64[m
[32m+[m
[32m+[m[32m  SoH_model::AbstractTESAgingModel[m
[32m+[m
   bounds::NamedTuple{(:lb, :ub), Tuple{Float64, Float64}}[m
   # Initial conditions[m
   Erated_ini::Float64[m
[36m@@ -48,19 +54,40 @@[m [mmutable struct ThermalStorage <: AbstractStorage[m
   # Inner constructor[m
   ThermalStorage(; Î±_p_ch = 1.5,[m
        Î±_p_dch = 1.5,[m
[31m-       Î·_ch = 0.8,[m
[31m-       Î·_dch = 0.8,[m
[31m-       Î·_self = 0.008,[m
[32m+[m[32m       eff_model = FixedTESEfficiency(),[m
        Î±_soc_min = 0.,[m
        Î±_soc_max = 1.,[m
[31m-       lifetime = 25,[m
[32m+[m[32m       SoH_model = FixedTESLifetime(),[m
        bounds = (lb = 0., ub = 1000.),[m
        Erated_ini = 1e-6,[m
        soc_ini = 0.5,[m
        soh_ini = 1.) =[m
[31m-       new(Î±_p_ch, Î±_p_dch, Î·_ch, Î·_dch, Î·_self, Î±_soc_min, Î±_soc_max, lifetime, bounds, Erated_ini, soc_ini, soh_ini)[m
[32m+[m[32m       new(Î±_p_ch, Î±_p_dch, eff_model, Î±_soc_min, Î±_soc_max, SoH_model, bounds, Erated_ini, soc_ini, soh_ini)[m
[32m+[m[32mend[m
[32m+[m
[32m+[m[32mmutable struct FixedTESEfficiency <: AbstractTESEffModel[m
[32m+[m
[32m+[m[32m  Î·_ch::Float64[m
[32m+[m[32m  Î·_dch::Float64[m
[32m+[m[32m  Î·_self::Float64[m
[32m+[m
[32m+[m[32m  FixedTESEfficiency(;Î·_ch = 0.8,[m
[32m+[m		[32mÎ·_dch = 0.8,[m
[32m+[m		[32mÎ·_self = 0.008,[m
[32m+[m	[32m) = new(Î·_ch, Î·_dch, Î·_self)[m
 end[m
 [m
[32m+[m
[32m+[m[32mmutable struct FixedTESLifetime <: AbstractTESAgingModel[m
[32m+[m
[32m+[m	[32mlifetime::Int64[m
[32m+[m
[32m+[m	[32mFixedTESLifetime(;lifetime = 25) = new(lifetime)[m
[32m+[m[32mend[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
 """[m
  preallocate!(tes::ThermalStorage, nh::Int64, ny::Int64, ns::Int64)[m
 [m
[36m@@ -86,10 +113,10 @@[m [mend[m
 [m
 function compute_operation_dynamics(tes::ThermalStorage, state::NamedTuple{(:Erated, :soc), Tuple{Float64, Float64}}, decision::Float64, Î”h::Int64)[m
   # Control power constraint and correction[m
[31m-  power_dch = max(min(decision, tes.Î±_p_dch * state.Erated, tes.Î·_dch * (state.soc * (1. - tes.Î·_self * Î”h) - tes.Î±_soc_min) * state.Erated / Î”h), 0.)[m
[31m-  power_ch = min(max(decision, -tes.Î±_p_ch * state.Erated, (state.soc * (1. - tes.Î·_self * Î”h) - tes.Î±_soc_max) * state.Erated / Î”h / tes.Î·_ch), 0.)[m
[32m+[m[32m  power_dch = max(min(decision, tes.Î±_p_dch * state.Erated, tes.eff_model.Î·_dch * (state.soc * (1. - tes.eff_model.Î·_self * Î”h) - tes.Î±_soc_min) * state.Erated / Î”h), 0.)[m
[32m+[m[32m  power_ch = min(max(decision, -tes.Î±_p_ch * state.Erated, (state.soc * (1. - tes.eff_model.Î·_self * Î”h) - tes.Î±_soc_max) * state.Erated / Î”h / tes.eff_model.Î·_ch), 0.)[m
   # SoC dynamic[m
[31m-  soc_next = state.soc * (1. - tes.Î·_self * Î”h) - (power_ch * tes.Î·_ch + power_dch / tes.Î·_dch) * Î”h / state.Erated[m
[32m+[m[32m  soc_next = state.soc * (1. - tes.eff_model.Î·_self * Î”h) - (power_ch * tes.eff_model.Î·_ch + power_dch / tes.eff_model.Î·_dch) * Î”h / state.Erated[m
   return soc_next, power_dch + power_ch[m
 end[m
 [m
[1mdiff --git a/src/optimization/controller/anticipative.jl b/src/optimization/controller/anticipative.jl[m
[1mindex 8408bfd..b2cad2c 100644[m
[1m--- a/src/optimization/controller/anticipative.jl[m
[1m+++ b/src/optimization/controller/anticipative.jl[m
[36m@@ -39,7 +39,7 @@[m [mfunction build_model(mg::Microgrid, controller::Anticipative, Ï‰::Scenarios; rep[m
     add_investment_decisions!(m, mg.storages)[m
     add_investment_decisions!(m, mg.converters)[m
     # Fix their values[m
[31m-    fix_investment_decisions!(m, mg, controller.generations, controller.storages, controller.converters)[m
[32m+[m[32m    fix_investment_decisions!(m, mg, [x for x in values(controller.generations)], [x for x in values(controller.storages)], [x.surface * x.N_cell for x in values(controller.converters)])[m
     # Add decision variables[m
     add_operation_decisions!(m, mg.storages, nh, ns)[m
     add_operation_decisions!(m, mg.converters, nh, ns)[m
[36m@@ -159,6 +159,51 @@[m [mfunction build_model(mg::Microgrid, controller::Anticipative, Ï‰::MiniScenarios,[m
 end [m
 [m
 [m
[32m+[m[32mfunction build_model(mg::Microgrid, controller::Anticipative, Ï‰::MiniScenarios_my, s::Int64; time_limit = 3600)[m
[32m+[m
[32m+[m[32m    id_dict = get_id_dict(mg)[m[41m    [m
[32m+[m[32m    nh, ns = size(Ï‰.demands[1].power, 1) * size(Ï‰.demands[1].power, 2), size(Ï‰.demands[1].power, 3)[m
[32m+[m[32m    n_days = size(Ï‰.demands[1].power, 2) * 365[m
[32m+[m[32m    # Initialize[m
[32m+[m[32m    m = Model(controller.options.solver.Optimizer)[m
[32m+[m[32m    set_optimizer_attribute(m, "TimeLimit", time_limit)[m
[32m+[m
[32m+[m[32m    #set_optimizer_attribute(m,"CPX_PARAM_SCRIND", 0)[m
[32m+[m[32m    # Add investment variables[m
[32m+[m[32m    add_investment_decisions!(m, mg.generations)[m
[32m+[m[32m    add_investment_decisions!(m, mg.storages)[m
[32m+[m[32m    add_investment_decisions!(m, mg.converters)[m
[32m+[m[32m    # Fix their values[m
[32m+[m[32m    fix_investment_decisions!(m, mg, controller.generations, controller.storages, controller.converters, id_dict)[m
[32m+[m[32m    # Add decision variables[m
[32m+[m[32m    add_operation_decisions!(m, mg.storages, nh, ns)[m
[32m+[m[32m    add_operation_decisions!(m, mg.converters, nh, ns)[m
[32m+[m[32m    add_operation_decisions!(m, mg.grids, nh, ns)[m
[32m+[m[32m    # Add technical constraints[m
[32m+[m[32m    add_SoC_base!(m, mg.storages, ns, n_days)[m
[32m+[m
[32m+[m
[32m+[m[32m    add_technical_constraints_mini!(m, mg.storages, mg.parameters.Î”h, nh, ns)[m
[32m+[m[32m    add_technical_constraints!(m, mg.converters, nh, ns)[m
[32m+[m[32m    add_technical_constraints!(m, mg.grids, nh, ns)[m
[32m+[m[32m    # Add periodicity constraint[m
[32m+[m[32m    #add_periodicity_constraints!(m, mg.storages, ns)[m
[32m+[m[32m    # Add power balance constraints[m
[32m+[m[32m    add_power_balance_my!(m, mg, Ï‰, Electricity, nh, ns)[m
[32m+[m[32m    add_power_balance_my!(m, mg, Ï‰, Heat, nh, ns)[m
[32m+[m[32m    add_power_balance_my!(m, mg, Ï‰, Hydrogen, nh, ns)[m
[32m+[m
[32m+[m[32m    add_Continuity_SoC_constraints_mini!(m, mg.storages, nh, ns, Ï‰.sequence[:,s])[m
[32m+[m[32m    add_periodicity_constraints_mini!(m, mg.storages, ns, Ï‰.sequence[:,s])[m
[32m+[m
[32m+[m[32m    # Objective[m
[32m+[m[32m    opex = compute_opex_mini(m, mg, Ï‰, n_days, ns, Ï‰.sequence[:,s])[m
[32m+[m[32m    @objective(m, Min, opex[1])[m
[32m+[m
[32m+[m[32m    return m[m
[32m+[m[32mend[m[41m [m
[32m+[m
[32m+[m
 ### Offline[m
 function initialize_controller!(mg::Microgrid, controller::Anticipative, Ï‰::MiniScenarios)[m
     # Preallocate[m
[36m@@ -175,7 +220,7 @@[m [mfunction initialize_controller!(mg::Microgrid, controller::Anticipative, Ï‰::Min[m
         model = build_model(mg, controller, Ï‰, y, s)[m
       [m
         # Optimize[m
[31m-        optimize!(model)[m
[32m+[m[32m        JuMP.optimize!(model)[m
 [m
         push!(model_return, model)[m
         #println(objective_value(model))[m
[36m@@ -210,6 +255,61 @@[m [mfunction initialize_controller!(mg::Microgrid, controller::Anticipative, Ï‰::Min[m
 end[m
 [m
 [m
[32m+[m[32mfunction initialize_controller!(mg::Microgrid, controller::Anticipative, Ï‰::MiniScenarios_my; time_limit = 3600)[m
[32m+[m[32m    # Preallocate[m
[32m+[m
[32m+[m[32m    preallocate!(mg, controller)[m
[32m+[m
[32m+[m[32m    model_return = [][m
[32m+[m
[32m+[m[32m    for s in 1:mg.parameters.ns[m
[32m+[m[32m        # Scenario reduction[m
[32m+[m[41m       [m
[32m+[m
[32m+[m[32m        # Build model[m
[32m+[m[32m        model = build_model(mg, controller, Ï‰, s; time_limit)[m
[32m+[m[41m      [m
[32m+[m[32m        # Optimize[m
[32m+[m[32m        JuMP.optimize!(model)[m
[32m+[m
[32m+[m[32m        push!(model_return, model)[m
[32m+[m[32m        #println(objective_value(model))[m
[32m+[m[41m        [m
[32m+[m[32m        legend()[m
[32m+[m
[32m+[m[41m       [m
[32m+[m[41m      [m
[32m+[m[32m        for y in 1:mg.parameters.ny[m
[32m+[m
[32m+[m[32m            h_seq = [][m
[32m+[m[32m            for d in (1+(y-1)*365):(365 + (y-1)*365)[m
[32m+[m[32m                for h in 1:24[m
[32m+[m[32m                    h_seq = push!(h_seq, (Ï‰.sequence[d]-1) * 24 + h  )[m
[32m+[m[32m                end[m
[32m+[m[32m            end[m
[32m+[m
[32m+[m[32m                # Assign controller values[m
[32m+[m[32m            for k in 1:length(mg.storages)[m
[32m+[m[32m                controller.decisions.storages[k][:,y,s] .= value.(model[:p_dch][h_seq,1,k] .- model[:p_ch][h_seq,1,k])[m
[32m+[m[32m            end[m
[32m+[m[32m            for (k,a) in enumerate(mg.converters)[m
[32m+[m[32m                if a isa Heater[m
[32m+[m[32m                    controller.decisions.converters[k][:,y,s] .= .- value.(model[:p_c][h_seq,y,k])[m
[32m+[m[32m                elseif typeof(a) <: AbstractElectrolyzer[m
[32m+[m[32m                    controller.decisions.converters[k][:,y,s] .= .- value.(model[:p_c][h_seq,y,k])[m
[32m+[m[32m                elseif typeof(a) <: AbstractFuelCell[m
[32m+[m[32m                    controller.decisions.converters[k][:,y,s] .= value.(model[:p_c][h_seq,y,k])[m
[32m+[m[32m                end[m
[32m+[m[32m            end[m
[32m+[m[32m        end[m
[32m+[m[41m    [m
[32m+[m[41m       [m
[32m+[m[32m    end[m
[32m+[m
[32m+[m[32m    return controller, model_return[m
[32m+[m[32mend[m
[32m+[m
[32m+[m
 ### Offline[m
 function initialize_controller!(mg::Microgrid, controller::Anticipative, Ï‰::Scenarios)[m
     # Preallocate[m
[1mdiff --git a/src/optimization/controller/rb.jl b/src/optimization/controller/rb.jl[m
[1mindex ed4ba6c..5cabbca 100644[m
[1m--- a/src/optimization/controller/rb.jl[m
[1m+++ b/src/optimization/controller/rb.jl[m
[36m@@ -219,9 +219,9 @@[m [mfunction Ï€_6(h::Int64, y::Int64, s::Int64, mg::Microgrid, controller::RBC)[m
         u_heater_E, heater_H = compute_operation_dynamics(heater, (powerMax = heater.powerMax[y,s],), p_net_E - u_liion - u_elyz_E, Î”h)[m
     else[m
         # If the battery is getting low and the fuelcell is not activated due to minor demand we activate and use the excess to charge the battery with it[m
[31m-        if p_net_E - u_liion < fc.EffModel.powerMin[h,y,s] && p_net_E - u_liion != 0 #&& liion.soc[h,y,s] < 0.6 #&& h2tank.soc[h,y,s] > 0.3 [m
[31m-            p_adjust_E = fc.EffModel.powerMin[h,y,s][m
[31m-            u_liion = p_net_E - fc.EffModel.powerMin[h,y,s][m
[32m+[m[32m        if p_net_E - u_liion < fc.eff_model.powerMin[h,y,s] && p_net_E - u_liion != 0 #&& liion.soc[h,y,s] < 0.6 #&& h2tank.soc[h,y,s] > 0.3[m[41m [m
[32m+[m[32m            p_adjust_E = fc.eff_model.powerMin[h,y,s][m
[32m+[m[32m            u_liion = p_net_E - fc.eff_model.powerMin[h,y,s][m
         else[m
             p_adjust_E = p_net_E - u_liion[m
         end[m
[36m@@ -279,8 +279,8 @@[m [mfunction Ï€_7(h::Int64, y::Int64, s::Int64, mg::Microgrid, controller::RBC)[m
     if p_net_E < 0.[m
 [m
         # If there is a rest but its not enough to activate the elyz[m
[31m-        if p_net_E - u_liion < elyz.EffModel.powerMax[h,y,s] * elyz.min_part_load && p_net_E - u_liion > 0 && p_net_E >= elyz.EffModel.powerMin[h,y,s][m
[31m-            p_adjust_E = elyz.EffModel.powerMin[h,y,s][m
[32m+[m[32m        if p_net_E - u_liion < elyz.eff_model.powerMax[h,y,s] * elyz.min_part_load && p_net_E - u_liion > 0 && p_net_E >= elyz.eff_model.powerMin[h,y,s][m
[32m+[m[32m            p_adjust_E = elyz.eff_model.powerMin[h,y,s][m
             u_liion = p_net_E - p_adjust_E[m
         else[m
             p_adjust_E = p_net_E - u_liion[m
[36m@@ -299,8 +299,8 @@[m [mfunction Ï€_7(h::Int64, y::Int64, s::Int64, mg::Microgrid, controller::RBC)[m
        [m
     else[m
          # If there is a rest but its not enough to activate the fc[m
[31m-        if p_net_E - u_liion < fc.EffModel.powerMin[h,y,s] && p_net_E - u_liion > 0 && p_net_E >= fc.EffModel.powerMin[h,y,s][m
[31m-            p_adjust_E = fc.EffModel.powerMin[h,y,s][m
[32m+[m[32m        if p_net_E - u_liion < fc.eff_model.powerMin[h,y,s] && p_net_E - u_liion > 0 && p_net_E >= fc.eff_model.powerMin[h,y,s][m
[32m+[m[32m            p_adjust_E = fc.eff_model.powerMin[h,y,s][m
             u_liion = p_net_E - p_adjust_E[m
         else[m
             p_adjust_E = p_net_E - u_liion[m
[36m@@ -349,7 +349,7 @@[m [mfunction Ï€_8(h::Int64, y::Int64, s::Int64, mg::Microgrid, controller::RBC)[m
 [m
         if u_fc_E == 0[m
             # La pile ne peut pas prendre le reste alors on lui donne son min [m
[31m-            u_fc_E = fc.EffModel.powerMin[h,y,s] [m
[32m+[m[32m            u_fc_E = fc.eff_model.powerMin[h,y,s][m[41m [m
             u_liion = p_net_E - u_fc_E[m
         end[m
 [m
[36m@@ -365,7 +365,7 @@[m [mfunction Ï€_8(h::Int64, y::Int64, s::Int64, mg::Microgrid, controller::RBC)[m
 [m
         if u_elyz_E == 0[m
             # L'electrolyzer ne peut pas prendre le reste alors on lui donne son min [m
[31m-            min_elyz = ceil(elyz.EffModel.powerMax[h,y,s] * elyz.min_part_load, digits = 6)[m
[32m+[m[32m            min_elyz = ceil(elyz.eff_model.powerMax[h,y,s] * elyz.min_part_load, digits = 6)[m
 [m
             u_elyz_E, _, u_elyz_H2 = compute_operation_dynamics(elyz, h, y, s, -min_elyz, Î”h)[m
 [m
[1mdiff --git a/src/optimization/designer/metaheuristic/metaheuristic.jl b/src/optimization/designer/metaheuristic/metaheuristic.jl[m
[1mindex 08a7b89..1dfbafb 100644[m
[1m--- a/src/optimization/designer/metaheuristic/metaheuristic.jl[m
[1m+++ b/src/optimization/designer/metaheuristic/metaheuristic.jl[m
[36m@@ -626,7 +626,7 @@[m [mend[m
 function get_liion_model_config(decisions::NamedTuple{(:eff, :soh, :couplage), Tuple{Float64, Float64, Float64}})[m
 [m
     if Int(round(decisions.eff)) == 0 [m
[31m-        eff_model = LinearLiionEfficiency()[m
[32m+[m[32m        eff_model = FixedLiionEfficiency()[m
     elseif  Int(round(decisions.eff)) == 1[m
         eff_model = PolynomialLiionEfficiency()[m
     else[m
[36m@@ -655,7 +655,7 @@[m [mfunction get_liion_model_config(decisions::NamedTuple{(:eff, :soh, :couplage), T[m
 [m
 [m
     [m
[31m-    return Liion(SoC_model = eff_model, SoH_model = soh_model, couplage = coupl)[m
[32m+[m[32m    return Liion(eff_model = eff_model, SoH_model = soh_model, couplage = coupl)[m
 [m
 end[m
 [m
[36m@@ -692,7 +692,7 @@[m [mfunction get_electrolyer_model_config(decisions::NamedTuple{(:eff, :soh, :coupla[m
 [m
 [m
     [m
[31m-    return Electrolyzer(;V_J_ini = V_J_Elyz, EffModel = eff_model, SoH_model = soh_model, couplage = coupl)[m
[32m+[m[32m    return Electrolyzer(;V_J_ini = V_J_Elyz, eff_model = eff_model, SoH_model = soh_model, couplage = coupl)[m
 [m
 end[m
 [m
[36m@@ -716,9 +716,9 @@[m [mfunction get_fuelcell_model_config(decisions::NamedTuple{(:eff, :soh, :couplage)[m
     elseif Int(round(decisions.soh)) == 1[m
         soh_model =  FunctHoursAgingFuelCell(;deg_params=deg, J_base = 0.1)[m
     elseif Int(round(decisions.soh)) == 2[m
[31m-        soh_model =  PowerAgingFuelCell(;deg_params=deg, StartStop = false)[m
[32m+[m[32m        soh_model =  PowerAgingFuelCell(;deg_params=deg, start_stop = false)[m
     elseif Int(round(decisions.soh)) == 3[m
[31m-        soh_model =  PowerAgingFuelCell(;deg_params=deg, StartStop = true)[m
[32m+[m[32m        soh_model =  PowerAgingFuelCell(;deg_params=deg, start_stop = true)[m
     else[m
         println("problem with var Fuel Cell soh model : ", decisions.soh)[m
     end[m
[36m@@ -732,7 +732,7 @@[m [mfunction get_fuelcell_model_config(decisions::NamedTuple{(:eff, :soh, :couplage)[m
     end[m
 [m
     [m
[31m-    return FuelCell(;V_J_ini = V_J_FC, EffModel = eff_model, SoH_model = soh_model, couplage = coupl)[m
[32m+[m[32m    return FuelCell(;V_J_ini = V_J_FC, eff_model = eff_model, SoH_model = soh_model, couplage = coupl)[m
 [m
 end[m
 [m
[1mdiff --git a/src/optimization/designer/milp.jl b/src/optimization/designer/milp.jl[m
[1mindex ac1dac6..1b360e7 100644[m
[1m--- a/src/optimization/designer/milp.jl[m
[1m+++ b/src/optimization/designer/milp.jl[m
[36m@@ -36,6 +36,10 @@[m [mend[m
 [m
 ### Models[m
 function build_model(mg::Microgrid, designer::MILP, Ï‰::Scenarios, probabilities::Vector{Float64})[m
[32m+[m
[32m+[m[32m    #milp_inform(mg)[m
[32m+[m
[32m+[m
     # Sets[m
     nh, ns = size(Ï‰.demands[1].power, 1), size(Ï‰.demands[1].power, 3)[m
     # Initialize[m
[36m@@ -94,7 +98,7 @@[m [mfunction build_model_robust(mg::Microgrid, designer::MILP, Ï‰::Scenarios)[m
     add_technical_constraints!(m, mg.converters, nh, ns)[m
     add_technical_constraints!(m, mg.grids, nh, ns)[m
     # Add periodicity constraint[m
[31m-    #add_periodicity_constraints!(m, mg.storages, ns)[m
[32m+[m[32m    add_periodicity_constraints!(m, mg.storages, ns)[m
     # Add power balance constraints[m
     add_power_balance!(m, mg, Ï‰, Electricity, nh, ns)[m
     add_power_balance!(m, mg, Ï‰, Heat, nh, ns)[m
[36m@@ -108,6 +112,10 @@[m [mend[m
 [m
 ### Offline[m
 function initialize_designer!(mg::Microgrid, designer::MILP, Ï‰::Scenarios; multiyear::Bool=false, robust::Bool=false)[m
[32m+[m
[32m+[m[32m    # Asset model compatibility[m
[32m+[m[32m    milp_assert(mg)[m
[32m+[m
     # Preallocate[m
     preallocate!(mg, designer)[m
 [m
[36m@@ -129,7 +137,7 @@[m [mfunction initialize_designer!(mg::Microgrid, designer::MILP, Ï‰::Scenarios; mult[m
 [m
     else[m
         Ï‰_reduced = Ï‰[m
[31m-        probabilities = 1[m
[32m+[m[32m        probabilities = [1.][m
     end[m
     [m
     # Initialize model[m
[36m@@ -141,8 +149,7 @@[m [mfunction initialize_designer!(mg::Microgrid, designer::MILP, Ï‰::Scenarios; mult[m
         println("Multi_year")[m
         designer.model = build_model_multi_years(mg, designer, Ï‰_reduced, probabilities)[m
     else[m
[31m-        println("my")[m
[31m-        designer.model = build_model_my(mg, designer, Ï‰_reduced, probabilities)[m
[32m+[m[32m        designer.model = build_model(mg, designer, Ï‰_reduced, probabilities)[m
     end[m
 [m
 [m
[36m@@ -186,7 +193,7 @@[m [mfunction initialize_designer!(mg::Microgrid, designer::MILP, Ï‰::Scenarios; mult[m
         # Assign values[m
         for (k,a) in enumerate(mg.generations)[m
             if a isa Solar[m
[31m-                designer.decisions.generations["PV"][1,:] .= value(designer.model[:r_g][k])[m
[32m+[m[32m                designer.decisions.generations["Solar"][1,:] .= value(designer.model[:r_g][k])[m
             end[m
         end[m
         for (k,a) in enumerate(mg.storages)[m
[36m@@ -198,19 +205,14 @@[m [mfunction initialize_designer!(mg::Microgrid, designer::MILP, Ï‰::Scenarios; mult[m
         end[m
         for (k,a) in enumerate(mg.converters)[m
             if typeof(a) <: AbstractFuelCell[m
[31m-                key = "FuelCell"[m
[31m-                if a isa FuelCell_V_J || a isa FuelCell_lin[m
[31m-                    designer.decisions.converters[key].surface[1,:] .= value(designer.model[:r_c_surface][k])[m
[31m-                    designer.decisions.converters[key].N_cell[1,:] .= value(designer.model[:r_c_N_cell][k])[m
[31m-                else[m
[31m-                    designer.decisions.converters[key][1,:] .= value(designer.model[:r_c][k])[m
[31m-                end[m
[32m+[m[32m                # designer.decisions.converters[key].surface[1,:] .= value(designer.model[:r_c_surface][k])[m
[32m+[m[32m                # designer.decisions.converters[key].N_cell[1,:] .= value(designer.model[:r_c_N_cell][k])[m
[32m+[m[32m                designer.decisions.converters["FuelCell"][1,:] .= value(designer.model[:r_c][k])[m
             elseif a isa Electrolyzer[m
                 designer.decisions.converters["Electrolyzer"][1,:] .= value(designer.model[:r_c][k])[m
             elseif a isa Heater[m
                 designer.decisions.converters["Heater"][1,:] .= value(designer.model[:r_c][k])[m
             end[m
[31m-[m
         end[m
     end[m
 [m
[36m@@ -243,8 +245,8 @@[m [mfunction build_model_my(mg::Microgrid, designer::MILP, Ï‰::Scenarios, probabilit[m
     nh, ny, ns = size(Ï‰.demands[1].power, 1), size(Ï‰.demands[1].power, 2), size(Ï‰.demands[1].power, 3)[m
     # solver[m
     [m
[31m-    solver = designer.options.exact ? Alpine : Juniper[m
[31m-    nl_option_name = designer.options.exact ? "nlp_solver" : "nl_solver"[m
[32m+[m[32m    #solver = designer.options.exact ? Alpine : Juniper[m
[32m+[m[32m    #nl_option_name = designer.options.exact ? "nlp_solver" : "nl_solver"[m
     [m
     gurobi = optimizer_with_attributes(Gurobi.Optimizer, [m
                                          MOI.Silent() => true,[m
[36m@@ -255,7 +257,6 @@[m [mfunction build_model_my(mg::Microgrid, designer::MILP, Ï‰::Scenarios, probabilit[m
     mip_solver = designer.options.exact ? gurobi : highs[m
 [m
     optimizer = optimizer_with_attributes(solver.Optimizer,[m
[31m-    [m
                             nl_option_name => ipopt,[m
                             "mip_solver" => gurobi,#mip_solver[m
                             "time_limit" => 600)[m
[36m@@ -297,6 +298,10 @@[m [mend[m
 [m
 ### Offline[m
 function initialize_designer_my!(mg::Microgrid, designer::MILP, Ï‰::Scenarios; multiyear::Bool=false)[m
[32m+[m
[32m+[m[32m    # Asset model compatibility[m
[32m+[m[32m    milp_assert(mg)[m
[32m+[m
     # Preallocate[m
     preallocate!(mg, designer)[m
 [m
[36m@@ -399,3 +404,63 @@[m [mfunction initialize_designer_my!(mg::Microgrid, designer::MILP, Ï‰::Scenarios; m[m
 [m
     return designer[m
 end[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32m# Inform user about the change that are applied to the model in order to make it Milp compatible[m
[32m+[m[32mfunction milp_inform(mg::Microgrid)[m
[32m+[m
[32m+[m[32m    for sto in mg.storages[m
[32m+[m[32m        if sto isa AbstractLiion[m
[32m+[m[32m            if !(typeof(sto.eff_model) in [FixedLiionEfficiency])[m
[32m+[m[32m                println("Liion efficicency model is not MILP compatible fixed efficicency is used")[m
[32m+[m[32m            end[m
[32m+[m[32m            @assert(sto.couplage.E + sto.couplage.R == 0, "Liion couplage model is not MILP compatible")[m
[32m+[m[32m            @assert(typeof(sto.SoH_model) in [EnergyThroughputLiion, FixedLifetimeLiion], "Liion aging model $(string(typeof(sto.SoH_model))) is not MILP compatible")[m
[32m+[m[32m        end[m
[32m+[m[32m    end[m
[32m+[m
[32m+[m[32m    for conv in mg.converters[m
[32m+[m[32m        if conv isa AbstractFuelCell[m
[32m+[m[32m            @assert(typeof(conv.eff_model) in [FixedFuelCellEfficiency], "Liion efficicency model is not MILP compatible")[m
[32m+[m[32m            @assert(conv.couplage == 0, "Liion couplage model is not MILP compatible")[m
[32m+[m[32m            @assert(typeof(conv.SoH_model) in [FixedLifetimeFuelCell], "Liion aging model $(string(typeof(conv.SoH_model))) is not MILP compatible")[m
[32m+[m[32m        end[m
[32m+[m
[32m+[m[32m        if conv isa AbstractElectrolyzer[m
[32m+[m[32m            @assert(typeof(conv.eff_model) in [FixedElectrolyzerEfficiency], "Liion efficicency model is not MILP compatible")[m
[32m+[m[32m            @assert(conv.couplage == 0, "Liion couplage model is not MILP compatible")[m
[32m+[m[32m            @assert(typeof(conv.SoH_model) in [FixedLifetimeElectrolyzer], "Liion aging model $(string(typeof(conv.SoH_model))) is not MILP compatible")[m
[32m+[m[32m        end[m
[32m+[m[32m    end[m
[32m+[m
[32m+[m[32mend[m
[32m+[m
[32m+[m[32m# Test that the representation of the physical component are milp compatible.[m
[32m+[m[32mfunction milp_assert(mg::Microgrid)[m
[32m+[m
[32m+[m[32m    for sto in mg.storages[m
[32m+[m[32m        if sto isa AbstractLiion[m
[32m+[m[32m            @assert(typeof(sto.eff_model) in [FixedLiionEfficiency], "Liion efficicency model is not MILP compatible")[m
[32m+[m[32m            @assert(sto.couplage.E + sto.couplage.R == 0, "Liion couplage model is not MILP compatible")[m
[32m+[m[32m            @assert(typeof(sto.SoH_model) in [EnergyThroughputLiion, FixedLifetimeLiion], "Liion aging model $(string(typeof(sto.SoH_model))) is not MILP compatible")[m
[32m+[m[32m        end[m
[32m+[m[32m    end[m
[32m+[m
[32m+[m[32m    for conv in mg.converters[m
[32m+[m[32m        if conv isa AbstractFuelCell[m
[32m+[m[32m            @assert(typeof(conv.eff_model) in [FixedFuelCellEfficiency], "FuelCell efficicency model is not MILP compatible")[m
[32m+[m[32m            @assert(conv.couplage == 0, "FuelCell couplage model is not MILP compatible")[m
[32m+[m[32m            @assert(typeof(conv.SoH_model) in [FixedLifetimeFuelCell], "FuelCell aging model $(string(typeof(conv.SoH_model))) is not MILP compatible")[m
[32m+[m[32m        end[m
[32m+[m
[32m+[m[32m        if conv isa AbstractElectrolyzer[m
[32m+[m[32m            @assert(typeof(conv.eff_model) in [FixedElectrolyzerEfficiency], "Efficiency efficicency model is not MILP compatible")[m
[32m+[m[32m            @assert(conv.couplage == 0, "Electrolyzer couplage model is not MILP compatible")[m
[32m+[m[32m            @assert(typeof(conv.SoH_model) in [FixedLifetimeElectrolyzer], "Efficiency aging model $(string(typeof(conv.SoH_model))) is not MILP compatible")[m
[32m+[m[32m        end[m
[32m+[m[32m    end[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32mend[m
\ No newline at end of file[m
[1mdiff --git a/src/optimization/utils.jl b/src/optimization/utils.jl[m
[1mindex c64809d..f89b8b7 100644[m
[1m--- a/src/optimization/utils.jl[m
[1m+++ b/src/optimization/utils.jl[m
[36m@@ -86,21 +86,22 @@[m [mfunction add_investment_decisions!(m::Model, converters::Vector{AbstractConverte[m
 end[m
 [m
 [m
[31m-function fix_investment_decisions!(m::Model, generations::Vector{Float64}, storages::Vector{Float64}, converters::Vector{Float64}, mg::Microgrid)[m
[32m+[m[32mfunction fix_investment_decisions!(m::Model, mg::Microgrid, generations::Vector{Float64}, storages::Vector{Float64}, converters::Vector{Float64})[m
     # Generation[m
     if !isempty(mg.generations)[m
[31m-        fix.(m[:r_g], generations)[m
[32m+[m[32m        fix.(m[:r_g], [x for x in values(generations)])[m
     end[m
     # Storages[m
     if !isempty(mg.storages)[m
[31m-        fix.(m[:r_sto], storages)[m
[32m+[m[32m        fix.(m[:r_sto], [x for x in values(storages)])[m
     end[m
     # Converters[m
     if !isempty(mg.converters)[m
[31m-        fix.(m[:r_c], converters)[m
[32m+[m[32m        fix.(m[:r_c], [x for x in values(converters)])[m
     end[m
 end[m
 [m
[32m+[m
 function fix_investment_decisions!(m::Model, generations::Vector{Float64}, storages::Vector{Float64}, converters::Vector{Float64})[m
     # Generation[m
     if !isempty(generations)[m
[36m@@ -117,6 +118,24 @@[m [mfunction fix_investment_decisions!(m::Model, generations::Vector{Float64}, stora[m
 end[m
 [m
 [m
[32m+[m[32mfunction fix_investment_decisions!(m::Model, generations::Dict, storages::Dict, converters::Dict, id_dict::Dict)[m
[32m+[m[32m    # Generation[m
[32m+[m[32m    if !isempty(mg.generations)[m
[32m+[m[32m        fix.(m[:r_g], [generations[string(name)] for name in id_dict["generations"]])[m
[32m+[m[32m    end[m
[32m+[m[32m    # Storages[m
[32m+[m[32m    if !isempty(mg.storages)[m
[32m+[m[32m        fix.(m[:r_sto], [storages[string(name)] for name in id_dict["storages"]])[m
[32m+[m[32m    end[m
[32m+[m[32m    # Converters[m
[32m+[m[32m    if !isempty(mg.converters)[m
[32m+[m[32m        fix.(m[:r_c], [converters[string(name)] for name in id_dict["converters"]])[m
[32m+[m[32m    end[m
[32m+[m[32mend[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
 function add_operation_decisions!(m::Model, demands::Vector{AbstractDemand}, nh::Int64, ns::Int64)[m
     if !isempty(demands)[m
         na = length(demands)[m
[36m@@ -125,6 +144,16 @@[m [mfunction add_operation_decisions!(m::Model, demands::Vector{AbstractDemand}, nh:[m
         end)[m
     end[m
 end[m
[32m+[m
[32m+[m[32mfunction add_operation_decisions!(m::Model, demands::Vector{AbstractDemand}, nh::Int64, ny::Int64, ns::Int64)[m
[32m+[m[32m    if !isempty(demands)[m
[32m+[m[32m        na = length(demands)[m
[32m+[m[32m        @variables(m, begin[m
[32m+[m[32m        p_d[1:nh, 1:ns, 1:ny, 1:na][m
[32m+[m[32m        end)[m
[32m+[m[32m    end[m
[32m+[m[32mend[m
[32m+[m
 function add_operation_decisions!(m::Model, generations::Vector{AbstractGeneration}, nh::Int64, ns::Int64)[m
     if !isempty(generations)[m
         na = length(generations)[m
[36m@@ -133,6 +162,17 @@[m [mfunction add_operation_decisions!(m::Model, generations::Vector{AbstractGenerati[m
         end)[m
     end[m
 end[m
[32m+[m
[32m+[m
[32m+[m[32mfunction add_operation_decisions!(m::Model, generations::Vector{AbstractGeneration}, nh::Int64, ny::Int64, ns::Int64)[m
[32m+[m[32m    if !isempty(generations)[m
[32m+[m[32m        na = length(generations)[m
[32m+[m[32m        @variables(m, begin[m
[32m+[m[32m        p_g[1:nh, 1:ns, 1:ny, 1:na][m
[32m+[m[32m        end)[m
[32m+[m[32m    end[m
[32m+[m[32mend[m
[32m+[m
 function add_operation_decisions!(m::Model, storages::Vector{AbstractStorage}, nh::Int64, ns::Int64)[m
     if !isempty(storages)[m
         na = length(storages)[m
[36m@@ -143,6 +183,19 @@[m [mfunction add_operation_decisions!(m::Model, storages::Vector{AbstractStorage}, n[m
         end)[m
     end[m
 end[m
[32m+[m
[32m+[m
[32m+[m[32mfunction add_operation_decisions!(m::Model, storages::Vector{AbstractStorage}, nh::Int64, ny::Int64, ns::Int64)[m
[32m+[m[32m    if !isempty(storages)[m
[32m+[m[32m        na = length(storages)[m
[32m+[m[32m        @variables(m, begin[m
[32m+[m[32m        p_ch[1:nh, 1:ny, 1:ns, 1:na]   >= 0.[m
[32m+[m[32m        p_dch[1:nh, 1:ny, 1:ns, 1:na]  >= 0.[m
[32m+[m[32m        soc[1:nh+1, 1:ny, 1:ns, 1:na][m
[32m+[m[32m        end)[m
[32m+[m[32m    end[m
[32m+[m[32mend[m
[32m+[m
 function add_operation_decisions!(m::Model, converters::Vector{AbstractConverter}, nh::Int64, ns::Int64)[m
     if !isempty(converters)[m
         na = length(converters)[m
[36m@@ -305,13 +358,13 @@[m [mfunction add_technical_constraints!(m::Model, storages::Vector{AbstractStorage},[m
         na = length(storages)[m
         @constraints(m, begin[m
         # Power bounds[m
[31m-        [h in 1:nh, s in 1:ns, a in 1:na], m[:p_dch][h,s,a] <= storages[a].Î±_p_dch * m[:r_sto][a][m
[31m-        [h in 1:nh, s in 1:ns, a in 1:na], m[:p_ch][h,s,a]  <= storages[a].Î±_p_ch * m[:r_sto][a][m
[32m+[m[32m        #[h in 1:nh, s in 1:ns, a in 1:na], m[:p_dch][h,s,a] <= storages[a].Î±_p_dch * m[:r_sto][a][m
[32m+[m[32m        #[h in 1:nh, s in 1:ns, a in 1:na], m[:p_ch][h,s,a]  <= storages[a].Î±_p_ch * m[:r_sto][a][m
         # SoC bounds[m
         [h in 1:nh+1, s in 1:ns, a in 1:na], m[:soc][h,s,a] <= storages[a].Î±_soc_max * m[:r_sto][a][m
         [h in 1:nh+1, s in 1:ns, a in 1:na], m[:soc][h,s,a] >= storages[a].Î±_soc_min * m[:r_sto][a][m
         # State dynamics[m
[31m-        [h in 1:nh, s in 1:ns, a in 1:na], m[:soc][h+1,s,a] == m[:soc][h,s,a] * (1. - storages[a].Î·_self * Î”h) - (m[:p_dch][h,s,a] / storages[a].Î·_dch - m[:p_ch][h,s,a] * storages[a].Î·_ch) * Î”h[m
[32m+[m[32m        [h in 1:nh, s in 1:ns, a in 1:na], m[:soc][h+1,s,a] == m[:soc][h,s,a] * (1. - storages[a].eff_model.Î·_self * Î”h) - (m[:p_dch][h,s,a] / storages[a].eff_model.Î·_dch - m[:p_ch][h,s,a] * storages[a].eff_model.Î·_ch) * Î”h[m
         # Initial and final states[m
         soc_ini[s in 1:ns, a in 1:na], m[:soc][1,s,a] == storages[a].soc_ini * m[:r_sto][a][m
         end)[m
[36m@@ -350,7 +403,7 @@[m [mfunction add_technical_constraints!(m::Model, storages::Vector{AbstractStorage},[m
         [h in 1:nh+1, y in 1:ny, s in 1:ns, a in 1:na], m[:soc][h,y,s,a] <= storages[a].Î±_soc_max * m[:r_sto][y,a][m
         [h in 1:nh+1, y in 1:ny, s in 1:ns, a in 1:na], m[:soc][h,y,s,a] >= storages[a].Î±_soc_min * m[:r_sto][y,a][m
         # State dynamics[m
[31m-        [h in 1:nh, y in 1:ny, s in 1:ns, a in 1:na], m[:soc][h+1,y,s,a] == m[:soc][h,y,s,a] * (1. - storages[a].Î·_self * Î”h) - (m[:p_dch][h,y,s,a] / storages[a].Î·_dch - m[:p_ch][h,y,s,a] * storages[a].Î·_ch) * Î”h[m
[32m+[m[32m        [h in 1:nh, y in 1:ny, s in 1:ns, a in 1:na], m[:soc][h+1,y,s,a] == m[:soc][h,y,s,a] * (1. - storages[a].eff_model.Î·_self * Î”h) - (m[:p_dch][h,y,s,a] / storages[a].eff_model.Î·_dch - m[:p_ch][h,y,s,a] * storages[a].eff_model.Î·_ch) * Î”h[m
         # Initial and final states[m
         soc_ini[s in 1:ns, a in 1:na], m[:soc][1,1,s,a] == storages[a].soc_ini * m[:r_sto][a][m
 [m
[36m@@ -462,17 +515,17 @@[m [mfunction add_power_balance!(m::Model, mg::Microgrid, Ï‰::Scenarios, type::DataTy[m
             end[m
         elseif type == Heat[m
             if a isa Heater[m
[31m-                add_to_expression!.(balance, .- m[:p_c][:,:,k] * a.Î·_E_H)[m
[32m+[m[32m                add_to_expression!.(balance, .- m[:p_c][:,:,k] * a.eff_model.Î·_E_H)[m
             elseif a isa Electrolyzer[m
[31m-                add_to_expression!.(balance, .- m[:p_c][:,:,k] * a.Î·_E_H)[m
[32m+[m[32m                add_to_expression!.(balance, .- m[:p_c][:,:,k] * a.eff_model.Î·_E_H)[m
             elseif a isa FuelCell[m
[31m-                add_to_expression!.(balance, .- m[:p_c][:,:,k] * a.Î·_H2_H / a.Î·_H2_E)[m
[32m+[m[32m                add_to_expression!.(balance, .- m[:p_c][:,:,k] * a.eff_model.Î·_H2_H / a.eff_model.Î·_H2_E)[m
             end[m
         elseif type == Hydrogen[m
             if a isa Electrolyzer[m
[31m-                add_to_expression!.(balance, .- m[:p_c][:,:,k] * a.Î·_E_H2)[m
[32m+[m[32m                add_to_expression!.(balance, .- m[:p_c][:,:,k] * a.eff_model.Î·_E_H2)[m
             elseif a isa FuelCell[m
[31m-                add_to_expression!.(balance, m[:p_c][:,:,k] / a.Î·_H2_E)[m
[32m+[m[32m                add_to_expression!.(balance, m[:p_c][:,:,k] / a.eff_model.Î·_H2_E)[m
             end[m
         end[m
     end[m
[36m@@ -546,17 +599,17 @@[m [mfunction add_power_balance!(m::Model, mg::Microgrid, Ï‰::Scenarios, type::DataTy[m
                 end[m
             elseif type == Heat[m
                 if a isa Heater[m
[31m-                    add_to_expression!.(balance, .- m[:p_c][:,y,:,k] * a.Î·_E_H)[m
[32m+[m[32m                    add_to_expression!.(balance, .- m[:p_c][:,y,:,k] * a.eff_model.Î·_E_H)[m
                 elseif a isa Electrolyzer[m
[31m-                    add_to_expression!.(balance, .- m[:p_c][:,y,:,k] * a.Î·_E_H)[m
[32m+[m[32m                    add_to_expression!.(balance, .- m[:p_c][:,y,:,k] * a.eff_model.Î·_E_H)[m
                 elseif a isa FuelCell[m
[31m-                    add_to_expression!.(balance, .- m[:p_c][:,y,:,k] * a.Î·_H2_H / a.Î·_H2_E)[m
[32m+[m[32m                    add_to_expression!.(balance, .- m[:p_c][:,y,:,k] * a.eff_model.Î·_H2_H / a.eff_model.Î·_H2_E)[m
                 end[m
             elseif type == Hydrogen[m
                 if a isa Electrolyzer[m
[31m-                    add_to_expression!.(balance, .- m[:p_c][:,y,:,k] * a.Î·_E_H2)[m
[32m+[m[32m                    add_to_expression!.(balance, .- m[:p_c][:,y,:,k] * a.eff_model.Î·_E_H2)[m
                 elseif a isa FuelCell[m
[31m-                    add_to_expression!.(balance, m[:p_c][:,y,:,k] / a.Î·_H2_E)[m
[32m+[m[32m                    add_to_expression!.(balance, m[:p_c][:,y,:,k] / a.eff_model.Î·_H2_E)[m
                 end[m
             end[m
         end[m
[36m@@ -585,7 +638,7 @@[m [mfunction add_renewable_share!(m::Model, mg::Microgrid, Ï‰::Scenarios, probabilit[m
         if a.carrier isa Electricity[m
             total .= total .+ sum(Ï‰.demands[k].power[h,1,:] for h in 1:nh)[m
         elseif a.carrier isa Heat[m
[31m-            total .= total .+ sum(Ï‰.demands[k].power[h,1,:] for h in 1:nh) ./ mg.converters[isin(mg.converters, Heater)[2]].Î·_E_H[m
[32m+[m[32m            total .= total .+ sum(Ï‰.demands[k].power[h,1,:] for h in 1:nh) ./ mg.converters[isin(mg.converters, Heater)[2]].eff_model.Î·_E_H[m
         end[m
     end[m
     for (k,a) in enumerate(mg.grids)[m
[36m@@ -613,7 +666,7 @@[m [mfunction add_renewable_share!(m::Model, mg::Microgrid, Ï‰::Scenarios, probabilit[m
         if a.carrier isa Electricity[m
             total .= total .+ sum(Ï‰.demands[k].power[h,y,:] for h in 1:nh for y in 1:ny)[m
         elseif a.carrier isa Heat[m
[31m-            total .= total .+ sum(Ï‰.demands[k].power[h,y,:] for h in 1:nh for y in 1:ny) ./ mg.converters[isin(mg.converters, Heater)[2]].Î·_E_H[m
[32m+[m[32m            total .= total .+ sum(Ï‰.demands[k].power[h,y,:] for h in 1:nh for y in 1:ny) ./ mg.converters[isin(mg.converters, Heater)[2]].eff_model.Î·_E_H[m
         end[m
     end[m
     for (k,a) in enumerate(mg.grids)[m
[36m@@ -638,7 +691,7 @@[m [mend[m
 # Objective[m
 function add_design_objective!(m::Model, mg::Microgrid, Ï‰::Scenarios, probabilities::Vector{Float64}, risk::AbstractRiskMeasure, nh::Int64, ns::Int64)[m
     # CAPEX[m
[31m-    capex = compute_capex(m, mg, Ï‰)[m
[32m+[m[32m    capex = compute_annualized_capex(m, mg, Ï‰)[m
     # OPEX[m
     opex = compute_opex(m, mg, Ï‰, nh, ns)[m
     # Objective according to the CVaR[m
[36m@@ -652,19 +705,19 @@[m [mend[m
 [m
 [m
 # Capex[m
[31m-function compute_capex(m::Model, mg::Microgrid, Ï‰::Scenarios)[m
[32m+[m[32mfunction compute_annualized_capex(m::Model, mg::Microgrid, Ï‰::Scenarios)[m
     cost = AffExpr(0.)[m
     # Generations[m
     for (k,a) in enumerate(mg.generations)[m
[31m-        add_to_expression!(cost, Î“(mg.parameters.Ï„, a.lifetime) * Ï‰.generations[k].cost[1] * m[:r_g][k])[m
[32m+[m[32m        add_to_expression!(cost, Î“(mg.parameters.Ï„, a.SoH_model.lifetime) * Ï‰.generations[k].cost[1] * m[:r_g][k])[m
     end[m
     # Storages[m
     for (k,a) in enumerate(mg.storages)[m
[31m-        add_to_expression!(cost, Î“(mg.parameters.Ï„, a.lifetime) * Ï‰.storages[k].cost[1] * m[:r_sto][k])[m
[32m+[m[32m        add_to_expression!(cost, Î“(mg.parameters.Ï„, a.SoH_model.lifetime) * Ï‰.storages[k].cost[1] * m[:r_sto][k])[m
     end[m
     # Converters[m
     for (k,a) in enumerate(mg.converters)[m
[31m-        add_to_expression!(cost, Î“(mg.parameters.Ï„, a.lifetime) * Ï‰.converters[k].cost[1] * m[:r_c][k])[m
[32m+[m[32m        add_to_expression!(cost, Î“(mg.parameters.Ï„, a.SoH_model.lifetime) * Ï‰.converters[k].cost[1] * m[:r_c][k])[m
     end[m
     return cost[m
 end[m
[36m@@ -690,7 +743,6 @@[m [mfunction add_design_objective!(m::Model, mg::Microgrid, Ï‰::Scenarios, probabili[m
     salvage = compute_salvage(m, mg, Ï‰, ny, ns)[m
     # Objective according to the CVaR[m
 [m
[31m-[m
     @objective(m, Min,  capex + opex[1] - salvage[1])[m
 end[m
 [m
[36m@@ -704,13 +756,13 @@[m [mfunction compute_capex(m::Model, mg::Microgrid, Ï‰::Scenarios, ny::Int64)[m
             add_to_expression!(cost, Ï‰.generations[k].cost[y] * m[:r_g][k])[m
         end[m
         # Storages[m
[31m-        for (k,a) in enumerate(mg.storages)[m
[32m+[m[32m        for (k,a) in enumerate(mg.storages)[m[41m          [m
             add_to_expression!(cost, Ï‰.storages[k].cost[y] * m[:r_sto][y,k])[m
         end[m
         # Converters[m
[31m-        # for (k,a) in enumerate(mg.converters)[m
[31m-        #     add_to_expression!(cost, Ï‰.converters[k].cost[y] * m[:r_c][y,k])[m
[31m-        # end[m
[32m+[m[32m        for (k,a) in enumerate(mg.converters)[m
[32m+[m[32m            add_to_expression!(cost, Ï‰.converters[k].cost[y] * m[:r_c][y,k])[m
[32m+[m[32m        end[m
     end[m
     return cost[m
 end[m
[36m@@ -726,8 +778,24 @@[m [mend[m
 [m
 function compute_salvage(m::Model, mg::Microgrid, Ï‰::Scenarios, ny::Int64, ns::Int64)[m
     salvage =  AffExpr.(zeros(ns))[m
[31m-    K = Ï‰.storages[1].cost[ny] * m[:E_state][end][m
[31m-    add_to_expression!.(salvage, K * m[:soh][end,end,:])[m
[32m+[m
[32m+[m[32m    for (k,a) in enumerate(mg.storages)[m
[32m+[m[32m        if typeof(a) isa EnergyThroughputLiion[m
[32m+[m[32m            E_ex_tot = 2 * a.SoH_model.nCycle_ini * (a.Î±_soc_max - a.Î±_soc_min)[m[41m [m
[32m+[m[32m            cost_per_kwh_ex = Ï‰.storages[k].cost[y] / E_ex_tot[m
[32m+[m
[32m+[m[32m            salv = Ï‰.storages[k].cost[y] * m[:r_sto][y,k] + (sum(m[:p_ch][:,:,k]) * a.eff_model.Î·_ch - sum(m[:p_dch][:,:,k]) * a.eff_model.Î·_dch) * cost_per_kwh_ex[m
[32m+[m[32m            add_to_expression!(salvage, salv)[m
[32m+[m[32m        else[m
[32m+[m[41m        [m
[32m+[m[32m        end[m
[32m+[m[32m    end[m
[32m+[m
[32m+[m[32m    #TODO Salvage pour les autres cas que Energythroughput.[m
[32m+[m
[32m+[m[41m    [m
[32m+[m[32m    #K = Ï‰.storages[1].cost[ny] * m[:E_state][end][m
[32m+[m[32m    #add_to_expression!.(salvage, K * m[:soh][end,end,:])[m
 [m
     return salvage[m
 end[m
[1mdiff --git a/src/scenarios/scenarios.jl b/src/scenarios/scenarios.jl[m
[1mindex e4dd5c6..e735193 100644[m
[1m--- a/src/scenarios/scenarios.jl[m
[1m+++ b/src/scenarios/scenarios.jl[m
[36m@@ -49,16 +49,26 @@[m [mOnly some days will be selected. This method implement the work of Van Der Heijd[m
 - `days::Array{Int64,3}`: The matrix of the days used as representative indexed for each year and scenario  [day,year,sscenario][m
 - `sequence::Array{Int64,3}`: The matrix of the representative day used  to represent each day of the year indexed for each year and scenario  [day,year,scenario][m
 """[m
[31m-mutable struct MiniScenarios{T, O, I} <: AbstractScenarios[m
[31m-    demands::Vector{NamedTuple{(:t, :power),Tuple{T,O}}}[m
[31m-    generations::Vector{NamedTuple{(:t, :power, :cost), Tuple{T, O, I}}}[m
[31m-    storages::Vector{NamedTuple{(:cost,), Tuple{I}}}[m
[31m-    converters::Vector{NamedTuple{(:cost,), Tuple{I}}}[m
[31m-    grids::Vector{NamedTuple{(:cost_in, :cost_out, :cost_exceed), Tuple{O, O, I}}} [m
[32m+[m[32mmutable struct MiniScenarios <: AbstractScenarios[m
[32m+[m[32m    demands::Vector{NamedTuple}[m
[32m+[m[32m    generations::Vector{NamedTuple}[m
[32m+[m[32m    storages::Vector{NamedTuple}[m
[32m+[m[32m    converters::Vector{NamedTuple}[m
[32m+[m[32m    grids::Vector{NamedTuple}[m
     days::Array{Int64, 3}[m
     sequence::Array{Int64, 3}[m
     scenarios_reconstructed::Scenarios[m
 end[m
[32m+[m[32mmutable struct MiniScenarios_my <: AbstractScenarios[m
[32m+[m[32m    demands::Vector{NamedTuple}[m
[32m+[m[32m    generations::Vector{NamedTuple}[m
[32m+[m[32m    storages::Vector{NamedTuple}[m
[32m+[m[32m    converters::Vector{NamedTuple}[m
[32m+[m[32m    grids::Vector{NamedTuple}[m
[32m+[m[32m    days::Array{Int64, 2}[m
[32m+[m[32m    sequence::Array{Int64, 2}[m
[32m+[m[32m    scenarios_reconstructed::Scenarios[m
[32m+[m[32mend[m
 [m
 [m
 """[m
[36m@@ -280,36 +290,36 @@[m [mfunction MiniScenarios(mg::Microgrid, Ï‰::Scenarios, N_days::Int64; N_bins = 20,[m
                     end[m
                 end[m
 [m
[31m-            end[m
         end[m
[32m+[m[32m    end[m
 [m
         [m
[31m-        for (k, a) in enumerate(mg.demands)[m
[31m-            if a.carrier isa Electricity[m
[31m-                demands[k] = (t = Ï‰.demands[k].t[index_hour], power = Ï‰.demands[k].power[index_hour])[m
[31m-                demands_reconstructed[k] = (t = Ï‰.demands[k].t, power = loads_E)[m
[31m-            elseif a.carrier isa Heat[m
[31m-                demands[k] = (t = Ï‰.demands[k].t[index_hour], power = Ï‰.demands[k].power[index_hour])[m
[31m-                demands_reconstructed[k] = (t = Ï‰.demands[k].t, power = loads_H)[m
[31m-            end[m
[31m-        end    [m
[32m+[m[32m    for (k, a) in enumerate(mg.demands)[m
[32m+[m[32m        if a.carrier isa Electricity[m
[32m+[m[32m            demands[k] = (t = Ï‰.demands[k].t[index_hour], power = Ï‰.demands[k].power[index_hour])[m
[32m+[m[32m            demands_reconstructed[k] = (t = Ï‰.demands[k].t, power = loads_E)[m
[32m+[m[32m        elseif a.carrier isa Heat[m
[32m+[m[32m            demands[k] = (t = Ï‰.demands[k].t[index_hour], power = Ï‰.demands[k].power[index_hour])[m
[32m+[m[32m            demands_reconstructed[k] = (t = Ï‰.demands[k].t, power = loads_H)[m
[32m+[m[32m        end[m
[32m+[m[32m    end[m[41m    [m
 [m
[31m-        for (k, a) in enumerate(mg.generations)[m
[31m-            if a isa Solar[m
[31m-                generations[k] = (t = Ï‰.generations[k].t[index_hour], power = Ï‰.generations[k].power[index_hour], cost = Ï‰.generations[k].cost[y, s])[m
[31m-                generations_reconstructed[k] = (t = Ï‰.generations[k].t, power = PVs, cost = Ï‰.generations[k].cost[y, s])       [m
[31m-            end[m
[32m+[m[32m    for (k, a) in enumerate(mg.generations)[m
[32m+[m[32m        if a isa Solar[m
[32m+[m[32m            generations[k] = (t = Ï‰.generations[k].t[index_hour], power = Ï‰.generations[k].power[index_hour], cost = Ï‰.generations[k].cost[y, s])[m
[32m+[m[32m            generations_reconstructed[k] = (t = Ï‰.generations[k].t, power = PVs, cost = Ï‰.generations[k].cost[y, s])[m[41m       [m
         end[m
[32m+[m[32m    end[m
 [m
[31m-    [m
[31m-        # Grids[m
[31m-        for (k, a) in enumerate(mg.grids)[m
[31m-            if a.carrier isa Electricity[m
[31m-                grids[k] = (cost_in = Ï‰.grids[k].cost_in[index_hour], cost_out = Ï‰.grids[k].cost_out[index_hour], cost_exceed = zeros(length(y),length(s)) .+ 10) #TODO this price should come from the scenarios[m
[31m-            end[m
[32m+[m
[32m+[m[32m    # Grids[m
[32m+[m[32m    for (k, a) in enumerate(mg.grids)[m
[32m+[m[32m        if a.carrier isa Electricity[m
[32m+[m[32m            grids[k] = (cost_in = Ï‰.grids[k].cost_in[index_hour], cost_out = Ï‰.grids[k].cost_out[index_hour], cost_exceed = zeros(length(y),length(s)) .+ 10) #TODO this price should come from the scenarios[m
         end[m
[32m+[m[32m    end[m
 [m
[31m-        Scenarios_reconstructed = Scenarios(demands_reconstructed, generations_reconstructed,  Ï‰.storages, Ï‰.converters, Ï‰.grids)[m
[32m+[m[32m    Scenarios_reconstructed = Scenarios(demands_reconstructed, generations_reconstructed,  Ï‰.storages, Ï‰.converters, Ï‰.grids)[m
    [m
 [m
     return MiniScenarios(demands, generations,  Ï‰.storages, Ï‰.converters, grids, days, sequence, Scenarios_reconstructed)[m
[36m@@ -317,6 +327,203 @@[m [mfunction MiniScenarios(mg::Microgrid, Ï‰::Scenarios, N_days::Int64; N_bins = 20,[m
 end[m
 [m
 [m
[32m+[m[32m"""[m
[32m+[m[32m    function Scenarios(mg::Microgrid, d::Dict{})[m
[32m+[m
[32m+[m[32mConstructor function for creating a new `Scenarios` instance based on a given `Microgrid` and a `Dict` containing scenario data.[m
[32m+[m
[32m+[m[32m# Arguments[m
[32m+[m[32m- `mg::Microgrid`: A Microgrid instance.[m
[32m+[m[32m- `d::Dict{}`: A dictionary containing scenario data.[m
[32m+[m
[32m+[m[32m# Returns[m
[32m+[m[32m- `Scenarios`: A Scenarios instance with the specified data.[m
[32m+[m
[32m+[m[32m## Example[m
[32m+[m
[32m+[m[32m```julia[m
[32m+[m[32mmicrogrid = ...[m
[32m+[m[32mscenario_data = ...[m
[32m+[m
[32m+[m[32mscenarios = Scenarios(microgrid, scenario_data)[m
[32m+[m[32m```[m
[32m+[m[32m"""[m
[32m+[m[32mfunction MiniScenarios(mg::Microgrid, Ï‰::Scenarios, N_days::Int64, y; N_bins = 20, times_limit = [100,200], display_res = true)[m
[32m+[m[32m    h, s = 1:mg.parameters.nh, 1:mg.parameters.ns[m
[32m+[m[32m    T, O, I = Array{DateTime,3}, Array{Float64, 3}, Array{Float64, 2}, Array{Int64, 3}[m
[32m+[m
[32m+[m
[32m+[m[32m    demands = Vector{NamedTuple}(undef, length(mg.demands))[m
[32m+[m[32m    generations = Vector{NamedTuple}(undef, length(mg.generations))[m
[32m+[m[32m    storages = Vector{NamedTuple}(undef, length(mg.storages))[m
[32m+[m[32m    converters = Vector{NamedTuple}(undef, length(mg.converters))[m
[32m+[m[32m    grids = Vector{NamedTuple}(undef, length(mg.grids))[m
[32m+[m
[32m+[m[32m    demands_reconstructed = Vector{NamedTuple}(undef, length(mg.demands))[m
[32m+[m[32m    generations_reconstructed = Vector{NamedTuple}(undef, length(mg.generations))[m
[32m+[m[32m    storages_reconstructed = Vector{NamedTuple}(undef, length(mg.storages))[m
[32m+[m[32m    converters_reconstructed = Vector{NamedTuple}(undef, length(mg.converters))[m
[32m+[m[32m    grids_reconstructed = Vector{NamedTuple}(undef, length(mg.grids))[m
[32m+[m
[32m+[m[32m    days = Int.(zeros(N_days, mg.parameters.ns))[m
[32m+[m[32m    sequence = Int.(zeros(365*y, mg.parameters.ns))[m
[32m+[m
[32m+[m[32m    index_hour = Int.(zeros(24*N_days, mg.parameters.ns))[m
[32m+[m
[32m+[m[32m    data = [][m
[32m+[m[32m    constructed_res = zeros(length(h) * y, length(s))[m
[32m+[m[32m    loads_E = zeros(length(h) * y, length(s))[m
[32m+[m[32m    loads_H = zeros(length(h) * y, length(s))[m
[32m+[m[32m    PVs = zeros(length(h) * y, length(s))[m
[32m+[m
[32m+[m[32m    for s_id in s[m
[32m+[m[41m       [m
[32m+[m[32m        # Van det heijde[m
[32m+[m[32m        # 1 : Selecting days by fitting the duration curve[m[41m    [m
[32m+[m[32m        # From Selecting Representative Days for Capturing the Implications of Integrating Intermittent Renewables in Generation Expansion Planning Problems by Kris poncelet et al.[m
[32m+[m
[32m+[m[32m            days_selected, weights = get_days_multi_year(N_days, N_bins, Ï‰, y, s_id; time_limit = times_limit[1])[m
[32m+[m
[32m+[m[32m            days[:, s_id] = days_selected[m
[32m+[m[32m        #######################[m
[32m+[m[32m        ### Recompose data to plot and compare the load curves ######[m
[32m+[m[32m        #####################[m
[32m+[m
[32m+[m[32m                if display_res[m
[32m+[m[41m                  [m
[32m+[m[32m                    data_reshape = [][m
[32m+[m
[32m+[m[32m                    for demand in Ï‰.demands[m
[32m+[m[32m                        push!(data_reshape, reshape(vec(demand.power[:, 1:y, s]),(24,365*y)))[m
[32m+[m[32m                    end[m
[32m+[m[32m                    for generation in Ï‰.generations[m
[32m+[m[32m                        push!(data_reshape, reshape(vec(generation.power[:, 1:y, s]),(24,365*y)))[m
[32m+[m[32m                    end[m
[32m+[m[32m                    # push!(data_reshape, reshape(vec(Ï‰.demands[1].power[:, : , s_id]), (24,365*y)))[m
[32m+[m[32m                    # push!(data_reshape, reshape(vec(Ï‰.demands[2].power[:, :, s_id]), (24,365*y)))[m
[32m+[m[32m                    # push!(data_reshape, reshape(vec(Ï‰.generations[1].power[:, :, s_id]), (24,365*y)))[m
[32m+[m
[32m+[m[32m                    data = [][m
[32m+[m[32m                    labels = [][m
[32m+[m[32m                    units = [][m
[32m+[m
[32m+[m[32m                    for (k,demand) in enumerate(Ï‰.demands)[m
[32m+[m[32m                        push!(data, vec(demand.power[:, 1:y, s]))[m
[32m+[m[32m                        push!(labels, string("demand : ", typeof(mg.demands[k].carrier)))[m
[32m+[m[32m                        push!(units, string( "Power [kWh]"))[m
[32m+[m
[32m+[m[32m                    end[m
[32m+[m[32m                    for (k,generation) in enumerate(Ï‰.generations)[m
[32m+[m[32m                        push!(data, vec(generation.power[:, 1:y, s]))[m
[32m+[m[32m                        push!(labels, string("generation : ", typeof(mg.generations[k])))[m
[32m+[m[32m                        push!(units, string("Power [p.u]"))[m
[32m+[m[32m                    end[m
[32m+[m[32m                    # push!(data, vec(Ï‰.demands[1].power[:, :, s_id]))[m
[32m+[m[32m                    # push!(data, vec(Ï‰.demands[2].power[:, :, s_id]))[m
[32m+[m[32m                    # push!(data, vec(Ï‰.generations[1].power[:, :, s_id]))[m
[32m+[m[41m                    [m
[32m+[m[32m                    fig, axs = PyPlot.subplots(length(data)+1,1, figsize=(9, 3), sharey=false, constrained_layout = true)[m
[32m+[m[32m                    fig.set_size_inches( 1920 / fig.dpi, 1080/ fig.dpi)[m
[32m+[m[41m                [m
[32m+[m[32m                    for j in 1:length(data)[m
[32m+[m
[32m+[m[32m                        val = [][m
[32m+[m[32m                        for i in 1:length(days_selected)[m
[32m+[m[32m                            val = vcat(val, repeat(data_reshape[j][:,days_selected[i]], outer = weights[i]))[m
[32m+[m[32m                        end[m
[32m+[m[41m                    [m
[32m+[m[32m                        RP_DC = reverse(sort(val))[m
[32m+[m[41m                    [m
[32m+[m[32m                        OG_DC = reverse(sort(data[j]))[m
[32m+[m[41m                        [m
[32m+[m[41m                                [m
[32m+[m[32m                        axs[j].plot(RP_DC, label="Bins = $N_bins, Days = $N_days")[m
[32m+[m[32m                        axs[j].plot(OG_DC, label = "OG")[m
[32m+[m
[32m+[m[32m                        axs[j].set_title(string("Duration curve : ", labels[j]))[m
[32m+[m[32m                        axs[j].set_xlabel("Hours",fontsize = 14)[m
[32m+[m[32m                        axs[j].set_ylabel(units[j], fontsize = 16)[m
[32m+[m[41m                        [m
[32m+[m[41m                        [m
[32m+[m[32m                    end[m
[32m+[m
[32m+[m[32m                    color = Seaborn.color_palette("viridis", as_cmap =true)[m
[32m+[m[32m                    #color_names = collect(keys(matplotlib.colors.XKCD_COLORS))[1:end][m
[32m+[m[32m                    count_start = 1[m
[32m+[m[32m                    id_x = [][m
[32m+[m[32m                    for i in 1:length(weights)[m
[32m+[m[32m                        push!(id_x, (count_start,weights[i]))[m
[32m+[m[32m                        axs[length(data)+1].annotate(days_selected[i], (count_start -0.5 + weights[i]/2, 0.5))[m
[32m+[m[32m                        count_start += weights[i][m
[32m+[m[32m                    end[m
[32m+[m[32m                    axs[length(data)+1].broken_barh(id_x , (0, 1),[m
[32m+[m[32m                            facecolors=color.(days_selected./(365*y))) #color_names[days_selected])[m
[32m+[m
[32m+[m[41m                    [m
[32m+[m[32m                    tight_layout()[m
[32m+[m
[32m+[m[32m                    legend()[m
[32m+[m[32m                end[m
[32m+[m[41m                [m
[32m+[m
[32m+[m[32m        # 2 : Assign real days to representative days to reconstruct the temporality[m[41m    [m
[32m+[m[32m        # From Representative days selection for district energy system optimisation: a solar district heating system with seasonal storage[m
[32m+[m[32m        # Contruct a MIQP model to fit the original data curves by constructing a new one with representative days[m
[32m+[m
[32m+[m[32m                constructed_res, sequence_repr = get_profil_and_sequence_multi_year(days_selected, weights, Ï‰, y, s_id, mg; display_res = display_res, time_limit = times_limit[2])[m
[32m+[m[41m                    [m
[32m+[m
[32m+[m[32m                #loads_E[:,:,s_id] = load_E[m
[32m+[m[32m                #loads_H[:,:,s_id] = load_H[m
[32m+[m
[32m+[m[32m               # PVs[:,:,s_id] = gen[m
[32m+[m
[32m+[m
[32m+[m[32m                sequence[:, :, s_id] = sequence_repr[m
[32m+[m
[32m+[m[41m                [m
[32m+[m[32m                for i in 1:N_days[m
[32m+[m[32m                    for j in 1:24[m
[32m+[m[32m                        index_hour[(i-1)*24+j, s_id] = (days_selected[i]-1) * 24 + j[m
[32m+[m[32m                    end[m
[32m+[m[32m                end[m
[32m+[m
[32m+[m[32m    end[m
[32m+[m
[32m+[m[41m        [m
[32m+[m[32m    for (k, a) in enumerate(mg.demands)[m
[32m+[m[32m        if a.carrier isa Electricity[m
[32m+[m[32m            demands[k] = (t = Ï‰.demands[k].t[index_hour], power = Ï‰.demands[k].power[index_hour])[m
[32m+[m[32m            demands_reconstructed[k] = (t = Ï‰.demands[k].t, power = constructed_res[k])[m
[32m+[m[32m        elseif a.carrier isa Heat[m
[32m+[m[32m            demands[k] = (t = Ï‰.demands[k].t[index_hour], power = Ï‰.demands[k].power[index_hour])[m
[32m+[m[32m            demands_reconstructed[k] = (t = Ï‰.demands[k].t, power = loads_H)[m
[32m+[m[32m        end[m
[32m+[m[32m    end[m[41m    [m
[32m+[m
[32m+[m[32m    for (k, a) in enumerate(mg.generations)[m
[32m+[m[32m        if a isa Solar[m
[32m+[m[32m            generations[k] = (t = Ï‰.generations[k].t[index_hour], power = Ï‰.generations[k].power[index_hour], cost = Ï‰.generations[k].cost)[m
[32m+[m[32m            generations_reconstructed[k] = (t = Ï‰.generations[k].t, power = constructed_res[k+length(mg.demands)], cost = Ï‰.generations[k].cost)[m[41m       [m
[32m+[m[32m        end[m
[32m+[m[32m    end[m
[32m+[m
[32m+[m
[32m+[m[32m    # Grids[m
[32m+[m[32m    for (k, a) in enumerate(mg.grids)[m
[32m+[m[32m        if a.carrier isa Electricity[m
[32m+[m[32m            grids[k] = (cost_in = Ï‰.grids[k].cost_in[index_hour], cost_out = Ï‰.grids[k].cost_out[index_hour], cost_exceed = zeros(length(y),length(s)) .+ 10) #TODO this price should come from the scenarios[m
[32m+[m[32m        end[m
[32m+[m[32m    end[m
[32m+[m
[32m+[m[32m    Scenarios_reconstructed = Scenarios(demands_reconstructed, generations_reconstructed,  Ï‰.storages, Ï‰.converters, Ï‰.grids)[m
[32m+[m[41m   [m
[32m+[m
[32m+[m[32m    return MiniScenarios_my(demands, generations,  Ï‰.storages, Ï‰.converters, grids, days, sequence, Scenarios_reconstructed)[m
[32m+[m
[32m+[m[32mend[m
[32m+[m
[32m+[m
 [m
 [m
 [m
[1mdiff --git a/src/scenarios/utils.jl b/src/scenarios/utils.jl[m
[1mindex f0fc93e..66aa412 100644[m
[1m--- a/src/scenarios/utils.jl[m
[1m+++ b/src/scenarios/utils.jl[m
[36m@@ -139,7 +139,7 @@[m [mfunction get_profil_and_sequence(days::Vector{Int64}, weights::Vector{Int64}, Ï‰[m
     @objective(m2, Min, sum((error[data_id, d, h]^2) .* weight_energy for data_id in 1:length(data_reshape) for d in 1:365 for  h in 1:24))[m
 [m
 [m
[31m-    optimize!(m2)[m
[32m+[m[32m    JuMP.optimize!(m2)[m
 [m
     [m
     sequence = [findfirst( x -> x > 0, Int64.(round.(value.(m2[:assignments])[i,:]))) for i in 1:365][m
[36m@@ -212,14 +212,18 @@[m [mend[m
 [m
 [m
 [m
[32m+[m
 function get_days(N_days, N_bins, Ï‰, y ,s; time_limit = 0)[m
 [m
 [m
     data = [][m
 [m
[31m-    push!(data, Ï‰.demands[1].power[:, y, s])[m
[31m-    push!(data, Ï‰.demands[2].power[:, y, s])[m
[31m-    push!(data, Ï‰.generations[1].power[:, y, s])[m
[32m+[m[32m    for demand in Ï‰.demands[m
[32m+[m[32m        push!(data, demand.power[:, y, s])[m
[32m+[m[32m    end[m
[32m+[m[32m    for generation in Ï‰.generations[m
[32m+[m[32m        push!(data, generation.power[:, y, s])[m
[32m+[m[32m    end[m
 [m
     N_metric = length(data) # Elec curve, Solar curve[m
 [m
[36m@@ -284,7 +288,96 @@[m [mfunction get_days(N_days, N_bins, Ï‰, y ,s; time_limit = 0)[m
 [m
     @objective(m, Min, sum(errors[metric, b] for metric in 1:N_metric for b in 1:N_bins))[m
 [m
[31m-    optimize!(m)[m
[32m+[m[32m    JuMP.optimize!(m)[m
[32m+[m
[32m+[m[32m    days_id = findall( x -> x > 0, Int64.(round.(value.(m[:day]))))[m
[32m+[m[32m    return days_id, Int64.(round.(value.(m[:weight_day])))[days_id][m
[32m+[m[41m            [m
[32m+[m[32mend[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32mfunction get_days_multi_year(N_days, N_bins, Ï‰, y, s; time_limit = 0)[m
[32m+[m
[32m+[m
[32m+[m[32m    data = [][m
[32m+[m
[32m+[m[32m    for demand in Ï‰.demands[m
[32m+[m[32m        push!(data, vec(demand.power[:, 1:y, s]))[m
[32m+[m[32m    end[m
[32m+[m[32m    for generation in Ï‰.generations[m
[32m+[m[32m        push!(data, vec(generation.power[:, 1:y, s]))[m
[32m+[m[32m    end[m
[32m+[m
[32m+[m[32m    N_metric = length(data) # Elec curve, Solar curve[m
[32m+[m
[32m+[m[41m    [m
[32m+[m[32m    # #######################[m
[32m+[m[32m    ### Define values of L and A (see Poncelet et al. P.5 second column) ######[m
[32m+[m[32m    #####################[m
[32m+[m[32m    L = zeros(N_metric, N_bins)[m
[32m+[m[32m    A = zeros(N_metric, N_bins, 365 * y)[m
[32m+[m
[32m+[m[32m    for i in 1:N_metric[m
[32m+[m[32m        min_data = minimum(data[i])[m
[32m+[m[32m        max_data = maximum(data[i])[m
[32m+[m
[32m+[m[32m        bin_step = (max_data-min_data)/N_bins[m
[32m+[m
[32m+[m[32m        OG_DC = reverse(sort(data[i]))[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32m        for j in 1:N_bins[m
[32m+[m[32m            #PyPlot.scatter(findfirst(OG_DC .<  ((j-1)*bin_step)+min_data),((j-1)*bin_step)+min_data)[m
[32m+[m
[32m+[m[32m            L[i,j] = sum(OG_DC .>= ((j-1)*bin_step)+min_data) / (8760 * y)[m
[32m+[m
[32m+[m[32m            for k in 1:(365 * y)[m
[32m+[m[32m                A[i,j,k] = sum(data[i][((k-1)*24+1):(k*24)] .>= ((j-1)*bin_step)+min_data) / 24[m
[32m+[m[32m            end[m
[32m+[m[32m        end[m
[32m+[m[32m    end[m
[32m+[m
[32m+[m[41m    [m
[32m+[m
[32m+[m
[32m+[m[32m#######################[m
[32m+[m[32m### Optimize to find the best set of days and their weights ######[m
[32m+[m[32m#####################[m
[32m+[m
[32m+[m[32m    n_real_days = 365 * y[m[41m [m
[32m+[m[32m    @assert(n_real_days == length(data[1])/24)[m
[32m+[m
[32m+[m
[32m+[m[32m    m = Model(Gurobi.Optimizer)[m
[32m+[m
[32m+[m[32m    if time_limit > 0[m
[32m+[m[32m        set_optimizer_attribute(m, "TimeLimit", time_limit)[m
[32m+[m[32m    end[m
[32m+[m
[32m+[m
[32m+[m[32m    @variable(m, weight_day[1:n_real_days] >= 0, Int)[m
[32m+[m[32m    @variable(m, day[1:n_real_days], Bin)[m
[32m+[m
[32m+[m
[32m+[m[32m    @constraint(m, sum(m[:weight_day][d] for d in 1:n_real_days) == n_real_days)[m
[32m+[m[32m    @constraint(m, [d in 1:n_real_days], weight_day[d] <= n_real_days * day[d])[m
[32m+[m[32m    @constraint(m, [d in 1:n_real_days], weight_day[d] >= day[d])[m
[32m+[m
[32m+[m
[32m+[m[32m    @constraint(m, sum(day[d] for d in 1:n_real_days) == N_days)[m
[32m+[m
[32m+[m[32m    @variable(m, errors[1:N_metric, 1:N_bins])[m
[32m+[m
[32m+[m
[32m+[m[32m    @constraint(m, [metric in 1:N_metric, b in 1:N_bins], errors[metric,b] >= sum(weight_day[d] * 1/n_real_days * A[metric,b,d] for d in 1:n_real_days) - L[metric,b])[m
[32m+[m[32m    @constraint(m, [metric in 1:N_metric, b in 1:N_bins], errors[metric,b] >= -(sum(weight_day[d] * 1/n_real_days * A[metric,b,d] for d in 1:n_real_days) - L[metric,b]))[m
[32m+[m
[32m+[m[32m    @objective(m, Min, sum(errors[metric, b] for metric in 1:N_metric for b in 1:N_bins))[m
[32m+[m
[32m+[m[32m    JuMP.optimize!(m)[m
 [m
     days_id = findall( x -> x > 0, Int64.(round.(value.(m[:day]))))[m
     return days_id, Int64.(round.(value.(m[:weight_day])))[days_id][m
[36m@@ -292,3 +385,159 @@[m [mfunction get_days(N_days, N_bins, Ï‰, y ,s; time_limit = 0)[m
 end[m
 [m
 [m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32mfunction get_profil_and_sequence_multi_year(days::Vector{Int64}, weights::Vector{Int64}, Ï‰::Scenarios, y::Int64, s::Int64, mg::Microgrid; display_res = false, time_limit = 300)[m
[32m+[m[41m    [m
[32m+[m
[32m+[m[32m    data_reshape = [][m
[32m+[m[32m    data = [][m
[32m+[m[32m    labels = [][m
[32m+[m[32m    units = [][m
[32m+[m
[32m+[m[32m    for (k,demand) in enumerate(Ï‰.demands)[m
[32m+[m[32m        push!(data, demand.power[:, :, s])[m
[32m+[m[32m        push!(labels, string("demand : ", typeof(mg.demands[k].carrier)))[m
[32m+[m[32m        push!(units, string( "Power [kWh]"))[m
[32m+[m[41m       [m
[32m+[m[32m    end[m
[32m+[m[32m    for (k,generation) in enumerate(Ï‰.generations)[m
[32m+[m[32m        push!(data, generation.power[:, :, s])[m
[32m+[m[32m        push!(labels, string("generation : ", typeof(mg.generations[k])))[m
[32m+[m[32m        push!(units, string("Power [p.u]"))[m
[32m+[m[32m    end[m
[32m+[m
[32m+[m[32m    n_real_days = 365 * y[m[41m [m
[32m+[m[32m    @assert(n_real_days == length(data[1])/24)[m
[32m+[m
[32m+[m
[32m+[m[32m    max_data = maximum.(data)[m
[32m+[m
[32m+[m[32m    for (k,d) in enumerate(data)[m
[32m+[m[32m        push!(data_reshape, reshape(vec(d), (24,n_real_days)) ./ max_data[k])[m
[32m+[m[32m    end[m
[32m+[m[41m    [m
[32m+[m[41m    [m
[32m+[m[32m    total_energy = sum(sum(data))[m
[32m+[m[32m    weight_energy = ones(length(data)) ./ length(data)#[sum(d) for d in data] ./ total_energy[m
[32m+[m
[32m+[m
[32m+[m[32m    m2 = Model(Gurobi.Optimizer)[m
[32m+[m[32m    set_optimizer_attribute(m2, "TimeLimit", time_limit)[m
[32m+[m[41m    [m
[32m+[m[32m    #Which day is assigned to which representative[m
[32m+[m[32m    @variable(m2, assignments[1:n_real_days, 1:length(days)], Bin)[m
[32m+[m
[32m+[m[32m    #Each representative represent itself[m
[32m+[m[32m    for (i,d) in enumerate(days)[m
[32m+[m[32m        fix(m2[:assignments][d,i], 1)[m
[32m+[m[32m    end[m
[32m+[m
[32m+[m[32m    #Each day is represented by one day[m
[32m+[m[32m    @constraint(m2, [d in 1:n_real_days], sum(assignments[d,r] for r in 1:length(days)) == 1)[m
[32m+[m[32m    # Each representative represents a number of day equal to its weight[m
[32m+[m[32m    @constraint(m2, [r in 1:length(days)], sum(assignments[d,r] for d in 1:n_real_days) == weights[r])[m
[32m+[m
[32m+[m[32m    #The constructed profil[m
[32m+[m[32m    @variable(m2, constructed_data[1:length(data_reshape), 1:n_real_days, 1:24])[m
[32m+[m[32m    #Assign values to the constructed profil[m
[32m+[m[32m    @constraint(m2, [data_id in 1:length(data_reshape), d in 1:n_real_days, h in 1:24], constructed_data[data_id,d,h] == sum(assignments[d,r] * data_reshape[data_id][h,days[r]] for r in 1:length(days)))[m
[32m+[m
[32m+[m[32m    @variable(m2, error[1:length(data_reshape), 1:n_real_days, 1:24])[m
[32m+[m[41m   [m
[32m+[m
[32m+[m[32m    @constraint(m2, [data_id in 1:length(data_reshape), d in 1:n_real_days, h in 1:24], error[data_id, d, h] == (constructed_data[data_id,d,h] - data_reshape[data_id][h,d]))[m
[32m+[m[41m   [m
[32m+[m
[32m+[m
[32m+[m[32m    #Minimize the squared error[m
[32m+[m[32m   # @objective(m2, Min, sum((error[data_id, d, h]^2) * weight_energy[data_id] for data_id in 1:length(data_reshape) for d in 1:n_real_days for  h in 1:24))[m
[32m+[m[41m   [m
[32m+[m[32m   # Not quadratic version[m
[32m+[m[32m   @variable(m2, error_abs[1:length(data_reshape), 1:n_real_days, 1:24])[m
[32m+[m[32m   @constraint(m2, [data_id in 1:length(data_reshape), d in 1:n_real_days, h in 1:24], error_abs[data_id, d, h] >= error[data_id, d, h])[m
[32m+[m[32m   @constraint(m2, [data_id in 1:length(data_reshape), d in 1:n_real_days, h in 1:24], error_abs[data_id, d, h] >= -error[data_id, d, h])[m
[32m+[m[32m   @objective(m2, Min, sum((error_abs[data_id, d, h]) * weight_energy[data_id] for data_id in 1:length(data_reshape) for d in 1:n_real_days for  h in 1:24))[m
[32m+[m
[32m+[m[32m    JuMP.optimize!(m2)[m
[32m+[m
[32m+[m[41m    [m
[32m+[m[32m    sequence = [findfirst( x -> x > 0, value.(m2[:assignments][i,:])) for i in 1:n_real_days][m
[32m+[m
[32m+[m[32m    constructed_res = [reshape(vec(transpose(value.(m2[:constructed_data][k,:,:]))) * max_data[k], (8760,y)) for k in 1:length(data)][m
[32m+[m
[32m+[m[32m    # load_result_E = vec(transpose(value.(m2[:constructed_data][1,:,:]))) * max_ld_E[m
[32m+[m[32m    # load_result_H = vec(transpose(value.(m2[:constructed_data][2,:,:]))) * max_ld_H[m
[32m+[m[32m    # gen_result = vec(transpose(value.(m2[:constructed_data][3,:,:]))) * max_ld_PV[m
[32m+[m
[32m+[m[32m    if display_res[m[41m [m
[32m+[m[41m    [m
[32m+[m[32m        fig, axs = PyPlot.subplots(length(data),1, figsize=(9, 3), sharey=true)[m
[32m+[m[32m        fig.set_size_inches( 1920 / fig.dpi, 1080/ fig.dpi)[m
[32m+[m
[32m+[m[32m        for k in 1:length(data)[m
[32m+[m[32m            axs[k].plot(vec(transpose(value.(m2[:error])[k,:,:])).^2)[m
[32m+[m[32m            axs[k].set_title(labels[k])[m
[32m+[m[32m            axs[k].set_xlabel("Days",fontsize = 16)[m
[32m+[m[32m            axs[k].set_ylabel("Squared Error",fontsize = 16)[m
[32m+[m[32m        end[m
[32m+[m[32m        # axs[1].plot(vec(transpose(value.(m2[:error])[2,:,:])).^2)[m
[32m+[m[32m        # axs[1].set_title("Load_H")[m
[32m+[m[32m        # axs[1].set_xlabel("Days",fontsize = 16)[m
[32m+[m[32m        # axs[1].set_ylabel("Squared Error",fontsize = 16)[m
[32m+[m
[32m+[m
[32m+[m[32m        # axs[2].plot(vec(transpose(value.(m2[:error])[3,:,:])).^2)[m
[32m+[m[32m        # axs[2].set_title("Generation")[m
[32m+[m[32m        # axs[2].set_xlabel("Days",fontsize = 16)[m
[32m+[m[32m        # axs[2].set_ylabel("Squared Error",fontsize = 16)[m
[32m+[m[32m        tight_layout()[m
[32m+[m
[32m+[m[32m        fig, axs = PyPlot.subplots(length(data)+1,1, figsize=(9, 3), sharey=false)[m
[32m+[m[32m        fig.set_size_inches( 1920 / fig.dpi, 1080/ fig.dpi)[m
[32m+[m
[32m+[m[32m        for k in 1:length(data)[m
[32m+[m[32m            axs[k].plot(vec(data_reshape[k]).* max_data[k], label = "OG")[m
[32m+[m[32m            axs[k].plot(vec(transpose(value.(m2[:constructed_data][k,:,:]))) .* max_data[k])[m
[32m+[m[32m            axs[k].set_title(labels[k])[m
[32m+[m[32m            axs[k].set_ylabel(units[k],fontsize = 16)[m
[32m+[m[32m        end[m
[32m+[m[32m        # axs[2].plot(vec(data_reshape[2]).* max_ld_H, label = "OG")[m
[32m+[m[32m        # axs[2].plot(vec(transpose(value.(m2[:constructed_data][2,:,:]))) .* max_ld_H)[m
[32m+[m[32m        # axs[2].set_title("Load Profil Heat")[m
[32m+[m[32m        # axs[2].set_ylabel("Power [kW]",fontsize = 16)[m
[32m+[m
[32m+[m
[32m+[m[32m        # axs[3].plot(vec(data_reshape[3]).* max_ld_PV)[m
[32m+[m[32m        # axs[3].plot(vec(transpose(value.(m2[:constructed_data][3,:,:]))) .* max_ld_PV)[m
[32m+[m[32m        # axs[3].set_title("Generation Profil")[m
[32m+[m[32m        # axs[3].set_xlabel("Hours",fontsize = 16)[m
[32m+[m[32m        # axs[3].set_ylabel("Power [p.u]",fontsize = 16)[m
[32m+[m
[32m+[m
[32m+[m[32m        x_id = [][m
[32m+[m[32m        color_id = [][m
[32m+[m[32m       # color_names = collect(keys(matplotlib.colors.XKCD_COLORS))[m
[32m+[m[32m        color = Seaborn.color_palette("viridis", as_cmap =true)[m
[32m+[m
[32m+[m[32m        for day in 1:(365*y)[m
[32m+[m[32m            push!(x_id, (((day-1)*1), 1))[m
[32m+[m[32m            push!(color_id, color(days[sequence[day]]/(365*y)))# color_names[sequence[day]])[m
[32m+[m[32m        end[m
[32m+[m[32m        axs[length(data)+1].broken_barh(x_id, (0, 1),[m
[32m+[m[32m                    facecolors=color_id)[m
[32m+[m
[32m+[m[32m        tight_layout()[m
[32m+[m
[32m+[m[32m        legend()[m
[32m+[m[32m    end[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[41m    [m
[32m+[m[32m    return  constructed_res, sequence[m
[32m+[m
[32m+[m
[32m+[m[32mend[m
\ No newline at end of file[m
[1mdiff --git a/src/simulation/dynamics.jl b/src/simulation/dynamics.jl[m
[1mindex 98cd07a..f000049 100644[m
[1m--- a/src/simulation/dynamics.jl[m
[1m+++ b/src/simulation/dynamics.jl[m
[36m@@ -1,19 +1,55 @@[m
[31m-#=[m
[31m-    This file includes all the funtions needed to compute the operation[m
[31m-    and investment dynamics[m
[31m- =#[m
[32m+[m[32m"""[m
[32m+[m[32m function compute_operation_dynamics!(h::Int64, y::Int64, s::Int64, mg::Microgrid, controller::AbstractController)[m
 [m
[32m+[m[32mFor each convert and storage from mg the operation of the time and scenario index h,y,s the decision from controller are applied.[m
[32m+[m[32m# Arguments[m
[32m+[m[32m- `h::Int64`: An hour.[m
[32m+[m[32m- `y::Int64`: A year.[m
[32m+[m[32m- `s::Int64`: A scenario.[m
[32m+[m[32m- `mg::Microgrid`: A microgrid to be operated at time index h,y,s.[m
[32m+[m[32m- `controller::AbstractController`: A controller storing the decisions for the components to be operated..[m
[32m+[m
[32m+[m[32m# Returns[m
[32m+[m[32m- nothing[m
[32m+[m
[32m+[m[32m## Example[m
[32m+[m
[32m+[m[32m```julia[m
[32m+[m[32m    # Compute operation dynamics for each converter and storage in mg[m
[32m+[m[32m    compute_operation_dynamics!(h, y, s, mg, controller)[m
[32m+[m[32m```[m
[32m+[m[32m"""[m
 function compute_operation_dynamics!(h::Int64, y::Int64, s::Int64, mg::Microgrid, controller::AbstractController)[m
     # Converters[m
     for (k, a) in enumerate(mg.converters)[m
[31m-        @inbounds compute_operation_dynamics!(h, y, s, a, controller.decisions.converters[k][h,y,s], mg.parameters.Î”h)[m
[32m+[m[32m        compute_operation_dynamics!(h, y, s, a, controller.decisions.converters[k][h,y,s], mg.parameters.Î”h)[m
     end[m
     # Storage[m
     for (k, a) in enumerate(mg.storages)[m
[31m-        @inbounds compute_operation_dynamics!(h, y, s, a, controller.decisions.storages[k][h,y,s], mg.parameters.Î”h)[m
[32m+[m[32m        compute_operation_dynamics!(h, y, s, a, controller.decisions.storages[k][h,y,s], mg.parameters.Î”h)[m
     end[m
 end[m
 [m
[32m+[m[32m"""[m
[32m+[m[32mfunction compute_investment_dynamics!(y::Int64, s::Int64, mg::Microgrid, designer::AbstractDesigner)[m
[32m+[m
[32m+[m[32mFor each generation, convertion and storage unit from mg, the design decisions associated to the year y and scenario s are applied.[m
[32m+[m[32m# Arguments[m
[32m+[m[32m- `y::Int64`: A year.[m
[32m+[m[32m- `s::Int64`: A scenario.[m
[32m+[m[32m- `mg::Microgrid`: A microgrid to be operated at time index h,y,s.[m
[32m+[m[32m- `designer::AbstractDesigner`: A designer storing the design decisions.[m
[32m+[m
[32m+[m[32m# Returns[m
[32m+[m[32m- nothing[m
[32m+[m
[32m+[m[32m## Example[m
[32m+[m
[32m+[m[32m```julia[m
[32m+[m[32m    # Compute decision dynamics for each convertion, storage and generation unit in mg[m
[32m+[m[32m    compute_investment_dynamics!(y, s, mg, designer)[m
[32m+[m[32m```[m
[32m+[m[32m"""[m
 function compute_investment_dynamics!(y::Int64, s::Int64, mg::Microgrid, designer::AbstractDesigner)[m
      # Generations[m
      for (k, a) in enumerate(mg.generations)[m
[1mdiff --git a/src/tmp/optimization/controller/rb.jl b/src/tmp/optimization/controller/rb.jl[m
[1mindex aaaedb4..fb8fbe2 100644[m
[1m--- a/src/tmp/optimization/controller/rb.jl[m
[1m+++ b/src/tmp/optimization/controller/rb.jl[m
[36m@@ -219,9 +219,9 @@[m [mfunction Ï€_6(h::Int64, y::Int64, s::Int64, mg::Microgrid, controller::RBC)[m
         u_heater_E, heater_H = compute_operation_dynamics(heater, (powerMax = heater.powerMax[y,s],), p_net_E - u_liion - u_elyz_E, Î”h)[m
     else[m
         # If the battery is getting low and the fuelcell is not activated due to minor demand we activate and use the excess to charge the battery with it[m
[31m-        if p_net_E - u_liion < fc.EffModel.powerMin[h,y,s] && p_net_E - u_liion != 0 #&& liion.soc[h,y,s] < 0.6 #&& h2tank.soc[h,y,s] > 0.3 [m
[31m-            p_adjust_E = fc.EffModel.powerMin[h,y,s][m
[31m-            u_liion = p_net_E - fc.EffModel.powerMin[h,y,s][m
[32m+[m[32m        if p_net_E - u_liion < fc.eff_model.powerMin[h,y,s] && p_net_E - u_liion != 0 #&& liion.soc[h,y,s] < 0.6 #&& h2tank.soc[h,y,s] > 0.3[m[41m [m
[32m+[m[32m            p_adjust_E = fc.eff_model.powerMin[h,y,s][m
[32m+[m[32m            u_liion = p_net_E - fc.eff_model.powerMin[h,y,s][m
         else[m
             p_adjust_E = p_net_E - u_liion[m
         end[m
[36m@@ -279,8 +279,8 @@[m [mfunction Ï€_7(h::Int64, y::Int64, s::Int64, mg::Microgrid, controller::RBC)[m
     if p_net_E < 0.[m
 [m
         # If there is a rest but its not enough to activate the elyz[m
[31m-        if p_net_E - u_liion < elyz.EffModel.powerMax[h,y,s] * elyz.min_part_load && p_net_E - u_liion > 0 && p_net_E >= elyz.EffModel.powerMin[h,y,s][m
[31m-            p_adjust_E = elyz.EffModel.powerMin[h,y,s][m
[32m+[m[32m        if p_net_E - u_liion < elyz.eff_model.powerMax[h,y,s] * elyz.min_part_load && p_net_E - u_liion > 0 && p_net_E >= elyz.eff_model.powerMin[h,y,s][m
[32m+[m[32m            p_adjust_E = elyz.eff_model.powerMin[h,y,s][m
             u_liion = p_net_E - p_adjust_E[m
         else[m
             p_adjust_E = p_net_E - u_liion[m
[36m@@ -299,8 +299,8 @@[m [mfunction Ï€_7(h::Int64, y::Int64, s::Int64, mg::Microgrid, controller::RBC)[m
        [m
     else[m
          # If there is a rest but its not enough to activate the fc[m
[31m-        if p_net_E - u_liion < fc.EffModel.powerMin[h,y,s] && p_net_E - u_liion > 0 && p_net_E >= fc.EffModel.powerMin[h,y,s][m
[31m-            p_adjust_E = fc.EffModel.powerMin[h,y,s][m
[32m+[m[32m        if p_net_E - u_liion < fc.eff_model.powerMin[h,y,s] && p_net_E - u_liion > 0 && p_net_E >= fc.eff_model.powerMin[h,y,s][m
[32m+[m[32m            p_adjust_E = fc.eff_model.powerMin[h,y,s][m
             u_liion = p_net_E - p_adjust_E[m
         else[m
             p_adjust_E = p_net_E - u_liion[m
[36m@@ -349,7 +349,7 @@[m [mfunction Ï€_8(h::Int64, y::Int64, s::Int64, mg::Microgrid, controller::RBC)[m
 [m
         if u_fc_E == 0[m
             # La pile ne peut pas prendre le reste alors on lui donne son min [m
[31m-            u_fc_E = fc.EffModel.powerMin[h,y,s] [m
[32m+[m[32m            u_fc_E = fc.eff_model.powerMin[h,y,s][m[41m [m
             u_liion = p_net_E - u_fc_E[m
         end[m
 [m
[36m@@ -365,7 +365,7 @@[m [mfunction Ï€_8(h::Int64, y::Int64, s::Int64, mg::Microgrid, controller::RBC)[m
 [m
         if u_elyz_E == 0[m
             # L'electrolyzer ne peut pas prendre le reste alors on lui donne son min [m
[31m-            min_elyz = ceil(elyz.EffModel.powerMax[h,y,s] * elyz.min_part_load, digits = 6)[m
[32m+[m[32m            min_elyz = ceil(elyz.eff_model.powerMax[h,y,s] * elyz.min_part_load, digits = 6)[m
 [m
             u_elyz_E, _, u_elyz_H2 = compute_operation_dynamics(elyz, h, y, s, -min_elyz, Î”h)[m
 [m
[1mdiff --git a/src/tmp/optimization/designer/metaheuristic/metaheuristic.jl b/src/tmp/optimization/designer/metaheuristic/metaheuristic.jl[m
[1mindex 24a9503..eaf15dc 100644[m
[1m--- a/src/tmp/optimization/designer/metaheuristic/metaheuristic.jl[m
[1m+++ b/src/tmp/optimization/designer/metaheuristic/metaheuristic.jl[m
[36m@@ -602,7 +602,7 @@[m [mend[m
 function get_liion_model_config(decisions::NamedTuple{(:eff, :soh, :couplage), Tuple{Float64, Float64, Float64}})[m
 [m
     if Int(round(decisions.eff)) == 0 [m
[31m-        eff_model = LinearLiionEfficiency()[m
[32m+[m[32m        eff_model = FixedLiionEfficiency()[m
     elseif  Int(round(decisions.eff)) == 1[m
         eff_model = PolynomialLiionEfficiency()[m
     else[m
[36m@@ -631,7 +631,7 @@[m [mfunction get_liion_model_config(decisions::NamedTuple{(:eff, :soh, :couplage), T[m
 [m
 [m
     [m
[31m-    return Liion(SoC_model = eff_model, SoH_model = soh_model, couplage = coupl)[m
[32m+[m[32m    return Liion(eff_model = eff_model, SoH_model = soh_model, couplage = coupl)[m
 [m
 end[m
 [m
[36m@@ -668,7 +668,7 @@[m [mfunction get_electrolyer_model_config(decisions::NamedTuple{(:eff, :soh, :coupla[m
 [m
 [m
     [m
[31m-    return Electrolyzer(;V_J_ini = V_J_Elyz, EffModel = eff_model, SoH_model = soh_model, couplage = coupl)[m
[32m+[m[32m    return Electrolyzer(;V_J_ini = V_J_Elyz, eff_model = eff_model, SoH_model = soh_model, couplage = coupl)[m
 [m
 end[m
 [m
[36m@@ -692,9 +692,9 @@[m [mfunction get_fuelcell_model_config(decisions::NamedTuple{(:eff, :soh, :couplage)[m
     elseif Int(round(decisions.soh)) == 1[m
         soh_model =  FunctHoursAgingFuelCell(;deg_params=deg, J_base = 0.1)[m
     elseif Int(round(decisions.soh)) == 2[m
[31m-        soh_model =  PowerAgingFuelCell(;deg_params=deg, StartStop = false)[m
[32m+[m[32m        soh_model =  PowerAgingFuelCell(;deg_params=deg, start_stop = false)[m
     elseif Int(round(decisions.soh)) == 3[m
[31m-        soh_model =  PowerAgingFuelCell(;deg_params=deg, StartStop = true)[m
[32m+[m[32m        soh_model =  PowerAgingFuelCell(;deg_params=deg, start_stop = true)[m
     else[m
         println("problem with var Fuel Cell soh model : ", decisions.soh)[m
     end[m
[36m@@ -708,7 +708,7 @@[m [mfunction get_fuelcell_model_config(decisions::NamedTuple{(:eff, :soh, :couplage)[m
     end[m
 [m
     [m
[31m-    return FuelCell(;V_J_ini = V_J_FC, EffModel = eff_model, SoH_model = soh_model, couplage = coupl)[m
[32m+[m[32m    return FuelCell(;V_J_ini = V_J_FC, eff_model = eff_model, SoH_model = soh_model, couplage = coupl)[m
 [m
 end[m
 [m
[1mdiff --git a/src/tmp/optimization/utils.jl b/src/tmp/optimization/utils.jl[m
[1mindex b9b0497..700234e 100644[m
[1m--- a/src/tmp/optimization/utils.jl[m
[1m+++ b/src/tmp/optimization/utils.jl[m
[36m@@ -134,7 +134,7 @@[m [mfunction fix_investment_decisions!(m::Model, mg::Microgrid, generations::Dict, s[m
     if !isempty(converters)[m
         for (i,key) in enumerate(keys(converters))[m
             if converters[key] isa NamedTuple[m
[31m-                power = maximum(mg.converters[i].V_J_ini.V .* mg.converters[i].V_J_ini.J) * converters["FuelCell"].surface * converters["FuelCell"].N_cell[m
[32m+[m[32m                power = maximum(mg.converters[i].V_J_ini[1,:] .* mg.converters[i].V_J_ini[2,:]) * converters["FuelCell"].surface * converters["FuelCell"].N_cell[m
                 fix(m[:r_c][i], power)[m
             else[m
                 fix(m[:r_c][i], converters[key])[m
[36m@@ -228,6 +228,17 @@[m [mfunction add_SoC_base!(m::Model, storages::Vector{AbstractStorage}, ns::Int64)[m
 end[m
 [m
 [m
[32m+[m[32mfunction add_SoC_base!(m::Model, storages::Vector{AbstractStorage}, ns::Int64, n_days::Int64)[m
[32m+[m[32m    if !isempty(storages)[m
[32m+[m[32m        na = length(storages)[m
[32m+[m
[32m+[m[32m        @variables(m, begin[m
[32m+[m[32m            SoC_base[1:(n_days+1), 1:ns, 1:na]  >= 0.[m
[32m+[m[32m        end)[m
[32m+[m[32m    end[m
[32m+[m[32mend[m
[32m+[m
[32m+[m
 # Investment bounds[m
 function add_investment_constraints!(m::Model, generations::Vector{AbstractGeneration})[m
     if !isempty(generations)[m
[36m@@ -289,11 +300,11 @@[m [mfunction add_technical_constraints_mini!(m::Model, storages::Vector{AbstractStor[m
         na = length(storages)[m
         @constraints(m, begin[m
         # Power bounds[m
[31m-        [h in 1:nh, s in 1:ns, a in 1:na], m[:p_dch][h,s,a] <= storages[a].Î±_p_dch * m[:r_sto][a][m
[31m-        [h in 1:nh, s in 1:ns, a in 1:na], m[:p_ch][h,s,a]  <= storages[a].Î±_p_ch * m[:r_sto][a][m
[32m+[m[32m       # [h in 1:nh, s in 1:ns, a in 1:na], m[:p_dch][h,s,a] <= storages[a].Î±_p_dch * m[:r_sto][a][m
[32m+[m[32m       # [h in 1:nh, s in 1:ns, a in 1:na], m[:p_ch][h,s,a]  <= storages[a].Î±_p_ch * m[:r_sto][a][m
         [m
[31m-        [h in 1:nh+1, s in 1:ns, a in 1:na], m[:soc][h,s,a] <= storages[a].Î±_soc_max * m[:r_sto][a][m
[31m-        [h in 1:nh+1, s in 1:ns, a in 1:na], m[:soc][h,s,a] >= storages[a].Î±_soc_min * m[:r_sto][a][m
[32m+[m[32m       # [h in 1:nh+1, s in 1:ns, a in 1:na], m[:soc][h,s,a] <= storages[a].Î±_soc_max * m[:r_sto][a][m
[32m+[m[32m       # [h in 1:nh+1, s in 1:ns, a in 1:na], m[:soc][h,s,a] >= storages[a].Î±_soc_min * m[:r_sto][a][m
         # State dynamics[m
         # Initial and final states[m
         end)[m
[36m@@ -301,8 +312,13 @@[m [mfunction add_technical_constraints_mini!(m::Model, storages::Vector{AbstractStor[m
         for (k,a) in enumerate(storages)[m
             if typeof(a) <: AbstractLiion[m
                 @constraints(m, begin[m
[31m-                    soc_ini[s in 1:ns, a in 1:na], m[:soc][1,s,a] == storages[a].soc_ini * m[:r_sto][a][m
[31m-                    [h in 1:nh, s in 1:ns, a in 1:na], m[:soc][h+1,s,a] == m[:soc][h,s,a] * (1. - storages[a].Î·_self * Î”h) - (m[:p_dch][h,s,a] / storages[a].Î·_dch - m[:p_ch][h,s,a] * storages[a].Î·_ch) * Î”h[m
[32m+[m[32m                    soc_ini_liion[s in 1:ns, a in 1:na], m[:soc][1,s,k] == storages[k].soc_ini * m[:r_sto][k][m
[32m+[m[32m                    [h in 1:nh, s in 1:ns], m[:soc][h+1,s,k] == m[:soc][h,s,k] * (1. - storages[k].eff_model.Î·_self * Î”h) - (m[:p_dch][h,s,k] / storages[k].eff_model.Î·_dch - m[:p_ch][h,s,k] * storages[k].eff_model.Î·_ch) * Î”h[m
[32m+[m[32m                end)[m
[32m+[m[32m            else[m
[32m+[m[32m                @constraints(m, begin[m
[32m+[m[32m                    soc_ini_H2[s in 1:ns], m[:soc][1,s,k] == storages[k].soc_ini * m[:r_sto][k][m
[32m+[m[32m                    [h in 1:nh, s in 1:ns], m[:soc][h+1,s,k] == m[:soc][h,s,k] * (1. - storages[k].Î·_self * Î”h) - (m[:p_dch][h,s,k] / storages[k].Î·_dch - m[:p_ch][h,s,k] * storages[k].Î·_ch) * Î”h[m
                 end)[m
             end[m
         end[m
[36m@@ -351,6 +367,7 @@[m [mfunction add_Continuity_SoC_constraints!(m::Model, storages::Vector{AbstractStor[m
     [d in 1:ndays, h in 1:24, s in 1:ns, a in 1:na], m[:Extrem_high][d,s,a] >= sum( (m[:p_dch][((d-1)*24)+i,s,a] / storages[a].Î·_dch) - (m[:p_ch][((d-1)*24)+i,s,a] * storages[a].Î·_ch) for i in 1:h)[m
     [d in 1:ndays, h in 1:24, s in 1:ns, a in 1:na], m[:Extrem_low][d,s,a] <= sum( (m[:p_dch][((d-1)*24)+i,s,a] / storages[a].Î·_dch) - (m[:p_ch][((d-1)*24)+i,s,a] * storages[a].Î·_ch) for i in 1:h)[m
 [m
[32m+[m
     #Constraint Extrem value to be inside to soc  bounds[m
     [d in 1:365, s in 1:ns, a in 1:na], m[:SoC_base][d,s,a] + m[:Extrem_high][sequence[d],s,a] <= storages[a].Î±_soc_max * m[:r_sto][a][m
     [d in 1:365, s in 1:ns, a in 1:na], m[:SoC_base][d,s,a] + m[:Extrem_low][sequence[d],s,a] >= storages[a].Î±_soc_min * m[:r_sto][a][m
[36m@@ -368,8 +385,6 @@[m [mfunction add_Continuity_SoC_constraints_mini!(m::Model, storages::Vector{Abstrac[m
         na = length(storages)[m
     end[m
 [m
[31m-[m
[31m-[m
     @variables(m, begin[m
     Extrem_high[1:ndays, 1:ns, 1:na] [m
     Extrem_low[1:ndays, 1:ns, 1:na] [m
[36m@@ -377,18 +392,28 @@[m [mfunction add_Continuity_SoC_constraints_mini!(m::Model, storages::Vector{Abstrac[m
     end)[m
 [m
 [m
[32m+[m[32m    Î·_ch = [storages[1].eff_model.Î·_ch][m
[32m+[m[32m    Î·_dch = [storages[1].eff_model.Î·_dch][m
[32m+[m[32m    Î·_self = [storages[1].eff_model.Î·_self][m
[32m+[m[32m    if length(storages) == 2[m
[32m+[m[32m        Î·_ch = vcat(Î·_ch, storages[2].Î·_ch)[m[41m [m
[32m+[m[32m        Î·_dch = vcat(Î·_dch, storages[2].Î·_dch)[m[41m [m
[32m+[m[32m        Î·_self = vcat(Î·_self, storages[2].Î·_self)[m[41m [m
[32m+[m[32m    end[m
[32m+[m[41m    [m
     @constraints(m, begin[m
     # Constraint the Base soc to be a sequence of sum of relative differences[m
[31m-    [d in 1:ndays, s in 1:ns, a in 1:na], m[:relativ_diff][d,s,a] == sum( (m[:p_dch][((d-1)*24)+i,s,a] / storages[a].Î·_dch) - (m[:p_ch][((d-1)*24)+i,s,a] * storages[a].Î·_ch) for i in 1:24)[m
[32m+[m[32m    [d in 1:ndays, s in 1:ns, a in 1:na], m[:relativ_diff][d,s,a] == sum((m[:p_ch][((d-1)*24)+h,s,a] * Î·_ch[a]) - (m[:p_dch][((d-1)*24)+h,s,a] / Î·_dch[a]) for h in 1:24)[m
 [m
     [s in 1:ns, a in 1:na], m[:SoC_base][1,s,a] == storages[a].soc_ini * m[:r_sto][a][m
[31m-    [d in 1:365, s in 1:ns, a in 1:na], m[:SoC_base][d+1,s,a] == (1-storages[a].Î·_self) * m[:SoC_base][d,s,a] + m[:relativ_diff][sequence[d],s,a][m
[32m+[m[32m    [d in 1:365, s in 1:ns, a in 1:na], m[:SoC_base][d+1,s,a] == (1 - Î·_self[a]) * m[:SoC_base][d,s,a] + m[:relativ_diff][sequence[d],s,a][m
 [m
     #Constraint extrem values for each days to be greater than the max and min soc diff[m
     # extrem have to be superior resp inferior to the sum of power flow at any moment of the day.[m
[31m-    [d in 1:ndays, h in 1:24, s in 1:ns, a in 1:na], m[:Extrem_high][sequence[d],s,a] >= sum( (m[:p_dch][((d-1)*24)+i,s,a] / storages[a].Î·_dch) - (m[:p_ch][((d-1)*24)+i,s,a] * storages[a].Î·_ch) for i in 1:h)[m
[31m-[m
[31m-    [d in 1:ndays, h in 1:24, s in 1:ns, a in 1:na], m[:Extrem_low][sequence[d],s,a] <= sum( (m[:p_dch][((d-1)*24)+i,s,a] / storages[a].Î·_dch) - (m[:p_ch][((d-1)*24)+i,s,a] * storages[a].Î·_ch) for i in 1:h)[m
[32m+[m[32m    [d in 1:ndays, h in 1:24, s in 1:ns, a in 1:na], m[:Extrem_high][d,s,a] >= sum( (m[:p_ch][((d-1)*24)+i,s,a] * Î·_ch[a]) - (m[:p_dch][((d-1)*24)+i,s,a] / Î·_dch[a])  for i in 1:h)[m
[32m+[m[32m   # [d in 1:ndays, h in 1:24, s in 1:ns, a in 1:na], m[:Extrem_low][d,s,a] <= 0.[m
[32m+[m[32m    #[d in 1:ndays, h in 1:24, s in 1:ns, a in 1:na], m[:Extrem_high][d,s,a] >= 0[m
[32m+[m[32m    [d in 1:ndays, h in 1:24, s in 1:ns, a in 1:na], m[:Extrem_low][d,s,a] <= sum( (m[:p_ch][((d-1)*24)+i,s,a] * Î·_ch[a]) - (m[:p_dch][((d-1)*24)+i,s,a] / Î·_dch[a])  for i in 1:h)[m
 [m
 [m
     #Constraint Extrem value to be inside to soc  bounds[m
[36m@@ -503,15 +528,94 @@[m [mfunction add_power_balance!(m::Model, mg::Microgrid, Ï‰::AbstractScenarios, type[m
             if a isa Heater[m
                 add_to_expression!.(balance, .- m[:p_c][:,:,k] * a.Î·_E_H)[m
             elseif  typeof(a) <: AbstractElectrolyzer[m
[32m+[m[32m                add_to_expression!.(balance, .- m[:p_c][:,:,k] * a.eff_model.Î·_E_H)[m
[32m+[m[32m            elseif typeof(a) <: AbstractFuelCell[m
[32m+[m[32m                add_to_expression!.(balance, .- m[:p_c][:,:,k] / a.eff_model.Î·_H2_H * a.eff_model.Î·_H2_E) #p_c is the electrical power, so the first step compute the H2 power then the efficiency to heat is applied[m
[32m+[m[32m            end[m
[32m+[m[32m        elseif type == Hydrogen[m
[32m+[m[32m            if typeof(a) <: AbstractElectrolyzer[m
[32m+[m[32m                add_to_expression!.(balance, .- m[:p_c][:,:,k] * a.eff_model.Î·_E_H2)[m
[32m+[m[32m            elseif typeof(a) <: AbstractFuelCell[m
[32m+[m[32m                add_to_expression!.(balance, m[:p_c][:,:,k] / a.eff_model.Î·_H2_E)[m
[32m+[m[32m            end[m
[32m+[m[32m        end[m
[32m+[m[32m    end[m
[32m+[m[32m    # Grids[m
[32m+[m[32m    for (k,a) in enumerate(mg.grids)[m
[32m+[m[32m        if a.carrier isa type[m
[32m+[m[32m            add_to_expression!.(balance, .- m[:p_in][:,:,k] + m[:p_out][:,:,k])[m
[32m+[m[32m        end[m
[32m+[m[32m    end[m
[32m+[m[32m    # Energy balance constraint[m
[32m+[m[32m    if type == Electricity[m
[32m+[m[32m        @constraint(m, electricity, balance .<= 0.)[m
[32m+[m[32m    elseif type == Heat[m
[32m+[m[32m        @constraint(m, heat, balance .<= 0.)[m
[32m+[m[32m    elseif type == Hydrogen[m
[32m+[m[32m        @constraint(m, hydrogen, balance .== 0.)[m
[32m+[m[32m    end[m
[32m+[m[32mend[m
[32m+[m
[32m+[m
[32m+[m[32m# Power balance[m
[32m+[m[32mfunction add_power_balance_my!(m::Model, mg::Microgrid, Ï‰::AbstractScenarios, type::DataType, nh::Int64, ns::Int64; ispnet::Bool=false)[m
[32m+[m[32m    # !!! All the decision variables are defined positive !!![m
[32m+[m[32m    balance = AffExpr.(zeros(nh,ns))[m
[32m+[m[32m    # Demands and generation[m
[32m+[m[32m    if !ispnet[m
[32m+[m[32m        for (k,a) in enumerate(mg.demands)[m
[32m+[m[32m            if a.carrier isa type[m
[32m+[m[32m                add_to_expression!.(balance, hcat(vec(Ï‰.demands[k].power[:,:,1]))  )[m
[32m+[m[32m            end[m
[32m+[m[32m        end[m
[32m+[m[32m        # Generation[m
[32m+[m[32m        for (k,a) in enumerate(mg.generations)[m
[32m+[m[32m            if a.carrier isa type[m
[32m+[m[32m                add_to_expression!.(balance, .- m[:r_g][k] .* hcat(vec(Ï‰.generations[k].power[:,:,1])))[m
[32m+[m[32m            end[m
[32m+[m[32m        end[m
[32m+[m[32m    else[m
[32m+[m[32m        for (k,a) in enumerate(mg.demands)[m
[32m+[m[32m            if a.carrier isa type[m
[32m+[m[32m                add_to_expression!.(balance, m[:p_d][:,:,k])[m
[32m+[m[32m            end[m
[32m+[m[32m        end[m
[32m+[m[32m        # Generation[m
[32m+[m[32m        for (k,a) in enumerate(mg.generations)[m
[32m+[m[32m            if a.carrier isa type[m
[32m+[m[32m                add_to_expression!.(balance, .- m[:p_g][:,:,k])[m
[32m+[m[32m            end[m
[32m+[m[32m        end[m
[32m+[m[32m    end[m
[32m+[m[32m    # Storages[m
[32m+[m[32m    for (k,a) in enumerate(mg.storages)[m
[32m+[m[32m        if a.carrier isa type[m
[32m+[m[32m            add_to_expression!.(balance, m[:p_ch][:,:,k] .- m[:p_dch][:,:,k])[m
[32m+[m[32m        end[m
[32m+[m[32m    end[m
[32m+[m[32m    # Converters[m
[32m+[m[32m    for (k,a) in enumerate(mg.converters)[m
[32m+[m[32m        if type == Electricity[m
[32m+[m[32m            if a isa Heater[m
[32m+[m[32m                add_to_expression!.(balance, m[:p_c][:,:,k])[m
[32m+[m[32m            elseif typeof(a) <: AbstractElectrolyzer[m
[32m+[m[32m                add_to_expression!.(balance, m[:p_c][:,:,k])[m
[32m+[m[32m            elseif typeof(a) <: AbstractFuelCell[m
[32m+[m[32m                add_to_expression!.(balance, .- m[:p_c][:,:,k])[m
[32m+[m[32m            end[m
[32m+[m[32m        elseif type == Heat[m
[32m+[m[32m            if a isa Heater[m
                 add_to_expression!.(balance, .- m[:p_c][:,:,k] * a.Î·_E_H)[m
[32m+[m[32m            elseif  typeof(a) <: AbstractElectrolyzer[m
[32m+[m[32m                add_to_expression!.(balance, .- m[:p_c][:,:,k] * a.eff_model.Î·_E_H)[m
             elseif typeof(a) <: AbstractFuelCell[m
[31m-                add_to_expression!.(balance, .- m[:p_c][:,:,k] / a.Î·_H2_H * a.Î·_H2_E) #p_c is the electrical power, so the first step compute the H2 power then the efficiency to heat is applied[m
[32m+[m[32m                add_to_expression!.(balance, .- m[:p_c][:,:,k] / a.eff_model.Î·_H2_H * a.eff_model.Î·_H2_E) #p_c is the electrical power, so the first step compute the H2 power then the efficiency to heat is applied[m
             end[m
         elseif type == Hydrogen[m
             if typeof(a) <: AbstractElectrolyzer[m
[31m-                add_to_expression!.(balance, .- m[:p_c][:,:,k] * a.Î·_E_H2)[m
[32m+[m[32m                add_to_expression!.(balance, .- m[:p_c][:,:,k] * a.eff_model.Î·_E_H2)[m
             elseif typeof(a) <: AbstractFuelCell[m
[31m-                add_to_expression!.(balance, m[:p_c][:,:,k] / a.Î·_H2_E)[m
[32m+[m[32m                add_to_expression!.(balance, m[:p_c][:,:,k] / a.eff_model.Î·_H2_E)[m
             end[m
         end[m
     end[m
[36m@@ -678,11 +782,11 @@[m [mfunction compute_penalization(m, nh, ns)[m
     return penalization[m
 end[m
 [m
[31m-function compute_opex_mini(m::Model, mg::Microgrid, Ï‰::AbstractScenarios, nh::Int64, ns::Int64, sequence::Vector{Int64})[m
[32m+[m[32mfunction compute_opex_mini(m::Model, mg::Microgrid, Ï‰::AbstractScenarios, n_day::Int64, ns::Int64, sequence::Vector{Int64})[m
     cost = AffExpr.(zeros(ns))[m
     [m
     for (k,a) in enumerate(mg.grids)[m
[31m-        add_to_expression!.(cost, sum(sum((m[:p_in][i,:,k] .* Ï‰.grids[k].cost_in[i,1,:] .- m[:p_out][i,:,k] .* Ï‰.grids[k].cost_out[i,1,:]) .* mg.parameters.Î”h for i in ((sequence[d]-1)*24+1):(24*sequence[d])) for d in 1:365) )[m
[32m+[m[32m        add_to_expression!.(cost, sum(sum((m[:p_in][i,:,k] .* vec(Ï‰.grids[k].cost_in)[i] .- m[:p_out][i,:,k] .* vec(Ï‰.grids[k].cost_out)[i]) .* mg.parameters.Î”h for i in ((sequence[d]-1)*24+1):(24*sequence[d])) for d in 1:n_day) )[m
     #add_to_expression!.(cost, m[:p_in][h,:,k] .* Ï‰.grids[k].cost_in[h,1,:] for h in 1:nh)[m
     end[m
 [m
[1mdiff --git a/src/utils/metrics.jl b/src/utils/metrics.jl[m
[1mindex 24c4cfe..cb240bc 100644[m
[1m--- a/src/utils/metrics.jl[m
[1m+++ b/src/utils/metrics.jl[m
[36m@@ -23,6 +23,7 @@[m [mmutable struct TCO{T <: Array{Float64}}[m
     total::T[m
 end[m
 [m
[32m+[m[32m# TCO take account of grid cost, capex, salvage[m
 TCO(mg::Microgrid, designer::AbstractDesigner) = TCO(1:mg.parameters.ns, mg, designer)[m
 function TCO(s::Union{Int64, UnitRange{Int64}}, mg::Microgrid, designer::AbstractDesigner)[m
 [m
[36m@@ -39,6 +40,7 @@[m [mend[m
 # Compute costs[m
 COST(mg::Microgrid, designer::AbstractDesigner) = COST(1:mg.parameters.ns, mg, designer)[m
 # Compute costs for a given scenario s[m
[32m+[m[32m# COST take account of grid cost, capex, actualization rate and salvage[m
 function COST(s::Union{Int64, UnitRange{Int64}}, mg::Microgrid, designer::AbstractDesigner)[m
 [m
     Î³ = repeat(1. ./ (1. + mg.parameters.Ï„) .^ range(0, length = mg.parameters.ny, step = mg.parameters.Î”y), 1, length(s))[m
[36m@@ -64,6 +66,7 @@[m [mend[m
  # Compute costs[m
 NPV(mg::Microgrid, designer::AbstractDesigner) = NPV(1:mg.parameters.ns, mg, designer)[m
 # Compute costs for a given scenario s[m
[32m+[m[32m# NPV take account of  grid cost, capex, baseline, actualization rate and salvage[m
 function NPV(s::Union{Int64, UnitRange{Int64}}, mg::Microgrid, designer::AbstractDesigner)[m
 [m
     # Discount factor[m
[36m@@ -228,7 +231,7 @@[m [mfunction salvage_value(s::Union{Int64, UnitRange{Int64}}, mg::Microgrid)[m
     salvage[ny,:] .= 0.[m
     # Generations[m
     for a in mg.generations[m
[31m-        salvage[ny,:] = salvage[ny,:] .+ (a.lifetime .- ny) ./ a.lifetime .* a.cost[ny, s] .* a.powerMax[ny,s][m
[32m+[m[32m        salvage[ny,:] = salvage[ny,:] .+ (a.SoH_model.lifetime .- ny%a.SoH_model.lifetime) ./ a.SoH_model.lifetime .* a.cost[ny, s] .* a.powerMax[ny,s][m
     end[m
     # Storages[m
     for a in mg.storages[m
[36m@@ -237,12 +240,11 @@[m [mfunction salvage_value(s::Union{Int64, UnitRange{Int64}}, mg::Microgrid)[m
             #salvage[ny,:] = salvage[ny,:] .+ a.soh[1,end,s] .* a.cost[ny, s] .* a.Erated[ny,s][m
             #$a.soh[end,end,s]$ remplace ici $(a.lifetime .- ny) ./ a.lifetime$ comme indicateur de la fraction de vie restante[m
         else[m
[31m-            salvage[ny,:] = salvage[ny,:] .+ (a.lifetime .- ny) ./ a.lifetime .* a.cost[ny, s] .* a.Erated[ny,s][m
[32m+[m[32m            salvage[ny,:] = salvage[ny,:] .+ (a.SoH_model.lifetime .- ny%a.SoH_model.lifetime) ./ a.SoH_model.lifetime .* a.cost[ny, s] .* a.Erated[ny,s][m
         end[m
     end[m
     # Converters[m
     for a in mg.converters[m
[31m-        [m
         if hasproperty(a, :soh)[m
             if a isa AbstractFuelCell || a isa AbstractElectrolyzer[m
                 P_nom = maximum(a.V_J_ini[1,:] .* a.V_J_ini[2,:]) .* a.surface .* a.N_cell[m
[36m@@ -250,7 +252,7 @@[m [mfunction salvage_value(s::Union{Int64, UnitRange{Int64}}, mg::Microgrid)[m
                 salvage[ny,:] = salvage[ny,:] .+ ((a.soh[1,end,s] .- a.SoH_threshold) ./ (1 .-a.SoH_threshold)) .* a.cost[ny, s]  .* P_nom[m
             end[m
         else[m
[31m-            salvage[ny,:] = salvage[ny,:] .+ (a.lifetime .- ny) ./ a.lifetime .* a.cost[ny, s][m
[32m+[m[32m            salvage[ny,:] = salvage[ny,:] .+ (a.SoH_model.lifetime .- ny%a.SoH_model.lifetime) ./ a.SoH_model.lifetime .* a.cost[ny, s][m
         end[m
     end[m
    [m
[36m@@ -278,7 +280,7 @@[m [mfunction annualised_capex(y::Union{Int64, UnitRange{Int64}}, s::Union{Int64, Uni[m
     # Generations[m
     for (k, a) in enumerate(mg.generations)[m
     [m
[31m-        Î“ = (mg.parameters.Ï„ * (mg.parameters.Ï„ + 1.) ^ a.lifetime) / ((mg.parameters.Ï„ + 1.) ^ a.lifetime - 1.)            [m
[32m+[m[32m        Î“ = (mg.parameters.Ï„ * (mg.parameters.Ï„ + 1.) ^ a.SoH_model.lifetime) / ((mg.parameters.Ï„ + 1.) ^ a.SoH_model.lifetime - 1.)[m[41m            [m
         capex = capex .+ Î“ .* designer.decisions.generations[string(typeof(a))][y,s] .* a.cost[y,s][m
         capex[1,s] = capex[1,s] + Î“[1] .* designer.generations[string(typeof(a))] * a.cost[1,s][m
 [m
[36m@@ -289,7 +291,7 @@[m [mfunction annualised_capex(y::Union{Int64, UnitRange{Int64}}, s::Union{Int64, Uni[m
             id = findfirst(a.soh[:,:,s] .<= a.SoH_threshold) [m
             lifetime = id[2] + id[1]/8760[m
         else[m
[31m-            lifetime = a.lifetime[m
[32m+[m[32m            lifetime = a.SoH_model.lifetime[m
         end[m
         Î“ = (mg.parameters.Ï„ * (mg.parameters.Ï„ + 1.) ^ lifetime) / ((mg.parameters.Ï„ + 1.) ^  lifetime - 1.)[m
         capex = capex .+ Î“ .* designer.decisions.storages[string(typeof(a))][y,s] .* a.cost[y,s][m
[36m@@ -302,7 +304,7 @@[m [mfunction annualised_capex(y::Union{Int64, UnitRange{Int64}}, s::Union{Int64, Uni[m
             id = findfirst(a.soh[:,:,s] .<= a.SoH_threshold) [m
             lifetime = id[2] + id[1]/8760[m
         else[m
[31m-            lifetime = a.lifetime[m
[32m+[m[32m            lifetime = a.SoH_model.lifetime[m
         end[m
 [m
         Î“ = (mg.parameters.Ï„ * (mg.parameters.Ï„ + 1.) ^ lifetime) / ((mg.parameters.Ï„ + 1.) ^ lifetime - 1.)[m
