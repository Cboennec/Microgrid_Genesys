var documenterSearchIndex = {"docs":
[{"location":"assets.html#Assets","page":"Assets","title":"Assets","text":"","category":"section"},{"location":"assets.html#Storages","page":"Assets","title":"Storages","text":"","category":"section"},{"location":"assets.html#Batteries","page":"Assets","title":"Batteries","text":"","category":"section"},{"location":"assets.html","page":"Assets","title":"Assets","text":"Genesys.AbstractLiion\nGenesys.Liion_rainflow\nGenesys.Liion_electro_chimique\nGenesys.Liion_fixed_lifetime\nGenesys.Liion_energy_exchanged","category":"page"},{"location":"assets.html#Main.Genesys.AbstractLiion","page":"Assets","title":"Main.Genesys.AbstractLiion","text":"abstract type AbstractLiion <: AbstractStorage\n\nAn abstract type to generalize every Liion battery storage solution\n\n\n\n\n\n","category":"type"},{"location":"assets.html#Main.Genesys.Liion_rainflow","page":"Assets","title":"Main.Genesys.Liion_rainflow","text":"Liion_rainflow\n\nA mutable struct that represents a Li-ion battery model with rainflow counting algorithm for State of Health (SoH) computation.\n\nThe structure have a lot of parameters but most of them are set to default values.\n\nParameters:\n\nα_p_ch::Float64: Charging maximum C-rate (default : 1.5)\nα_p_dch::Float64: Discharging  maximum C-rate (default : 1.5)\nα_soc_min::Float64: Minimum threshold of charge (normalized) (default : 0.2)\nα_soc_max::Float64: Maximum threshold of charge (normalized) (default : 0.8)\nSoH_threshold::Float64: SoH level to replace the battery (default : 0.8)\ncouplage::NamedTuple: Named tuple with two boolean values to indicate if the SoH should influence the other parameters (E stand for capacity coupling and R for efficiency coupling)\nsoc_model::String: Model name for State of Charge (SoC) computation. Available models are listed \ncalendar::Bool: Whether to include calendar aging in the SoH computation  (default : true)\nsoc_ini::Float64: Initial State of Charge (SoC) for the beginning of the simulation (default : 0.5)\nsoh_ini::Float64: Initial State of Health (SoH) for the beginning of the simulation (default : 1)\nupdate_by_year::Int64: Rainflow SoH computation by year (default : 12)\nfatigue_data::DataFrames.DataFrame: DataFrame containing fatigue data (DoD, ncycle) (Default NMC battery data are provided)\n\nexample\n\nLiion_rainflow(update_by_year = 12, calendar = true, soc_model = \"linear\", couplage = (E=true, R=true))\n\n\n\n\n\n","category":"type"},{"location":"assets.html#Main.Genesys.Liion_electro_chimique","page":"Assets","title":"Main.Genesys.Liion_electro_chimique","text":"Liion_electro_chimique\n\nA mutable struct that represents a Li-ion battery aging model for State of Health (SoH) computation. This model is detailled in B. Xu et al. \"Modeling of Lithium-Ion Battery Degradation for Cell Life Assessment,\"  doi : 10.1109/TSG.2016.2578950, link.\n\nThe structure have a lot of parameters but most of them are set to default values.\n\nParameters:\n\nα_p_ch::Float64: Charging maximum C-rate (default : 1.5)\nα_p_dch::Float64: Discharging  maximum C-rate (default : 1.5)\nα_soc_min::Float64: Minimum threshold of charge (normalized) (default : 0.2)\nα_soc_max::Float64: Maximum threshold of charge (normalized) (default : 0.8)\nSoH_threshold::Float64: SoH level to replace the battery (default : 0.8)\ncouplage::NamedTuple: Named tuple with two boolean values to indicate if the SoH should influence the other parameters (E stand for capacity coupling and R for efficiency coupling)\ntemperature::Float64: Temperature of the battery (no temprature model is implemented for the battery).\nsoc_model::String: Model name for State of Charge (SoC) computation. Available models are listed \ncalendar::Bool: Whether to include calendar aging in the SoH computation  (default : true)\nsoc_ini::Float64: Initial State of Charge (SoC) for the beginning of the simulation (default : 0.5)\nsoh_ini::Float64: Initial State of Health (SoH) for the beginning of the simulation (default : 1)\nupdate_by_year::Int64: Rainflow SoH computation by year (default : 12)\nfatigue_data::DataFrames.DataFrame: DataFrame containing fatigue data (DoD, ncycle) (Default NMC battery data are provided)\n\nExample\n\nLiion_electro_chimique(update_by_year = 12, soc_model = \"linear\", couplage = (E=true, R=true))\n\n\n\n\n\n","category":"type"},{"location":"assets.html#Main.Genesys.Liion_fixed_lifetime","page":"Assets","title":"Main.Genesys.Liion_fixed_lifetime","text":"Liionfixedlifetime\n\nA mutable struct that represents a Li-ion battery model with a linear calendar aging for State of Health (SoH) computation.\n\nThe structure have a lot of parameters but most of them are set to default values.\n\nParameters:\n\nα_p_ch::Float64: Charging maximum C-rate (default : 1.5)\nα_p_dch::Float64: Discharging  maximum C-rate (default : 1.5)\nα_soc_min::Float64: Minimum threshold of charge (normalized) (default : 0.2)\nα_soc_max::Float64: Maximum threshold of charge (normalized) (default : 0.8)\nSoH_threshold::Float64: SoH level to replace the battery (default : 0.8)\ncouplage::NamedTuple: Named tuple with two boolean values to indicate if the SoH should influence the other parameters (E stand for capacity coupling and R for efficiency coupling)\nsoc_model::String: Model name for State of Charge (SoC) computation. Available models are listed \nsoc_ini::Float64: Initial State of Charge (SoC) for the beginning of the simulation (default : 0.5)\nsoh_ini::Float64: Initial State of Health (SoH) for the beginning of the simulation (default : 1)\n\nExample of usage : Liion_fixed_lifetime(;soc_model = \"polynomial\", couplage = (E=true, R=true))\n\n\n\n\n\n","category":"type"},{"location":"assets.html#Main.Genesys.Liion_energy_exchanged","page":"Assets","title":"Main.Genesys.Liion_energy_exchanged","text":"Liion_energy_exchanged\n\nA mutable struct that represents a Li-ion battery model Energy Throughput aging model for State of Health (SoH) computation.\n\nThe structure have a lot of parameters but most of them are set to default values.\n\nParameters:\n\nα_p_ch::Float64: Charging maximum C-rate (default : 1.5)\nα_p_dch::Float64: Discharging  maximum C-rate (default : 1.5)\nα_soc_min::Float64: Minimum threshold of charge (normalized) (default : 0.2)\nα_soc_max::Float64: Maximum threshold of charge (normalized) (default : 0.8)\nnCycle::Float64: Number of cycle before reaching EOL (should be found in the cycle to failure curve)\nSoH_threshold::Float64: SoH level to replace the battery (default : 0.8)\ncouplage::NamedTuple: Named tuple with two boolean values to indicate if the SoH should influence the other parameters (E stand for capacity coupling and R for efficiency coupling)\nsoc_model::String: Model name for State of Charge (SoC) computation. Available models are listed \ncalendar::Bool: Whether to include calendar aging in the SoH computation  (default : true)\nsoc_ini::Float64: Initial State of Charge (SoC) for the beginning of the simulation (default : 0.5)\nsoh_ini::Float64: Initial State of Health (SoH) for the beginning of the simulation (default : 1)\n\nExample \n\nLiion_energy_exchanged(;calendar = true, nCycle = fatigue_data.cycle[findfirst(fatigue_data.DoD .> (0.6))], soc_model = \"polynomial\", couplage = (E=true, R=true))\n\nHere the nCycle is selected from the cycle to failure curve using 60% DoD.\n\n\n\n\n\n","category":"type"},{"location":"assets.html#Thermal-Storage","page":"Assets","title":"Thermal Storage","text":"","category":"section"},{"location":"assets.html","page":"Assets","title":"Assets","text":"Genesys.ThermalStorage","category":"page"},{"location":"assets.html#Main.Genesys.ThermalStorage","page":"Assets","title":"Main.Genesys.ThermalStorage","text":"mutable struct ThermalStorage <: AbstractStorage\n\nA mutable struct representing a thermal energy storage model with various parameters, initial conditions, variables, and an inner constructor.\n\nParameters\n\nα_p_ch::Float64: Maximum charging power factor\nα_p_dch::Float64: Maximum discharging power factor\nη_ch::Float64: Charging efficiency\nη_dch::Float64: Discharging efficiency\nη_self::Float64: Self-discharge rate\nα_soc_min::Float64: Minimum state of charge factor\nα_soc_max::Float64: Maximum state of charge factor\nlifetime::Int64: Storage lifetime in years\nbounds::NamedTuple{(:lb, :ub), Tuple{Float64, Float64}}: Lower and upper bounds of storage capacity\nErated_ini::Float64: Initial rated storage energy capacity\nsoc_ini::Float64: Initial state of charge\nsoh_ini::Float64: Initial state of health\nErated::AbstractArray{Float64,2}: Rated storage energy capacity over time and scenarios\ncarrier::Heat: Heat carrier for the thermal storage\nsoc::AbstractArray{Float64,3}: State of charge over time, years, and scenarios\ncost::AbstractArray{Float64,2}: Cost of the thermal storage over time and scenarios\n\n\n\n\n\n","category":"type"},{"location":"assets.html#Hydrogen","page":"Assets","title":"Hydrogen","text":"","category":"section"},{"location":"assets.html","page":"Assets","title":"Assets","text":"Genesys.H2Tank","category":"page"},{"location":"assets.html#Main.Genesys.H2Tank","page":"Assets","title":"Main.Genesys.H2Tank","text":"mutable struct H2Tank  <: AbstractStorage\n\nA mutable struct representing a hydrogen tank storage model with various parameters, initial conditions, variables, and an inner constructor.\n\nParameters\n\nα_p_ch::Float64: Maximum charging power factor (default: 1.5)\nα_p_dch::Float64: Maximum discharging power factor (default: 1.5)\nη_ch::Float64: Charging efficiency (default: 1.0)\nη_dch::Float64: Discharging efficiency (default: 1.0)\nη_self::Float64: Self-discharge rate (default: 0.0)\nα_soc_min::Float64: Minimum state of charge factor (default: 0.0)\nα_soc_max::Float64: Maximum state of charge factor (default: 1.0)\nlifetime::Int64: Storage lifetime in years (default: 25)\nbounds::NamedTuple{(:lb, :ub), Tuple{Float64, Float64}}: Lower and upper bounds of storage capacity (default: (lb = 0., ub = 10000.))\nErated_ini::Float64: Initial rated storage energy capacity (default: 1e-6)\nsoc_ini::Float64: Initial state of charge (default: 0.5)\nsoh_ini::Float64: Initial state of health (default: 1.0)\nErated::AbstractArray{Float64,2}: Rated storage energy capacity over time and scenarios\ncarrier::Hydrogen: Hydrogen carrier for the H2 tank\nsoc::AbstractArray{Float64,3}: State of charge over time, years, and scenarios\ncost::AbstractArray{Float64,2}: Cost of the hydrogen storage over time and scenarios\n\n\n\n\n\n","category":"type"},{"location":"assets.html#Generation","page":"Assets","title":"Generation","text":"","category":"section"},{"location":"assets.html","page":"Assets","title":"Assets","text":"Genesys.Solar","category":"page"},{"location":"assets.html#Main.Genesys.Solar","page":"Assets","title":"Main.Genesys.Solar","text":"mutable struct Solar <: AbstractGeneration\n\nA mutable struct representing a solar power generation source. It contains information about the lifetime, bounds, initial conditions, variables, and costs related to the solar generation.\n\nParameters\n\n-lifetime::Int64 (default: 25): The lifetime of the solar power generation system. -bounds::NamedTuple{(:lb, :ub), Tuple{Float64, Float64}} (default: (lb = 0., ub = 1000.)): The lower and upper bounds of the solar power generation system. -powerMax_ini::Float64 (default: 0.): The initial maximum power output of the solar power generation system. -soh_ini::Float64 (default: 1.): The initial state of health of the solar power generation system.\n\n\n\n\n\n","category":"type"},{"location":"assets.html#Carrier","page":"Assets","title":"Carrier","text":"","category":"section"},{"location":"assets.html","page":"Assets","title":"Assets","text":"Genesys.EnergyCarrier\nGenesys.Electricity\nGenesys.Heat\nGenesys.Hydrogen","category":"page"},{"location":"assets.html#Main.Genesys.EnergyCarrier","page":"Assets","title":"Main.Genesys.EnergyCarrier","text":"EnergyCarrier\n\nAn abstract type representing an energy carrier (e.g., Main.Genesys.Electricity, Main.Genesys.Heat, Main.Genesys.Hydrogen).\n\n\n\n\n\n","category":"type"},{"location":"assets.html#Main.Genesys.Electricity","page":"Assets","title":"Main.Genesys.Electricity","text":"Electricity()\n\nA mutable struct representing electricity as an energy carrier. It is a subtype of EnergyCarrier.\n\nFields\n\npower::AbstractArray{Float64,3}: A 3-dimensional array of power values associated with electricity.\n\n\n\n\n\n","category":"type"},{"location":"assets.html#Main.Genesys.Heat","page":"Assets","title":"Main.Genesys.Heat","text":"Heat()\n\nA mutable struct representing heat as an energy carrier. It is a subtype of EnergyCarrier.\n\nFields\n\npower::AbstractArray{Float64,3}: A 3-dimensional array of power values associated with heat.\n\n\n\n\n\n","category":"type"},{"location":"assets.html#Main.Genesys.Hydrogen","page":"Assets","title":"Main.Genesys.Hydrogen","text":"Hydrogen()\n\nA mutable struct representing hydrogen as an energy carrier. It is a subtype of EnergyCarrier.\n\nFields\n\npower::AbstractArray{Float64,3}: A 3-dimensional array of power values associated with hydrogen.\n\n\n\n\n\n","category":"type"},{"location":"assets.html#Demand","page":"Assets","title":"Demand","text":"","category":"section"},{"location":"assets.html","page":"Assets","title":"Assets","text":"Genesys.Demand","category":"page"},{"location":"assets.html#Main.Genesys.Demand","page":"Assets","title":"Main.Genesys.Demand","text":"Demand(; carrier = Electricity())\n\nA mutable struct representing energy demand in the grid. The struct is a subtype of AbstractDemand.\n\nParameters\n\ncarrier::EnergyCarrier: The type of energy carrier for the demand (e.g., Electricity, Heat, etc.) this structre also contains the quantity for each timestamp. see Main.Genesys.EnergyCarrier\ntimestamp::Array{DateTime,3}: A 3-dimensional array of DateTime objects representing timestamps associated with the demand.\n\nExample\n\ndemand = Demand(carrier = Electricity())\n\n\n\n\n\n","category":"type"},{"location":"Examples.html#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"Examples.html#Table-of-Contents","page":"Examples","title":"Table of Contents","text":"","category":"section"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"Introduction\nGenerating Data Scenarios\nOptimizing and Simulating the Microgrid\nExtracting Metrics and Figures","category":"page"},{"location":"Examples.html#Introduction","page":"Examples","title":"Introduction","text":"","category":"section"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"This page provides example code snippets on how to use the main functionalities of our Julia package for modeling, optimizing and simulating microgrids. This package is designed to make it easy for users to design and analyze microgrid systems. The examples provided in this document cover the following key features:","category":"page"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"Generating data scenarios for simulation\nOptimizing and simulating the microgrid\nExtracting metrics and figures","category":"page"},{"location":"Examples.html#Generating-Data-Scenarios","page":"Examples","title":"Generating Data Scenarios","text":"","category":"section"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"In this section, we provide examples of how to generate data scenarios for the simulation of your microgrid system. These data scenarios will be used as input for the optimization and simulation processes.","category":"page"},{"location":"Examples.html","page":"Examples","title":"Examples","text":" #Example code: Generating data scenarios","category":"page"},{"location":"Examples.html#Optimizing-and-Simulating-the-Microgrid","page":"Examples","title":"Optimizing and Simulating the Microgrid","text":"","category":"section"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"Once you have generated the data scenarios for your microgrid system, you can optimize and simulate its performance using the functions provided in our package. In this section, we demonstrate how to perform optimization and simulation using the data scenarios created in the previous section.","category":"page"},{"location":"Examples.html#Constructing-the-grid","page":"Examples","title":"Constructing the grid","text":"","category":"section"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"The first step is to build the microgrid get the data and add assets to it. The following code show this process for the case of a single energy grid with battery storage and Solar panel over 21 years for 1 scenario. For more details about the assets see Assets page","category":"page"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"\nusing JLD, Dates\n\nconst nh, ny, ns = 8760, 21, 1 #nh = number of timestep per year, ny = time horizon (in years), ns = number of scenario used\n\ndata = load(joinpath(\"example\",\"data\",\"ausgrid_5_twostage.jld\")) #Get the data for scenarios \n\nmg = Microgrid(parameters = GlobalParameters(nh, ny, ns, renewable_share = 1.)) # Instantiate a Microgrid \n\n\nadd!(mg, Demand(carrier = Electricity()),\n                Solar(),\n                Liion_electro_chimique(),\n                Grid(carrier = Electricity())) # Add assets to it\n\nω_d = Scenarios(mg, data[\"ω_optim\"]) # Build the right number of scenarios with the right length for the microgrid\n","category":"page"},{"location":"Examples.html#Sizing-the-grid","page":"Examples","title":"Sizing the grid","text":"","category":"section"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"The sizing is performed by a component called designer. Several type of designer are implemented and their role is to determine the size of the asset. The simplest designer is the manual one where the user chose mannually the size of the assets. Other designer use optimization to provide a size, different optimization methods are implemented, exact and stochastic ones.","category":"page"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"Considering a grid mg, in order to determine the size of its assets, ","category":"page"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"one can use it's own design and use a Manual design.","category":"page"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"PV_size = 20.\nBAT_size = 40.                \ndesigner = initialize_designer!(mg, Manual(generations = [PV_size], storages = [BAT_size], subscribed_power = [5.]), ω_d)","category":"page"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"Manual design require a vector of values for the size of the generation assets, storage assets and grid assets.","category":"page"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"Other design methods can be used with the following code.","category":"page"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"#Code for using a opt desginer","category":"page"},{"location":"Examples.html#Operating-the-grid","page":"Examples","title":"Operating the grid","text":"","category":"section"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"To make the decisions during the simulation the grid need to be controlled. This role is taken by the Controller. A controller is going to operate the grid during the simulation, their is several type of controller implemented (Need to add reference or details) here. The simplest ones are Rule Based Controller RBC.  ","category":"page"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"controller = initialize_controller!(mg,  RBC(options = RBCOptions(policy_selection = 2 )), ω_d)","category":"page"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"More complexe controller using optimisation with varying range of sight can also be used.","category":"page"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"#Code for using a opt controller","category":"page"},{"location":"Examples.html#Extracting-Metrics-and-Figures","page":"Examples","title":"Extracting Metrics and Figures","text":"","category":"section"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"After optimizing and simulating your microgrid system, you may want to analyze its performance by extracting relevant metrics and creating visualizations. In this section, we provide examples of how to use our package to generate these metrics and figures.","category":"page"},{"location":"Examples.html","page":"Examples","title":"Examples","text":" #Example code: Generating Metrics and Figures","category":"page"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"Once you have completed the examples in this document, you should be familiar with the main functionalities of our Julia package for modeling, optimizing, and simulating microgrids. If you have any questions or need further assistance, please refer to our package documentation or contact us for support.","category":"page"},{"location":"index.html#Microgrid_Genesys.jl","page":"Microgrid_Genesys.jl","title":"Microgrid_Genesys.jl","text":"","category":"section"},{"location":"index.html","page":"Microgrid_Genesys.jl","title":"Microgrid_Genesys.jl","text":"A toolbox for modeling, optimizing and simulating microgrids developped by the Genesys team at LAPLACE laboratory, Toulouse, France","category":"page"},{"location":"index.html#Table-Of-Contents","page":"Microgrid_Genesys.jl","title":"Table Of Contents","text":"","category":"section"},{"location":"index.html","page":"Microgrid_Genesys.jl","title":"Microgrid_Genesys.jl","text":"","category":"page"},{"location":"index.html#Package-features","page":"Microgrid_Genesys.jl","title":"Package features","text":"","category":"section"},{"location":"index.html","page":"Microgrid_Genesys.jl","title":"Microgrid_Genesys.jl","text":"In this page, we'll provide an overview of the main components and features of the Genesys module.","category":"page"},{"location":"index.html#Main-Components","page":"Microgrid_Genesys.jl","title":"Main Components","text":"","category":"section"},{"location":"index.html","page":"Microgrid_Genesys.jl","title":"Microgrid_Genesys.jl","text":"The Genesys module includes the following main components:","category":"page"},{"location":"index.html","page":"Microgrid_Genesys.jl","title":"Microgrid_Genesys.jl","text":"Assets: Microgrid components, such as demand, solar, liion, thermal storage, and grid.\nScenarios: Tools for generating and reducing scenarios for simulations.\nOptimization: Design and operation optimization tools, including controllers and designers.\nSimulation: Functions for simulating microgrids over different time horizons and scenarios.\nUtils: Utilities for metrics, plotting, and data saving.","category":"page"},{"location":"index.html#Key-Features","page":"Microgrid_Genesys.jl","title":"Key Features","text":"","category":"section"},{"location":"index.html","page":"Microgrid_Genesys.jl","title":"Microgrid_Genesys.jl","text":"The Genesys module offers a wide range of features for microgrid simulations and optimizations:","category":"page"},{"location":"index.html","page":"Microgrid_Genesys.jl","title":"Microgrid_Genesys.jl","text":"A flexible and extensible structure that allows for the incorporation of different asset types, descriptive models and optimization algorithms.\nA comprehensive set of optimization tools, including dummy, anticipative, rule-based control, and online learning for frequency control.\nScenario generation and reduction techniques for efficient and accurate simulations.\nBuilt-in plotting and metrics utilities for easy analysis and visualization of results.","category":"page"},{"location":"index.html","page":"Microgrid_Genesys.jl","title":"Microgrid_Genesys.jl","text":"To learn more about how to use the Genesys module, please refer to the other pages in this documentation. To learn to use the key features of this module please refer to the example page.","category":"page"}]
}
