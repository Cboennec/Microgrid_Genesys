var documenterSearchIndex = {"docs":
[{"location":"Tutorials/3-Component.html#Component-model-and-data-structures","page":"Component model and data structures","title":"Component model and data structures","text":"","category":"section"},{"location":"Tutorials/3-Component.html#CM-(2h)","page":"Component model and data structures","title":"CM (2h)","text":"","category":"section"},{"location":"Tutorials/3-Component.html","page":"Component model and data structures","title":"Component model and data structures","text":"présentation de l'architechture ","category":"page"},{"location":"Tutorials/3-Component.html","page":"Component model and data structures","title":"Component model and data structures","text":"Abstract storage, converter, generation et leur paramètre centraux associés (eta, SoC, SoH...)","category":"page"},{"location":"Tutorials/3-Component.html","page":"Component model and data structures","title":"Component model and data structures","text":"Présentation des tableaux interne de données et la centralisation sur le microgrid.","category":"page"},{"location":"Tutorials/3-Component.html","page":"Component model and data structures","title":"Component model and data structures","text":"Présentation des modèles qui régissent cela avec l'exemple de la batterie.","category":"page"},{"location":"Tutorials/3-Component.html","page":"Component model and data structures","title":"Component model and data structures","text":"Explication sur la différence entre une intégration dans l'opti et dans la simulation (par exemple en simulation on peut utiliser RB avec n'importe quel model)","category":"page"},{"location":"Tutorials/3-Component.html","page":"Component model and data structures","title":"Component model and data structures","text":"Exemple de choix de modèle et leurs implications","category":"page"},{"location":"Tutorials/3-Component.html","page":"Component model and data structures","title":"Component model and data structures","text":"Paramètrage","category":"page"},{"location":"Tutorials/3-Component.html#TP-(4h)","page":"Component model and data structures","title":"TP (4h)","text":"","category":"section"},{"location":"Tutorials/3-Component.html#Model-selection","page":"Component model and data structures","title":"Model selection","text":"","category":"section"},{"location":"Tutorials/3-Component.html","page":"Component model and data structures","title":"Component model and data structures","text":"exercice sur la séléction de modèle et comparaison des implications","category":"page"},{"location":"Tutorials/3-Component.html","page":"Component model and data structures","title":"Component model and data structures","text":"exercice sur le paramètrage","category":"page"},{"location":"Tutorials/3-Component.html#How-to-implement-a-new-one","page":"Component model and data structures","title":"How to implement a new one","text":"","category":"section"},{"location":"Tutorials/3-Component.html","page":"Component model and data structures","title":"Component model and data structures","text":"Tutoriel sur les éléments à changer pour inserer un nouveau model au package.","category":"page"},{"location":"Tutorials/3-Component.html","page":"Component model and data structures","title":"Component model and data structures","text":"Description d'un nouveau modèle ","category":"page"},{"location":"Tutorials/3-Component.html","page":"Component model and data structures","title":"Component model and data structures","text":"Exercice d'ajout d'un nouveau modèle","category":"page"},{"location":"assets.html#Assets","page":"Assets","title":"Assets","text":"","category":"section"},{"location":"assets.html#Storages","page":"Assets","title":"Storages","text":"","category":"section"},{"location":"assets.html#Batteries","page":"Assets","title":"Batteries","text":"","category":"section"},{"location":"assets.html","page":"Assets","title":"Assets","text":"Genesys.AbstractLiion\nGenesys.Liion_rainflow\nGenesys.Liion_electro_chimique\nGenesys.Liion_fixed_lifetime\nGenesys.Liion_energy_exchanged","category":"page"},{"location":"assets.html#Main.Genesys.AbstractLiion","page":"Assets","title":"Main.Genesys.AbstractLiion","text":"abstract type AbstractLiion <: AbstractStorage\n\nAn abstract type to generalize every Liion battery storage solution\n\n\n\n\n\n","category":"type"},{"location":"assets.html#Main.Genesys.Liion_rainflow","page":"Assets","title":"Main.Genesys.Liion_rainflow","text":"Liion_rainflow\n\nA mutable struct that represents a Li-ion battery model with rainflow counting algorithm for State of Health (SoH) computation.\n\nThe structure have a lot of parameters but most of them are set to default values.\n\nParameters:\n\nα_p_ch::Float64: Charging maximum C-rate (default : 1.5)\nα_p_dch::Float64: Discharging  maximum C-rate (default : 1.5)\nα_soc_min::Float64: Minimum threshold of charge (normalized) (default : 0.2)\nα_soc_max::Float64: Maximum threshold of charge (normalized) (default : 0.8)\nSoH_threshold::Float64: SoH level to replace the battery (default : 0.8)\ncouplage::NamedTuple: Named tuple with two boolean values to indicate if the SoH should influence the other parameters (E stand for capacity coupling and R for efficiency coupling)\nsoc_model::String: Model name for State of Charge (SoC) computation. Available models are listed \ncalendar::Bool: Whether to include calendar aging in the SoH computation  (default : true)\nsoc_ini::Float64: Initial State of Charge (SoC) for the beginning of the simulation (default : 0.5)\nsoh_ini::Float64: Initial State of Health (SoH) for the beginning of the simulation (default : 1)\nupdate_by_year::Int64: Rainflow SoH computation by year (default : 12)\nfatigue_data::DataFrames.DataFrame: DataFrame containing fatigue data (DoD, ncycle) (Default NMC battery data are provided)\n\nexample\n\nLiion_rainflow(update_by_year = 12, calendar = true, soc_model = \"linear\", couplage = (E=true, R=true))\n\n\n\n\n\n","category":"type"},{"location":"assets.html#Main.Genesys.Liion_electro_chimique","page":"Assets","title":"Main.Genesys.Liion_electro_chimique","text":"Liion_electro_chimique\n\nA mutable struct that represents a Li-ion battery aging model for State of Health (SoH) computation. This model is detailled in B. Xu et al. \"Modeling of Lithium-Ion Battery Degradation for Cell Life Assessment,\"  doi : 10.1109/TSG.2016.2578950, link.\n\nThe structure have a lot of parameters but most of them are set to default values.\n\nParameters:\n\nα_p_ch::Float64: Charging maximum C-rate (default : 1.5)\nα_p_dch::Float64: Discharging  maximum C-rate (default : 1.5)\nα_soc_min::Float64: Minimum threshold of charge (normalized) (default : 0.2)\nα_soc_max::Float64: Maximum threshold of charge (normalized) (default : 0.8)\nSoH_threshold::Float64: SoH level to replace the battery (default : 0.8)\ncouplage::NamedTuple: Named tuple with two boolean values to indicate if the SoH should influence the other parameters (E stand for capacity coupling and R for efficiency coupling)\ntemperature::Float64: Temperature of the battery (no temprature model is implemented for the battery).\nsoc_model::String: Model name for State of Charge (SoC) computation. Available models are listed \ncalendar::Bool: Whether to include calendar aging in the SoH computation  (default : true)\nsoc_ini::Float64: Initial State of Charge (SoC) for the beginning of the simulation (default : 0.5)\nsoh_ini::Float64: Initial State of Health (SoH) for the beginning of the simulation (default : 1)\nupdate_by_year::Int64: Rainflow SoH computation by year (default : 12)\nfatigue_data::DataFrames.DataFrame: DataFrame containing fatigue data (DoD, ncycle) (Default NMC battery data are provided)\n\nExample\n\nLiion_electro_chimique(update_by_year = 12, soc_model = \"linear\", couplage = (E=true, R=true))\n\n\n\n\n\n","category":"type"},{"location":"assets.html#Main.Genesys.Liion_fixed_lifetime","page":"Assets","title":"Main.Genesys.Liion_fixed_lifetime","text":"Liionfixedlifetime\n\nA mutable struct that represents a Li-ion battery model with a linear calendar aging for State of Health (SoH) computation.\n\nThe structure have a lot of parameters but most of them are set to default values.\n\nParameters:\n\nα_p_ch::Float64: Charging maximum C-rate (default : 1.5)\nα_p_dch::Float64: Discharging  maximum C-rate (default : 1.5)\nα_soc_min::Float64: Minimum threshold of charge (normalized) (default : 0.2)\nα_soc_max::Float64: Maximum threshold of charge (normalized) (default : 0.8)\nSoH_threshold::Float64: SoH level to replace the battery (default : 0.8)\ncouplage::NamedTuple: Named tuple with two boolean values to indicate if the SoH should influence the other parameters (E stand for capacity coupling and R for efficiency coupling)\nsoc_model::String: Model name for State of Charge (SoC) computation. Available models are listed \nsoc_ini::Float64: Initial State of Charge (SoC) for the beginning of the simulation (default : 0.5)\nsoh_ini::Float64: Initial State of Health (SoH) for the beginning of the simulation (default : 1)\n\nExample\n\nLiion_fixed_lifetime(;soc_model = \"polynomial\", couplage = (E=true, R=true))\n\n\n\n\n\n","category":"type"},{"location":"assets.html#Main.Genesys.Liion_energy_exchanged","page":"Assets","title":"Main.Genesys.Liion_energy_exchanged","text":"Liion_energy_exchanged\n\nA mutable struct that represents a Li-ion battery model Energy Throughput aging model for State of Health (SoH) computation.\n\nThe structure have a lot of parameters but most of them are set to default values.\n\nParameters:\n\nα_p_ch::Float64: Charging maximum C-rate (default : 1.5)\nα_p_dch::Float64: Discharging  maximum C-rate (default : 1.5)\nα_soc_min::Float64: Minimum threshold of charge (normalized) (default : 0.2)\nα_soc_max::Float64: Maximum threshold of charge (normalized) (default : 0.8)\nnCycle::Float64: Number of cycle before reaching EOL (should be found in the cycle to failure curve)\nSoH_threshold::Float64: SoH level to replace the battery (default : 0.8)\ncouplage::NamedTuple: Named tuple with two boolean values to indicate if the SoH should influence the other parameters (E stand for capacity coupling and R for efficiency coupling)\nsoc_model::String: Model name for State of Charge (SoC) computation. Available models are listed \ncalendar::Bool: Whether to include calendar aging in the SoH computation  (default : true)\nsoc_ini::Float64: Initial State of Charge (SoC) for the beginning of the simulation (default : 0.5)\nsoh_ini::Float64: Initial State of Health (SoH) for the beginning of the simulation (default : 1)\n\nExample\n\nLiion_energy_exchanged(;calendar = true, nCycle = fatigue_data.cycle[findfirst(fatigue_data.DoD .> (0.6))], soc_model = \"polynomial\", couplage = (E=true, R=true))\n\nHere the nCycle is selected from the cycle to failure curve using 60% DoD.\n\n\n\n\n\n","category":"type"},{"location":"assets.html#Thermal-Storage","page":"Assets","title":"Thermal Storage","text":"","category":"section"},{"location":"assets.html","page":"Assets","title":"Assets","text":"Genesys.ThermalStorage","category":"page"},{"location":"assets.html#Main.Genesys.ThermalStorage","page":"Assets","title":"Main.Genesys.ThermalStorage","text":"mutable struct ThermalStorage <: AbstractStorage\n\nA mutable struct representing a thermal energy storage model with various parameters, initial conditions, variables, and an inner constructor.\n\nParameters\n\nα_p_ch::Float64: Maximum charging power factor\nα_p_dch::Float64: Maximum discharging power factor\nη_ch::Float64: Charging efficiency\nη_dch::Float64: Discharging efficiency\nη_self::Float64: Self-discharge rate\nα_soc_min::Float64: Minimum state of charge factor\nα_soc_max::Float64: Maximum state of charge factor\nlifetime::Int64: Storage lifetime in years\nbounds::NamedTuple{(:lb, :ub), Tuple{Float64, Float64}}: Lower and upper bounds of storage capacity\nErated_ini::Float64: Initial rated storage energy capacity\nsoc_ini::Float64: Initial state of charge\nsoh_ini::Float64: Initial state of health\nErated::AbstractArray{Float64,2}: Rated storage energy capacity over time and scenarios\ncarrier::Heat: Heat carrier for the thermal storage\nsoc::AbstractArray{Float64,3}: State of charge over time, years, and scenarios\ncost::AbstractArray{Float64,2}: Cost of the thermal storage over time and scenarios\n\n\n\n\n\n","category":"type"},{"location":"assets.html#Hydrogen","page":"Assets","title":"Hydrogen","text":"","category":"section"},{"location":"assets.html","page":"Assets","title":"Assets","text":"Genesys.H2Tank","category":"page"},{"location":"assets.html#Main.Genesys.H2Tank","page":"Assets","title":"Main.Genesys.H2Tank","text":"mutable struct H2Tank <: AbstractStorage\n\nA mutable struct representing a hydrogen tank storage model with various parameters, initial conditions, variables, and an inner constructor.\n\nParameters\n\nα_p_ch::Float64: Maximum charging power factor (default: 1.5)\nα_p_dch::Float64: Maximum discharging power factor (default: 1.5)\nη_ch::Float64: Charging efficiency (default: 1.0)\nη_dch::Float64: Discharging efficiency (default: 1.0)\nη_self::Float64: Self-discharge rate (default: 0.0)\nα_soc_min::Float64: Minimum state of charge factor (default: 0.0)\nα_soc_max::Float64: Maximum state of charge factor (default: 1.0)\nlifetime::Int64: Storage lifetime in years (default: 25)\nbounds::NamedTuple{(:lb, :ub), Tuple{Float64, Float64}}: Lower and upper bounds of storage capacity (default: (lb = 0., ub = 10000.))\nErated_ini::Float64: Initial rated storage energy capacity (default: 1e-6)\nsoc_ini::Float64: Initial state of charge (default: 0.5)\nsoh_ini::Float64: Initial state of health (default: 1.0)\nErated::AbstractArray{Float64,2}: Rated storage energy capacity over time and scenarios\ncarrier::Hydrogen: Hydrogen carrier for the H2 tank\nsoc::AbstractArray{Float64,3}: State of charge over time, years, and scenarios\ncost::AbstractArray{Float64,2}: Cost of the hydrogen storage over time and scenarios\n\n\n\n\n\n","category":"type"},{"location":"assets.html#Generation","page":"Assets","title":"Generation","text":"","category":"section"},{"location":"assets.html","page":"Assets","title":"Assets","text":"Genesys.Solar","category":"page"},{"location":"assets.html#Main.Genesys.Solar","page":"Assets","title":"Main.Genesys.Solar","text":"mutable struct Solar <: AbstractGeneration\n\nA mutable struct representing a solar power generation source. It contains information about the lifetime, bounds, initial conditions, variables, and costs related to the solar generation.\n\nParameters\n\n-lifetime::Int64 (default: 25): The lifetime of the solar power generation system. -bounds::NamedTuple{(:lb, :ub), Tuple{Float64, Float64}} (default: (lb = 0., ub = 1000.)): The lower and upper bounds of the solar power generation system. -powerMax_ini::Float64 (default: 0.): The initial maximum power output of the solar power generation system. -soh_ini::Float64 (default: 1.): The initial state of health of the solar power generation system.\n\n\n\n\n\n","category":"type"},{"location":"assets.html#Carrier","page":"Assets","title":"Carrier","text":"","category":"section"},{"location":"assets.html","page":"Assets","title":"Assets","text":"Genesys.EnergyCarrier\nGenesys.Electricity\nGenesys.Heat\nGenesys.Hydrogen","category":"page"},{"location":"assets.html#Main.Genesys.EnergyCarrier","page":"Assets","title":"Main.Genesys.EnergyCarrier","text":"EnergyCarrier\n\nAn abstract type representing an energy carrier (e.g., Main.Genesys.Electricity, Main.Genesys.Heat, Main.Genesys.Hydrogen).\n\n\n\n\n\n","category":"type"},{"location":"assets.html#Main.Genesys.Electricity","page":"Assets","title":"Main.Genesys.Electricity","text":"Electricity\n\nA mutable struct representing electricity as an energy carrier. It is a subtype of EnergyCarrier.\n\nFields\n\npower::AbstractArray{Float64,3}: A 3-dimensional array of power values associated with electricity.\n\nExample\n\nElectricity()\n\n\n\n\n\n","category":"type"},{"location":"assets.html#Main.Genesys.Heat","page":"Assets","title":"Main.Genesys.Heat","text":"Heat\n\nA mutable struct representing heat as an energy carrier. It is a subtype of EnergyCarrier.\n\nFields\n\npower::AbstractArray{Float64,3}: A 3-dimensional array of power values associated with heat.\n\nExample\n\nHeat()\n\n\n\n\n\n","category":"type"},{"location":"assets.html#Main.Genesys.Hydrogen","page":"Assets","title":"Main.Genesys.Hydrogen","text":"Hydrogen\n\nA mutable struct representing hydrogen as an energy carrier. It is a subtype of EnergyCarrier.\n\nFields\n\npower::AbstractArray{Float64,3}: A 3-dimensional array of power values associated with hydrogen.\n\nHydrogen()\n\n\n\n\n\n","category":"type"},{"location":"assets.html#Converter","page":"Assets","title":"Converter","text":"","category":"section"},{"location":"assets.html","page":"Assets","title":"Assets","text":"Genesys.Electrolyzer\nGenesys.FuelCell\nGenesys.Heater","category":"page"},{"location":"assets.html#Main.Genesys.Electrolyzer","page":"Assets","title":"Main.Genesys.Electrolyzer","text":"mutable struct Electrolyzer <: AbstractConverter\n\nA mutable struct representing an Electrolyzer, which is a subtype of AbstractConverter.\n\nParameters\n\nα_p::Float64: The performance degradation factor.\nη_E_H2::Float64: The conversion efficiency of electricity to hydrogen.\nη_E_H::Float64: The conversion efficiency of electricity to heat.\nlifetime::Int64: The expected lifetime of the electrolyzer (in years).\nnHoursMax::Float64: The maximum number of operational hours for the electrolyzer.\nbounds::NamedTuple{(:lb, :ub), Tuple{Float64, Float64}}: The lower and upper bounds of the electrolyzer's power.\n\nInitial conditions\n\npowerMax_ini::Float64: The initial maximum power output of the electrolyzer.\nsoh_ini::Float64: The initial state of health of the electrolyzer.\n\nVariables\n\npowerMax::AbstractArray{Float64,2}: The maximum power output of the electrolyzer.\ncarrier::Vector{EnergyCarrier}: The vector of energy carriers associated with the electrolyzer.\nsoh::AbstractArray{Float64,3}: The state of health of the electrolyzer.\n\nEco\n\ncost::AbstractArray{Float64,2}: The cost associated with the electrolyzer.\n\nExample\n\nelectrolyzer = Electrolyzer(α_p=0.05, η_E_H2=0.5, η_E_H=0.3, lifetime=15, nHoursMax=26000.0, bounds=(lb=0.0, ub=50.0), powerMax_ini=0.0, soh_ini=1.0)\n\n\n\n\n\n","category":"type"},{"location":"assets.html#Main.Genesys.FuelCell","page":"Assets","title":"Main.Genesys.FuelCell","text":"mutable struct FuelCell <: AbstractConverter\n\nA mutable struct representing a FuelCell, which is a subtype of AbstractConverter.\n\nParameters\n\nα_p::Float64: The performance degradation factor.\nη_H2_E::Float64: The conversion efficiency of hydrogen to electricity.\nη_H2_H::Float64: The conversion efficiency of hydrogen to heat.\nlifetime::Int64: The expected lifetime of the fuel cell (in years).\nnHoursMax::Float64: The maximum number of operational hours for the fuel cell.\nbounds::NamedTuple{(:lb, :ub), Tuple{Float64, Float64}}: The lower and upper bounds of the fuel cell's power.\n\nInitial conditions\n\npowerMax_ini::Float64: The initial maximum power output of the fuel cell.\nsoh_ini::Float64: The initial state of health of the fuel cell.\n\nVariables\n\npowerMax::AbstractArray{Float64,2}: The maximum power output of the fuel cell.\ncarrier::Vector{EnergyCarrier}: The vector of energy carriers associated with the fuel cell.\nsoh::AbstractArray{Float64,3}: The state of health of the fuel cell.\n\nEco\n\ncost::AbstractArray{Float64,2}: The cost associated with the fuel cell.\n\nExample\n\nfuel_cell = FuelCell(α_p=0.08, η_H2_E=0.4, η_H2_H=0.4, lifetime=14, nHoursMax=10000.0, bounds=(lb=0.0, ub=50.0), powerMax_ini=0.0, soh_ini=1.0)\n\n\n\n\n\n","category":"type"},{"location":"assets.html#Main.Genesys.Heater","page":"Assets","title":"Main.Genesys.Heater","text":"mutable struct Heater <: AbstractConverter\n\nA mutable struct representing a Heater, which is a subtype of AbstractConverter.\n\nParameters\n\nη_E_H::Float64: The conversion efficiency of the heater.\nlifetime::Int64: The expected lifetime of the heater (in years).\nbounds::NamedTuple{(:lb, :ub), Tuple{Float64, Float64}}: The lower and upper bounds of the heater's power.\npowerMax_ini::Float64: The initial maximum power output of the heater.\nsoh_ini::Float64: The initial state of health of the heater.\n\nVariables\n\npowerMax::AbstractArray{Float64,2}: The maximum power output of the heater.\ncarrier::Vector{Any}: The carrier vector.\ncost::AbstractArray{Float64,2}: The cost associated with the heater.\n\nExample\n\nheater = Heater(η_E_H=1.0, lifetime=25, bounds=(lb=30.0, ub=30.0), powerMax_ini=30.0, soh_ini=1.0)\n\n\n\n\n\n","category":"type"},{"location":"assets.html#Demand","page":"Assets","title":"Demand","text":"","category":"section"},{"location":"assets.html","page":"Assets","title":"Assets","text":"Genesys.Demand","category":"page"},{"location":"assets.html#Main.Genesys.Demand","page":"Assets","title":"Main.Genesys.Demand","text":"Demand(; carrier = Electricity())\n\nA mutable struct representing energy demand in the grid. The struct is a subtype of AbstractDemand.\n\nParameters\n\ncarrier::EnergyCarrier: The type of energy carrier for the demand (e.g., Electricity, Heat, etc.) this structre also contains the quantity for each timestamp. see Main.Genesys.EnergyCarrier\ntimestamp::Array{DateTime,3}: A 3-dimensional array of DateTime objects representing timestamps associated with the demand.\n\nExample\n\ndemand = Demand(carrier = Electricity())\n\n\n\n\n\n","category":"type"},{"location":"assets.html#grid","page":"Assets","title":"grid","text":"","category":"section"},{"location":"assets.html","page":"Assets","title":"Assets","text":"Genesys.Microgrid","category":"page"},{"location":"assets.html#Main.Genesys.Microgrid","page":"Assets","title":"Main.Genesys.Microgrid","text":"Microgrid()\n\nStructure containing every element of the grid including immaterial ones like electrical  demands.\n\nThose elements are divided in 5 types and stored in 5 vectors with one field for each element of a type :\n\ndemands inheriting from AbstractDemand and containing a demand for each energy (Electricity and Heat);\ngenerations inheriting from AbstractGeneration and containing energy \n\nproduction/generation assets;\n\nstorages inheriting from AbstractStorage and containing energy storage assets;\nconverters inheriting from AbstractConverter and containing energy convertion assets;\ngrids inheriting from AbstractGrid and containing energy market assets \n\n(usually an external grid from which can be bought and sold energy);\n\nThese assets can be later added with the add!(mg::Microgrid, assets...)  See also Main.Genesys.add! for a step by step declaration\n\n\n\n\n\n","category":"type"},{"location":"Examples.html#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"Examples.html#Table-of-Contents","page":"Examples","title":"Table of Contents","text":"","category":"section"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"Introduction\nGenerating Data Scenarios\nOptimizing and Simulating the Microgrid\nExtracting Metrics and Figures","category":"page"},{"location":"Examples.html#Introduction","page":"Examples","title":"Introduction","text":"","category":"section"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"This page provides example code snippets on how to use the main functionalities of our Julia package for modeling, optimizing and simulating microgrids. This package is designed to make it easy for users to design and analyze microgrid systems. The examples provided in this document cover the following key features:","category":"page"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"Generating data scenarios for simulation\nOptimizing and simulating the microgrid\nExtracting metrics and figures","category":"page"},{"location":"Examples.html#Generating-Data-Scenarios","page":"Examples","title":"Generating Data Scenarios","text":"","category":"section"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"In this section, we provide examples of how to generate data scenarios for the simulation of your microgrid system. These data scenarios will be used as input for the optimization and simulation processes.","category":"page"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"We here present two ways of generating scenarios :  A first way is to take directly the data from the Ausgrid dataset and for each client, each year create a scenario.  A second way is to build profils using a stochastic process detailed in this article.","category":"page"},{"location":"Examples.html#Deterministic-generation","page":"Examples","title":"Deterministic generation","text":"","category":"section"},{"location":"Examples.html","page":"Examples","title":"Examples","text":" # Import necessary libraries\nusing JLD, Dates, Seaborn\n\n# Include supplementary functions\ninclude(\"functions.jl\")\n\n# Define global constants\n# nh: number of hours in a year\n# ny: number of years to simulate\n# ns: number of scenarios to generate\nconst nh, ny, ns = 8760, 2, 60\n\n# Load data for Ausgrid network for the years 2010, 2011, 2012\ndata_2010 = load(joinpath(\"Examples\",\"build_scenarios\", \"data\", \"clean_dataset_ausgrid_2010_2011.jld\"), \"clean_dataset\")\ndata_2011 = load(joinpath(\"Examples\",\"build_scenarios\", \"data\", \"clean_dataset_ausgrid_2011_2012.jld\"), \"clean_dataset\")\ndata_2012 = load(joinpath(\"Examples\",\"build_scenarios\", \"data\", \"clean_dataset_ausgrid_2012_2013.jld\"), \"clean_dataset\")\n\n# Identify customers who have data for all three years\ncustomers = [k for k in keys(data_2010) if k in keys(data_2011) && k in keys(data_2012)]\n\n# Initialize empty arrays for Photovoltaic (PV) production, Electric Load (ld_E) and Heat Load (ld_H)\n_pv, _ld_E, _ld_H = [], [], []\n\n# Set up date format to be used\ndateformat = Dates.DateFormat(\"dd-u-yyyy\")\n\n# Loop over each customer and collect their data for all three years\nfor c in customers[1:20]\n    # Collect and format data for Electric Load\n    push!(_ld_E, (t = hcat(Dates.DateTime.(data_2010[c][\"GC\"][\"time\"][1:nh], dateformat), Dates.DateTime.(data_2011[c][\"GC\"][\"time\"][1:nh], dateformat), Dates.DateTime.(data_2012[c][\"GC\"][\"time\"][1:nh], dateformat)),\n            power = hcat(data_2010[c][\"GC\"][\"power\"][1:nh], data_2011[c][\"GC\"][\"power\"][1:nh], data_2012[c][\"GC\"][\"power\"][1:nh])))\n\n    # Collect and format data for Heat Load\n    push!(_ld_H, (t = hcat(Dates.DateTime.(data_2010[c][\"CL\"][\"time\"][1:nh], dateformat), Dates.DateTime.(data_2011[c][\"CL\"][\"time\"][1:nh], dateformat), Dates.DateTime.(data_2012[c][\"CL\"][\"time\"][1:nh], dateformat)),\n            power = hcat(data_2010[c][\"CL\"][\"power\"][1:nh], data_2011[c][\"CL\"][\"power\"][1:nh], data_2012[c][\"CL\"][\"power\"][1:nh])))\n\n    # Collect and format data for PV Production\n    push!(_pv, (t = hcat(Dates.DateTime.(data_2010[c][\"GG\"][\"time\"][1:nh], dateformat), Dates.DateTime.(data_2011[c][\"GG\"][\"time\"][1:nh], dateformat), Dates.DateTime.(data_2012[c][\"GG\"][\"time\"][1:nh], dateformat)),\n            power = hcat(data_2010[c][\"GG\"][\"power\"][1:nh], data_2011[c][\"GG\"][\"power\"][1:nh], data_2012[c][\"GG\"][\"power\"][1:nh])))\nend\n\n# Format data to be compatible with Genesys simulation system\ntimestamp = repeat(reshape(hcat([p.tfor p in _pv]...), nh, 1, ns), 1, ny, 1)\npv = repeat(reshape(hcat([p.power for p in _pv]...), nh, 1, ns), 1, ny, 1)\nld_E = repeat(reshape(hcat([ld.power for ld in _ld_E]...), nh, 1, ns), 1, ny, 1)\nld_H = repeat(reshape(hcat([ld.power for ld in _ld_H]...), nh, 1, ns), 1, ny, 1)\n\n# Define scenarios with costs\nω = Dict(\n    \"pv\" => (t = timestamp, power = pv, cost = 1300 * ones(ny, ns)),  # Scenario for PV with timestamp, power and cost\n    \"ld_E\" => (t = timestamp, power = ld_E),  # Scenario for Electric Load with timestamp and power\n    \"ld_H\" => (t = timestamp, power = ld_H),  # Scenario for Heat Load with timestamp and power\n    \"liion\" => (cost = 300 * ones(ny, ns),),  # Scenario for Lithium-ion batteries with cost\n    \"tes\" => (cost = 10 * ones(ny, ns),),  # Scenario for Thermal Energy Storage with cost\n    \"h2tank\" => (cost = 10 * ones(ny, ns),),  # Scenario for Hydrogen Storage Tank with cost\n    \"elyz\" => (cost = 1300 * ones(ny, ns),),  # Scenario for Electrolyzer with cost\n    \"fc\" => (cost = 1700 * ones(ny, ns),),  # Scenario for Fuel Cell with cost\n    \"heater\" => (cost = 0 * ones(ny, ns),),  # Scenario for Heater with cost\n    \"grid\" => (cost_in = 0.19 * ones(nh, ny, ns), cost_out = 0.0001 * ones(nh, ny, ns)),  # Scenario for Grid with cost_in and cost_out\n)\n\n# Save scenarios as .jld files\nsave(joinpath(\"data\", \"ausgrid_deterministic.jld\"), \"ω\", ω)","category":"page"},{"location":"Examples.html#Stochastic-generation","page":"Examples","title":"Stochastic generation","text":"","category":"section"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"include(\"..\\\\src\\\\Genesys.jl\")\n\nusing Main.Genesys\nusing Distributions, CSV, JLD, Dates, Seaborn, Statistics, ProgressMeter\n\n# Global constants\nconst nh, ny, ns = 8760, 1, 2000\n\n# Load data related to multiple clients over 3 years\ndata_2010 = load(joinpath(\"stage_scenario\", \"data\", \"clean_dataset_ausgrid_2010_2011.jld\"), \"clean_dataset\")\ndata_2011 = load(joinpath(\"stage_scenario\", \"data\", \"clean_dataset_ausgrid_2011_2012.jld\"), \"clean_dataset\")\ndata_2012 = load(joinpath(\"stage_scenario\", \"data\", \"clean_dataset_ausgrid_2012_2013.jld\"), \"clean_dataset\")\n\n# Find customers with 3 years of data\ncustomers = [k for k in keys(data_2010) if k in keys(data_2011) && k in keys(data_2012)]\n\n# Initialize\ndateformat = Dates.DateFormat(\"dd-u-yyyy\")\n_pv, _ld_E, _ld_H = [], [], []\ns0 = [0., 0., 0.]\nt0 = DateTime(2020,7,1,0)\n\n# For each customer with 3 years of data, we use the data to create three time series (photovoltaic production, electric consumption, heat consumption)\n# These time series are used to construct the states and probabilities of the Markov chains using the \"generator\"\n# We then use this generator to produce a set of ns scenarios at an hourly timestep using \"generate\"\n# The generated scenarios are stored in three lists (_pv, _ld_E, _ld_H)\n\n@showprogress for c in custumers[1:20]\n        # Retrieve the scenario\n        ld_E = (t = hcat(Dates.DateTime.(data_2010[c][\"GC\"][\"time\"][1:nh], dateformat), Dates.DateTime.(data_2011[c][\"GC\"][\"time\"][1:nh], dateformat), Dates.DateTime.(data_2012[c][\"GC\"][\"time\"][1:nh], dateformat)),\n                power = hcat(data_2010[c][\"GC\"][\"power\"][1:nh], data_2011[c][\"GC\"][\"power\"][1:nh], data_2012[c][\"GC\"][\"power\"][1:nh]))\n\n        ld_H = (t = hcat(Dates.DateTime.(data_2010[c][\"CL\"][\"time\"][1:nh], dateformat), Dates.DateTime.(data_2011[c][\"CL\"][\"time\"][1:nh], dateformat), Dates.DateTime.(data_2012[c][\"CL\"][\"time\"][1:nh], dateformat)),\n                power = hcat(data_2010[c][\"CL\"][\"power\"][1:nh], data_2011[c][\"CL\"][\"power\"][1:nh], data_2012[c][\"CL\"][\"power\"][1:nh]))\n\n        pv = (t = hcat(Dates.DateTime.(data_2010[c][\"GG\"][\"time\"][1:nh], dateformat), Dates.DateTime.(data_2011[c][\"GG\"][\"time\"][1:nh], dateformat), Dates.DateTime.(data_2012[c][\"GG\"][\"time\"][1:nh], dateformat)),\n                power = hcat(data_2010[c][\"GG\"][\"power\"][1:nh], data_2011[c][\"GG\"][\"power\"][1:nh], data_2012[c][\"GG\"][\"power\"][1:nh]))\n\n        # Initialize generator\n        generator = Genesys.initialize_generator!(MarkovGenerator(nstate = 20, algo = \"kmeans\"), pv, ld_E, ld_H)\n\n        # Generate\n        ω, proba = Genesys.generate(generator, s0, t0, nh, ny = ny, ns = ns)\n\n        # Store\n        push!(_pv, ω[1])\n        push!(_ld_E, ω[2])\n        push!(_ld_H, ω[3])\nend\n\n# After generating these time series, we will create scenarios for our case study\n# First by aggregating the consumption data to create a case of 5 consumers\n# Then by adding certain elements including pricing which will be necessary for our metrics\n# Finally, we will store all these elements in two dictionaries, one for sizing and one for analysis (resp. optim, simu)\n# These dictionaries will then be saved under the labels ω_optim and ω_simu\n\n\n# Aggregation\n# Randomly chose 5 among the 20 availables\nidx = rand(1:20, 5, ns)\n# Aggregate except for PV\npv = _pv[1]\nld_E = reshape(hcat([sum(ld[:,:,s] for ld in _ld_E[idx[:,s]]) for s in 1:ns]...), nh, ny, ns)\nld_H = reshape(hcat([sum(ld[:,:,s] for ld in _ld_H[idx[:,s]]) for s in 1:ns]...), nh, ny, ns)\n\n# Add first year\ntimestamp = repeat(t0:Hour(1):t0+Hour(nh-1), 1, 2, ns)\npv = cat(pv[:,1,1] .* ones(nh,1,ns), pv, dims=2)\nld_E = cat(ld_E[:,1,1] .* ones(nh,1,ns), ld_E, dims=2)\nld_H = cat(ld_H[:,1,1] .* ones(nh,1,ns), ld_H, dims=2)\n\n# Operating cost\n# Flat rate including taxes, etc. - from eurostat - projected evolution over 20 years\n_cost_in = compute_operating_cost_scenarios(0.19 * ones(nh), Normal(1.04, 0.04), nh, 20, ns)\n_cost_out = compute_operating_cost_scenarios(0.0001 * ones(nh), Normal(1., 0.), nh, 20, ns)\n# Averaged cost\ncost_in = mean(_cost_in, dims=2)\ncost_out = mean(_cost_out, dims=2)\n# Add first year\ncost_in = cat(0.19 * ones(nh, 1, ns), cost_in, dims=2)\ncost_out = cat(0.0001 * ones(nh, 1, ns), cost_out, dims=2)\n\n# Investment cost - from Petkov & Gabrielli, 2020\ncost_pv = 1300 * ones(2, ns)\ncost_liion = 300 * ones(2, ns)\ncost_tes = 10 * ones(2, ns)\ncost_h2tank = 10 * ones(2, ns)\ncost_elyz = 1300 * ones(2, ns)\ncost_fc = 1700 * ones(2, ns)\ncost_heater = 0 * ones(2, ns)\n\n# Here we can devide the set of scenario in two keeping one half for sizing and one for assessing\n# Scenarios\nω_optim = Dict(\n\"pv\" => (t = timestamp[:,:,2:2:end], power = pv[:,:,2:2:end], cost = cost_pv[:,2:2:end]),\n\"ld_E\" => (t = timestamp[:,:,2:2:end], power = ld_E[:,:,2:2:end]),\n\"ld_H\" => (t = timestamp[:,:,2:2:end], power = ld_H[:,:,2:2:end]),\n\"liion\" => (cost = cost_liion[:,2:2:end],),\n\"tes\" => (cost = cost_tes[:,2:2:end],),\n\"h2tank\" => (cost = cost_h2tank[:,2:2:end],),\n\"elyz\" => (cost = cost_elyz[:,2:2:end],),\n\"fc\" => (cost = cost_fc[:,2:2:end],),\n\"heater\" => (cost = cost_heater[:,2:2:end],),\n\"grid\" => (cost_in = cost_in[:,:,2:2:end], cost_out = cost_out[:,:,2:2:end]),\n)\n\n# ... and odd number scenarios for simulation\nω_simu = Dict(\n\"pv\" => (t = timestamp[:,:,1:2:end], power = pv[:,:,1:2:end], cost = cost_pv[:,1:2:end]),\n\"ld_E\" => (t = timestamp[:,:,1:2:end], power = ld_E[:,:,1:2:end]),\n\"ld_H\" => (t = timestamp[:,:,1:2:end], power = ld_H[:,:,1:2:end]),\n\"liion\" => (cost = cost_liion[:,1:2:end],),\n\"tes\" => (cost = cost_tes[:,1:2:end],),\n\"h2tank\" => (cost = cost_h2tank[:,1:2:end],),\n\"elyz\" => (cost = cost_elyz[:,1:2:end],),\n\"fc\" => (cost = cost_fc[:,1:2:end],),\n\"heater\" => (cost = cost_heater[:,1:2:end],),\n\"grid\" => (cost_in = cost_in[:,:,1:2:end], cost_out = cost_out[:,:,1:2:end]),\n)\n\n# Save scenarios as .jld files\nsave(joinpath(\"data\", \"ausgrid_5_twostage.jld\"), \"ω_optim\", ω_optim, \"ω_simu\", ω_simu)","category":"page"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"For more information on  initialize_generator and  generate see Scenario page","category":"page"},{"location":"Examples.html#Optimizing-and-Simulating-the-Microgrid","page":"Examples","title":"Optimizing and Simulating the Microgrid","text":"","category":"section"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"Once you have generated the data scenarios for your microgrid system, you can optimize and simulate its performance using the functions provided in our package. In this section, we demonstrate how to perform optimization and simulation using the data scenarios created in the previous section.","category":"page"},{"location":"Examples.html#Constructing-the-grid","page":"Examples","title":"Constructing the grid","text":"","category":"section"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"The first step is to build the microgrid get the data and add assets to it. The following code show this process for the case of a single energy grid with battery storage and Solar panel over 21 years for 1 scenario. For more details about the assets see Assets page","category":"page"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"\nusing JLD, Dates\n\nconst nh, ny, ns = 8760, 21, 1 #nh = number of timestep per year, ny = time horizon (in years), ns = number of scenario used\n\ndata = load(joinpath(\"example\",\"data\",\"ausgrid_5_twostage.jld\")) #Get the data for scenarios \n\nmicrogrid = Microgrid(parameters = GlobalParameters(nh, ny, ns, renewable_share = 1.)) # Instantiate a Microgrid \n\n\nadd!(microgrid, Demand(carrier = Electricity()),\n                Solar(),\n                Liion_electro_chimique(),\n                Grid(carrier = Electricity())) # Add assets to it\n\nω_d = Scenarios(microgrid, data[\"ω_optim\"]) # Build the right number of scenarios with the right length for the microgrid\n","category":"page"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"It is also possible to get 2 set of scenarios as explained in section Stochastic generation of this page. One for design and one for assessment.","category":"page"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"ω_d, ω_a = Scenarios(microgrid, data[\"ω_optim\"]), Scenarios(microgrid, data[\"ω_simu\"])","category":"page"},{"location":"Examples.html#Sizing-the-grid","page":"Examples","title":"Sizing the grid","text":"","category":"section"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"The sizing is performed by a component called designer. Several type of designer are implemented and their role is to determine the size of the asset. The simplest designer is the manual one where the user chose mannually the size of the assets. Other designer use optimization to provide a size, different optimization methods are implemented, exact and stochastic ones.","category":"page"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"Considering a grid mg, in order to determine the size of its assets, ","category":"page"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"one can use it's own design and use a Manual design.","category":"page"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"PV_size = 20.\nBAT_size = 40.                \ndesigner = initialize_designer!(mg, Manual(generations = [PV_size], storages = [BAT_size], subscribed_power = [5.]), ω_d)","category":"page"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"Manual design require a vector of values for the size of the generation assets, storage assets and grid assets.","category":"page"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"Other design methods can be used with the following code. Here an example for the MILP designer","category":"page"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"initialize_designer!(microgrid, MILP(options = MILPOptions(reducer = ManualReducer(y=1:1, s=1:1))), ω_d)","category":"page"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"Please note that the models used in the MILP formulation are linear models. Even if you added a more fine battery model.","category":"page"},{"location":"Examples.html#Operating-the-grid","page":"Examples","title":"Operating the grid","text":"","category":"section"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"To make the decisions during the simulation the grid need to be controlled. This role is taken by the Controller. A controller is going to operate the grid during the simulation, their is several type of controller implemented (Need to add reference or details) here. The simplest ones are Rule Based Controller RBC.  ","category":"page"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"controller = initialize_controller!(microgrid,  RBC(options = RBCOptions(policy_selection = 2 )), ω_d)","category":"page"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"More complexe controller using optimisation with varying range of sight can also be used.","category":"page"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"controller = initialize_controller!(microgrid, Anticipative(generations = [10.], storages = [20.], converters = []), designer, ω_d)","category":"page"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"Please note that the models used in the MILP formulation are linear models. Even if you added a more fine battery model.","category":"page"},{"location":"Examples.html#Simulating","page":"Examples","title":"Simulating","text":"","category":"section"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"Now that everything is declared the microgrid can be simulated to assess techno-economic indicators.","category":"page"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"@time simulate!(microgrid, controller, designer, ω_a, options = Genesys.Options(mode = \"serial\", firstyear = false))","category":"page"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"Here the microgrid will be simulated using the sizing stored in desginer, the operation stored in controller under the conditions of ω_a. The first year option can be use to compare a first year without any asset installed (as some kind of reference) to another year. ","category":"page"},{"location":"Examples.html#Extracting-Metrics-and-Figures","page":"Examples","title":"Extracting Metrics and Figures","text":"","category":"section"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"After optimizing and simulating your microgrid system, you may want to analyze its performance by extracting relevant metrics and creating visualizations. In this section, we provide examples of how to use our package to generate these metrics and figures.","category":"page"},{"location":"Examples.html","page":"Examples","title":"Examples","text":" #Example code: Generating Metrics and Figures","category":"page"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"Once you have completed the examples in this document, you should be familiar with the main functionalities of our Julia package for modeling, optimizing, and simulating microgrids. If you have any questions or need further assistance, please refer to our package documentation or contact us for support.","category":"page"},{"location":"Tutorials/1-Introduction.html#Tutorials","page":"Tutorials","title":"Tutorials","text":"","category":"section"},{"location":"Tutorials/1-Introduction.html#Introduction-(2h)","page":"Tutorials","title":"Introduction (2h)","text":"","category":"section"},{"location":"Tutorials/1-Introduction.html","page":"Tutorials","title":"Tutorials","text":"Ce package à deux fonctions majeures, complémentaires, mais différentes :","category":"page"},{"location":"Tutorials/1-Introduction.html","page":"Tutorials","title":"Tutorials","text":"Le dimentionnement et la gestion otpimal sur un axe optimization.\nLa simulation pour l'assessment des métriques sur le système.","category":"page"},{"location":"Tutorials/1-Introduction.html#Important-definitions","page":"Tutorials","title":"Important definitions","text":"","category":"section"},{"location":"Tutorials/1-Introduction.html#Problem-definition","page":"Tutorials","title":"Problem definition","text":"","category":"section"},{"location":"Tutorials/1-Introduction.html#Les-décisions","page":"Tutorials","title":"Les décisions","text":"","category":"section"},{"location":"Tutorials/1-Introduction.html","page":"Tutorials","title":"Tutorials","text":"Le terme dimensionnement fait référence à un problème (au sens de l'optimisation) de dimensionnement dans lequel il s'agit de décider de la meilleur taille pour chaque composant du réseau. On appel ces choix des décisions et un ensemble de valeur associé à ces décisions (une par décision) est appelé une solution. Le but étant de trouver la meilleure solution. Une solution, est considéré comme la meilleure si elle permet de maximiser une métrique (appelé critère ou objectif). L'objectif est généralement lié au coût global du système (en prenant en compte les années à venir) et on cherche alors à minimiser ce coût.","category":"page"},{"location":"Tutorials/1-Introduction.html","page":"Tutorials","title":"Tutorials","text":"Le terme gestion lui fait référence à un autre problème (toujours au sens de l'optimisation) dans lequel il s'agit de décider du pilotage des composants du réseaux, notamment à travers les flux d'énergie. Il s'agit là aussi de prendre des décisions quand au pilotage du réseau. ","category":"page"},{"location":"Tutorials/1-Introduction.html","page":"Tutorials","title":"Tutorials","text":"(Image: Multi-scale time model)  Ces décisions doivent être prises à interval réguliers. Pour cela 2 pas de temps sont considéré. Un pas de temps annuel Delta_y qui marquent les prises de décisions concernant le dimentionnement du réseau (au début de la simulation mais aussi pour les remplacements d'équipement ayant vieillis). Un pas de temps horaire Delta_h pour les décisions de gestions. (Delta_y = 8760 cdot Delta_h). (Image: Exemple d'un système simple ses équipements et ses flux)  Dans ce réseau simple, les décisions d'investissement concernent la taille des panneaux solaires ainsi que de la batterie. Les décisions de gestion vont dicter pour chaque heure quelle puissance doit être dirigée vers/hors de la batterie, la puissance tirée du réseau. On remarquera que la puissance générée par le panneau solaire dépend de l'ensoleillement et de la taille de celui ci mais nullement des décisions de gestion. De même que la demande ne dépend nullement de ces décisions mais doit être assurée.","category":"page"},{"location":"Tutorials/1-Introduction.html","page":"Tutorials","title":"Tutorials","text":"Il est alors possible de remarquer que ces deux problèmes sont  imbriqués (comme un problème bi-niveau).  En effet la meilleur façon de piloter les flux dépend de la taille des composants, voir même du choix des composants installés (un composant peut être dimensionné à 0). Par conséquent, le problème de gestion dépend de la solution proposée pour le problème de dimensionnement. De plus le problème de dimensionnement, pour évaluer la qualité de ses solutions doit proposer une solution au problème de gestion. Ainsi on remarque que ces 2 problèmes n'en sont en réalité qu'un seul.","category":"page"},{"location":"Tutorials/1-Introduction.html","page":"Tutorials","title":"Tutorials","text":"Ainsi on désigne ce problème comme le problème de dimensionnement/gestion optimal des microrésaux.","category":"page"},{"location":"Tutorials/1-Introduction.html#Les-contraintes","page":"Tutorials","title":"Les contraintes","text":"","category":"section"},{"location":"Tutorials/1-Introduction.html","page":"Tutorials","title":"Tutorials","text":"A cela il convient d'ajouter un volet contraintes (sur l'autonomie du réseau ou bien sa capacité à assurer la demande). Dans un problème d'optimisation, les contraintes sont un ensemble de restriction qui doivent être satisfaites pour qu'une solution soit considérée comme admissible (acceptable, recevable). Il s'agit de définir d'une part, le domaine de définition de chaque variable (min, max, positif, négatif ...) par exemple la capacité d'une batterie sera nécessairement positive. Ces contraintes simples impliquent une seule variable de décision. Il va également s'agir de définir des contraintes plus complexes permettant de vérifier l'équilibre des puissances du système. Enfin on peut définir des contraintes aux objectifs plus macroscopique comme par exemple sur l'autonomie du système.  De plus amples détails sur la constructions de ces problèmes d'optimisations seront données plus tard dans ce cours.","category":"page"},{"location":"Tutorials/1-Introduction.html#Aspect-Stochastique","page":"Tutorials","title":"Aspect Stochastique","text":"","category":"section"},{"location":"Tutorials/1-Introduction.html","page":"Tutorials","title":"Tutorials","text":"Les solutions sont bien sûrs dépendantes des données d'entrées notamment concernant la demande énergétiques mais aussi concernant la production énergétique des énergies renouvelables. Une faible demande demandera mécaniquement des équipements moins importants. Dans ce cas si l'on venait à utiliser une consommation trop faible pour dimensionner le système, on choisirai surement des équipements trop petit, et bien sûr on peut imaginer le cas inverse et acheter des équipement plus gros et plus cher sans raisons, bref on aurait surdimensionné le réseau.   Ces données d'entrée sont considérées comme aléatoire mais sont néanmoins régulièrement observée et peuvent donc être caractérisées. On considère alors qu'il est possible de prévenir partiellement le sur/sous-dimensionnement en utilisant un nombre important de scénarios de données considérés représentatifs des données aléatoires concernées.  Dans ce contexte on cherche le dimensionnement qui à le coût moyen (sur l'ensemble des scénarios) le plus bas tout en satisfaisant les contraintes sur l'ensemble des scénarios.","category":"page"},{"location":"Tutorials/1-Introduction.html#TP1-prise-en-main-(4h)","page":"Tutorials","title":"TP1 prise en main (4h)","text":"","category":"section"},{"location":"Tutorials/1-Introduction.html#Identification-des-parties-principales","page":"Tutorials","title":"Identification des parties principales","text":"","category":"section"},{"location":"Tutorials/1-Introduction.html","page":"Tutorials","title":"Tutorials","text":"Après avoir défini la tâche à réaliser qu'est le dimentionnement de micro réseau on peut aborder le sujet de la méthode. Pour cela on va s'attaquer à un exemple simple et identifier les différentes partie principale à considérer. Ces différentes parties seront plus tard plus amplement explorées jusqu'a permettre d'en créer de nouvelles versions.","category":"page"},{"location":"Tutorials/1-Introduction.html","page":"Tutorials","title":"Tutorials","text":"On va ici présenter le processus de dimentionnement comme ","category":"page"},{"location":"Tutorials/1-Introduction.html#Premier-script","page":"Tutorials","title":"Premier script","text":"","category":"section"},{"location":"Tutorials/1-Introduction.html","page":"Tutorials","title":"Tutorials","text":"La simulation consiste à attribuer des décisions aux différentes variables (ces décision peuvent venir de résultats d'optimisation comme de décisions arbitraires) avec d'observer le comportement du réseau durant une durée défini au préalable. Grâce à cela il est possible d'extraire des métriques afin d'évaluer les décisions prises.","category":"page"},{"location":"Tutorials/1-Introduction.html","page":"Tutorials","title":"Tutorials","text":"Cela peut sembler étonnant, \"nul besoin d'analyser dans le cas de l'optimisation, la solution est déjà la meilleure par définition\". En réalité c'est plus compliqué que cela.","category":"page"},{"location":"Tutorials/1-Introduction.html","page":"Tutorials","title":"Tutorials","text":"D'une part les modèles utilisable par certaines méthodes d'optimisation sont limités, la programmation linéaire par exemple, bien que très rapide nécéssite de modéliser l'ensemble du système via des équations linaires ce qui révient à faire un certains nombre de simplification et d'abstraction du système. Dans le cadre de la simulation l'inclusion de modèle complexe n'est pas un problème car on décrit l'évolution du système d'état en état. Cette différence implique que les solution trouvées via l'optimisation de sont pas nécéssairement les mêmes si les modèles qui décrivent le système sont différent.","category":"page"},{"location":"Tutorials/1-Introduction.html","page":"Tutorials","title":"Tutorials","text":"D'autre part les données d'entrer utilisée pour décrire un certain nopmbre de paramètres aléatoires (l'ensoleillement, la consommation ...) doivent être similaires mais différentes entre une phase de dimentionnement et une pahse de simulation. Dans le cas contraire un phénomène d'overfitting peut avoir lieu, le réseau est très adapaté à un scénario d'évennement qui n'arrivera pas car les données représente un profil crédible mais il est évident que la météo dans 5 ans n'a pas encore été prévue et qu'il est par conséquent impossible de prévoir l'ensoleillement à ce moment.","category":"page"},{"location":"Tutorials/1-Introduction.html#Input-data","page":"Tutorials","title":"Input data","text":"","category":"section"},{"location":"Tutorials/1-Introduction.html","page":"Tutorials","title":"Tutorials","text":"Le réseau est opéré à un pas de temps Delta_h qui doit être fixé, généralement une heure, et ce pendant un horizon temporel mathcalY qui désigne le nombre d'année. Il convient donc de fournir des données d'entrée adaptées à ce pas de temps et cet horizon temporel. Afin d'adresser le charactère aléatoire de ces données, il est même envisagé d'utilisé plusieurs séries temporelles. Ces données doivent généralement être basée sur des données réelles cohérentes avec la consommation et la production d'énergie du réseau étudié. On appel l'ensemble de ces données d'entrée un scénario. On peut inclure dans ce scénario l'ensemble des données d'entrée nécessaire à décrire le contexte dans lequel évoluera le réseau (prix des composants, demande, génération, prix de l'électricité en achat et vente)","category":"page"},{"location":"Tutorials/1-Introduction.html","page":"Tutorials","title":"Tutorials","text":"Comme ces données sont rares et peu disponibles en quantité, une méthode de génération de scénario à partir d'un ensemble réduit permet de palier à ce problème. Ces méthode est décrite dans  ce papier","category":"page"},{"location":"Tutorials/1-Introduction.html#Data-construction","page":"Tutorials","title":"Data construction","text":"","category":"section"},{"location":"Tutorials/1-Introduction.html","page":"Tutorials","title":"Tutorials","text":"Il est nécéssaire de créer des données adaptées à chaque cas particulier. En effet les méthodes pour le dimentionnement sont considéré généralisables car les données dentrée permettent de les adapter à chaque cas d'étude.","category":"page"},{"location":"Tutorials/1-Introduction.html","page":"Tutorials","title":"Tutorials","text":"{Définir et insérer une réflexion sur le processus de collecte et de mise en place des données d'entrée} {Ajouter que cette partie est une introduction et qu'un chapitre detaillé sur le sujet viendra plus tard}","category":"page"},{"location":"Tutorials/1-Introduction.html#Data-usage","page":"Tutorials","title":"Data usage","text":"","category":"section"},{"location":"Tutorials/1-Introduction.html#First-case-:-Find-the-optimal-sizing-for-an-exemple-microgrid","page":"Tutorials","title":"First case : Find the optimal sizing for an exemple microgrid","text":"","category":"section"},{"location":"Tutorials/1-Introduction.html#Grid-construction","page":"Tutorials","title":"Grid construction","text":"","category":"section"},{"location":"Tutorials/1-Introduction.html#Constant-declaration","page":"Tutorials","title":"Constant declaration","text":"","category":"section"},{"location":"Tutorials/1-Introduction.html","page":"Tutorials","title":"Tutorials","text":"La première chose à faire est de définir 3 constantes, une première ny pour le nombre d'année sur lesquels on souhait étudier le réseau. Une seconde nh pour définir le nombre de décision par année, généralement 8760 (24*365) pour une phase de décision de gestion par heure. Enfin une troisième ns pour définir le nombre de scénarios qui seront considérés.","category":"page"},{"location":"Tutorials/1-Introduction.html","page":"Tutorials","title":"Tutorials","text":"Enfin l'outil est pensé pour adresser aussi bien des réseau isolé que connecté, il s'agit également de définir le niveau d'autosuffisance attendu pour le réseau. Cela sera formulé sous forme de contrainte et dans le cas ou ce minimum est fixé à 100% le réseau sera considéré comme autonome.","category":"page"},{"location":"Tutorials/1-Introduction.html","page":"Tutorials","title":"Tutorials","text":"(Parler de la prossibilité de voir le grid comme une source non reouvellable et qu'il est tout à fait possible de créer un nouvel asset ou bien de se servire du grid comme un groupe éléctrogène. Connaissant le prix de l'essence et le rendemment du groupe electrogène on arrive vite à un prix de l'éléctricité.)","category":"page"},{"location":"Tutorials/1-Introduction.html","page":"Tutorials","title":"Tutorials","text":"Une fois ces constantes défini on peut alors créer une structure Microgrid. ","category":"page"},{"location":"Tutorials/1-Introduction.html","page":"Tutorials","title":"Tutorials","text":"    const nh, ny, ns = 8760, 21, 16\n    mg = Microgrid(parameters = GlobalParameters(nh, ny, ns, renewable_share = 1.))","category":"page"},{"location":"Tutorials/1-Introduction.html","page":"Tutorials","title":"Tutorials","text":"Ici on a donc un réseau isolé opérer sur 20 ans, heure par heure, et prêt à être analyser à travers 16 scénarios (Adresser le concept de la première année. pourquoi 20 ans alors que ny = 21)","category":"page"},{"location":"Tutorials/1-Introduction.html#Component-selection","page":"Tutorials","title":"Component selection","text":"","category":"section"},{"location":"Tutorials/1-Introduction.html","page":"Tutorials","title":"Tutorials","text":"Il s'agit alors d'ajouter à ce microgrid un ensemble de composant choisi parmis une liste de composants existant et pouvant être classifiés comme suit : (la liste des composant n'est peut être pas exhaustive)","category":"page"},{"location":"Tutorials/1-Introduction.html","page":"Tutorials","title":"Tutorials","text":"Les generateurs (PV panel, wind turbine, fuel cell ...), pour la production des energies.\nLes stockeurs (H2 tank, Li-ion battery, thermal storage ...) Pour le stockage des energies.\nLes convertisseurs (Heater, electrolizer ...) Pour la conversion des énérgies.\nLes sources externes (Electric grid, genset ...) Pour répondre à la demande si les générateurs sont insufisants.\nLa demande (Electrique, chaleur ...) Pour définir les besoins, cet élément permet de définir les type d'énergies qui seront attendues.","category":"page"},{"location":"Tutorials/1-Introduction.html","page":"Tutorials","title":"Tutorials","text":"Le code suivant permet d'ajouter au microgrid mg une demande éléctrique, un panneau solaire, une batterie li ion et de connecter le micrgrid à un réseau éléctrique. ","category":"page"},{"location":"Tutorials/1-Introduction.html","page":"Tutorials","title":"Tutorials","text":"add!(mg, Demand(carrier = Electricity()),\n                Solar(),\n                Liion_energy_exchanged(),\n                Grid(carrier = Electricity()))","category":"page"},{"location":"Tutorials/1-Introduction.html","page":"Tutorials","title":"Tutorials","text":"Ce qui amène au réseau suivant {IMAGE GRID}","category":"page"},{"location":"Tutorials/1-Introduction.html","page":"Tutorials","title":"Tutorials","text":"On peut alors associé les données défini à la section précédente à ce réseau avec le code suivant :","category":"page"},{"location":"Tutorials/1-Introduction.html","page":"Tutorials","title":"Tutorials","text":"ω_d = Scenarios(mg, data[\"data\"]; same_year=true, seed=1:ns)","category":"page"},{"location":"Tutorials/1-Introduction.html","page":"Tutorials","title":"Tutorials","text":"{Ajuster ce code pour qu'il soit très clair d'un point de vue pédagogique.}","category":"page"},{"location":"Tutorials/1-Introduction.html#component-parametrization","page":"Tutorials","title":"component parametrization","text":"","category":"section"},{"location":"Tutorials/1-Introduction.html#Operation-and-design","page":"Tutorials","title":"Operation and design","text":"","category":"section"},{"location":"Tutorials/1-Introduction.html#Operation","page":"Tutorials","title":"Operation","text":"","category":"section"},{"location":"Tutorials/1-Introduction.html#Design","page":"Tutorials","title":"Design","text":"","category":"section"},{"location":"Tutorials/1-Introduction.html#Simulations-and-assessment","page":"Tutorials","title":"Simulations and assessment","text":"","category":"section"},{"location":"Tutorials/1-Introduction.html#Simulation","page":"Tutorials","title":"Simulation","text":"","category":"section"},{"location":"Tutorials/1-Introduction.html#metrics","page":"Tutorials","title":"metrics","text":"","category":"section"},{"location":"Tutorials/1-Introduction.html#Prices","page":"Tutorials","title":"Prices","text":"","category":"section"},{"location":"Tutorials/1-Introduction.html#plots","page":"Tutorials","title":"plots","text":"","category":"section"},{"location":"index.html#Microgrid_Genesys.jl","page":"Microgrid_Genesys.jl","title":"Microgrid_Genesys.jl","text":"","category":"section"},{"location":"index.html","page":"Microgrid_Genesys.jl","title":"Microgrid_Genesys.jl","text":"A toolbox for modeling, optimizing and simulating microgrids developped by the Genesys team at LAPLACE laboratory, Toulouse, France","category":"page"},{"location":"index.html#Table-Of-Contents","page":"Microgrid_Genesys.jl","title":"Table Of Contents","text":"","category":"section"},{"location":"index.html","page":"Microgrid_Genesys.jl","title":"Microgrid_Genesys.jl","text":"","category":"page"},{"location":"index.html#Package-features","page":"Microgrid_Genesys.jl","title":"Package features","text":"","category":"section"},{"location":"index.html","page":"Microgrid_Genesys.jl","title":"Microgrid_Genesys.jl","text":"In this page, we'll provide an overview of the main components and features of the Genesys module.","category":"page"},{"location":"index.html#Main-Components","page":"Microgrid_Genesys.jl","title":"Main Components","text":"","category":"section"},{"location":"index.html","page":"Microgrid_Genesys.jl","title":"Microgrid_Genesys.jl","text":"The Genesys module includes the following main components:","category":"page"},{"location":"index.html","page":"Microgrid_Genesys.jl","title":"Microgrid_Genesys.jl","text":"Assets: Microgrid components, such as demand, solar, liion, thermal storage, and grid.\nScenarios: Tools for generating and reducing scenarios for simulations.\nOptimization: Design and operation optimization tools, including controllers and designers.\nSimulation: Functions for simulating microgrids over different time horizons and scenarios.\nUtils: Utilities for metrics, plotting, and data saving.","category":"page"},{"location":"index.html#Key-Features","page":"Microgrid_Genesys.jl","title":"Key Features","text":"","category":"section"},{"location":"index.html","page":"Microgrid_Genesys.jl","title":"Microgrid_Genesys.jl","text":"The Genesys module offers a wide range of features for microgrid simulations and optimizations:","category":"page"},{"location":"index.html","page":"Microgrid_Genesys.jl","title":"Microgrid_Genesys.jl","text":"A flexible and extensible structure that allows for the incorporation of different asset types, descriptive models and optimization algorithms.\nA comprehensive set of optimization tools, including dummy, anticipative, rule-based control, and online learning for frequency control.\nScenario generation and reduction techniques for efficient and accurate simulations.\nBuilt-in plotting and metrics utilities for easy analysis and visualization of results.","category":"page"},{"location":"index.html","page":"Microgrid_Genesys.jl","title":"Microgrid_Genesys.jl","text":"To learn more about how to use the Genesys module, please refer to the other pages in this documentation. To learn to use the key features of this module please refer to the example page.","category":"page"},{"location":"Scenario.html#Scenario","page":"Scenario","title":"Scenario","text":"","category":"section"},{"location":"Scenario.html","page":"Scenario","title":"Scenario","text":"Genesys.Scenarios","category":"page"},{"location":"Scenario.html#Main.Genesys.Scenarios","page":"Scenario","title":"Main.Genesys.Scenarios","text":"mutable struct Scenarios{T, O, I} <: AbstractScenarios\n\nA mutable struct representing Scenarios, which is a subtype of AbstractScenarios.\n\nFields\n\ndemands::Vector{NamedTuple{(:t, :power), Tuple{T, O}}}: A vector of named tuples representing the time and power demand.\ngenerations::Vector{NamedTuple{(:t, :power, :cost), Tuple{T, O, I}}}: A vector of named tuples representing the time, power generation, and cost.\nstorages::Vector{NamedTuple{(:cost,), Tuple{I}}}: A vector of named tuples representing the cost of storage.\nconverters::Vector{NamedTuple{(:cost,), Tuple{I}}}: A vector of named tuples representing the cost of converters.\ngrids::Vector{NamedTuple{(:cost_in, :cost_out, :cost_exceed), Tuple{O, O, I}}}: A vector of named tuples representing the input cost, output cost, and exceeding cost of the grid.\n\n\n\n\n\n","category":"type"},{"location":"Scenario.html#Scenarios-Reducer","page":"Scenario","title":"Scenarios Reducer","text":"","category":"section"},{"location":"Scenario.html","page":"Scenario","title":"Scenario","text":"Genesys.ManualReducer\nGenesys.SAAReducer\nGenesys.MeanValueReducer\nGenesys.FeatureBasedReducer","category":"page"},{"location":"Scenario.html#Main.Genesys.ManualReducer","page":"Scenario","title":"Main.Genesys.ManualReducer","text":"mutable struct ManualReducer <: AbstractScenariosReducer\n    h::Union{UnitRange{Int64}, Int64}\n    y::Union{UnitRange{Int64}, Int64}\n    s::Union{UnitRange{Int64}, Int64}\nend\n\nA mutable structure representing a manual scenario reduction. Inherits from the AbstractScenariosReducer abstract type.\n\nFields\n\nh::Union{UnitRange{Int64}, Int64}: The hours to be included in the reduced scenario.\ny::Union{UnitRange{Int64}, Int64}: The years to be included in the reduced scenario.\ns::Union{UnitRange{Int64}, Int64}: The scenarios to be included in the reduced scenario.\n\nConstructor\n\nManualReducer(; h = 1:8760, y = 2:3, s = 1:1) = new(h, y, s)\n\n\n\n\n\n","category":"type"},{"location":"Scenario.html#Main.Genesys.SAAReducer","page":"Scenario","title":"Main.Genesys.SAAReducer","text":"mutable struct SAAReducer <: AbstractScenariosReducer\n    nsample::Int64\nend\n\nA mutable structure representing a Sample Average Approximation (SAA) scenario reduction. Inherits from the AbstractScenariosReducer abstract type.\n\nFields\n\nnsample::Int64: The number of samples to be included in the reduced scenario.\n\nConstructor\n\nSAAReducer(; nsample = 100) = new(nsample)\n\n\n\n\n\n","category":"type"},{"location":"Scenario.html#Main.Genesys.MeanValueReducer","page":"Scenario","title":"Main.Genesys.MeanValueReducer","text":"mutable struct MeanValueReducer <: AbstractScenariosReducer\nend\n\nA mutable structure representing an Expected Value (Mean Value) scenario reduction. Inherits from the AbstractScenariosReducer abstract type.\n\nConstructor\n\nMeanValueReducer() = new()\n\n\n\n\n\n","category":"type"},{"location":"Scenario.html#Main.Genesys.FeatureBasedReducer","page":"Scenario","title":"Main.Genesys.FeatureBasedReducer","text":"mutable struct FeatureBasedReducer <: AbstractScenariosReducer\n    transformation::Union{UnionAll, Nothing}\n    reduction::Union{AbstractDimensionReducer, Nothing}\n    clustering::AbstractClusteringMethod\nend\n\nA mutable structure representing a Clustering scenario reduction using feature-based methods. Inherits from the AbstractScenariosReducer abstract type.\n\nFields\n\ntransformation: A transformation method to apply before clustering (default: UnitRangeTransform)\nreduction: A dimensionality reduction method to apply before clustering (default: StatsReduction())\nclustering: The clustering method to use (default: KmedoidsClustering())\n\nConstructor\n\nFeatureBasedReducer(; transformation = UnitRangeTransform,\n                    reduction = StatsReduction(),\n                    clustering = KmedoidsClustering()) = new(transformation, reduction, clustering)\n\n\n\n\n\n","category":"type"},{"location":"Scenario.html#Dimention-Reducer","page":"Scenario","title":"Dimention Reducer","text":"","category":"section"},{"location":"Scenario.html","page":"Scenario","title":"Scenario","text":"Genesys.PCAReduction\nGenesys.StatsReduction","category":"page"},{"location":"Scenario.html#Main.Genesys.PCAReduction","page":"Scenario","title":"Main.Genesys.PCAReduction","text":"mutable struct PCAReduction <: AbstractDimensionReducer\n    n_components::Int64\nend\n\nA mutable structure representing Principal Component Analysis (PCA) dimensionality reduction. Inherits from the AbstractDimensionReducer abstract type.\n\nFields\n\nn_components: The number of principal components to use for dimensionality reduction (default: 2)\n\nConstructor\n\nPCAReduction(; n_components = 2) = new(n_components)\n\n\n\n\n\n","category":"type"},{"location":"Scenario.html#Main.Genesys.StatsReduction","page":"Scenario","title":"Main.Genesys.StatsReduction","text":"struct StatsReduction <: AbstractDimensionReducer\n\nA structure representing statistics-based dimensionality reduction. Inherits from the AbstractDimensionReducer abstract type.\n\nConstructor\n\nStatsReduction()\n\n\n\n\n\n","category":"type"},{"location":"Scenario.html#Transformation","page":"Scenario","title":"Transformation","text":"","category":"section"},{"location":"Scenario.html","page":"Scenario","title":"Scenario","text":"Genesys.UnitRangeTransform\nGenesys.ZScoreTransform","category":"page"},{"location":"Scenario.html#StatsBase.UnitRangeTransform","page":"Scenario","title":"StatsBase.UnitRangeTransform","text":"Unit range normalization\n\n\n\n\n\n","category":"type"},{"location":"Scenario.html#StatsBase.ZScoreTransform","page":"Scenario","title":"StatsBase.ZScoreTransform","text":"Standardization (Z-score transformation)\n\n\n\n\n\n","category":"type"},{"location":"Scenario.html#Custering","page":"Scenario","title":"Custering","text":"","category":"section"},{"location":"Scenario.html","page":"Scenario","title":"Scenario","text":"Genesys.KmedoidsClustering","category":"page"},{"location":"Scenario.html#Main.Genesys.KmedoidsClustering","page":"Scenario","title":"Main.Genesys.KmedoidsClustering","text":"mutable struct KmedoidsClustering <: AbstractClusteringMethod\n\nA structure representing K-medoids clustering method. Inherits from the AbstractClusteringMethod abstract type.\n\nFields\n\nn_clusters::Int64: Number of clusters to form.\ndistance::Distances.SemiMetric: Distance metric to use for calculating the dissimilarity between points.\nlog::Bool: Whether to print logs during the clustering process.\n\nConstructor\n\nKmedoidsClustering(; n_clusters = 20, distance = Distances.Euclidean(), log = true)\n\n\n\n\n\n","category":"type"},{"location":"Scenario.html#Generator","page":"Scenario","title":"Generator","text":"","category":"section"},{"location":"Scenario.html","page":"Scenario","title":"Scenario","text":"Genesys.MarkovGenerator\nGenesys.AnticipativeGenerator","category":"page"},{"location":"Scenario.html#Main.Genesys.MarkovGenerator","page":"Scenario","title":"Main.Genesys.MarkovGenerator","text":"mutable struct MarkovGenerator <: AbstractScenariosGenerator\n\nA structure representing a Markov chain-based scenario generator.\n\nFields\n\nnstate::Int64: Number of states, which corresponds to the number of clusters per hour per month.\nalgo::String: Algorithm used for clustering the states.\nmarkovchains::NamedTuple{(:wk, :wkd), Tuple{MarkovChain, MarkovChain}}: A named tuple containing the Markov chains for weekdays and weekends.\n\nExample\n\nmarkov_generator = MarkovGenerator(nstate=10, algo=\"kmeans\")\n\n\n\n\n\n","category":"type"},{"location":"Scenario.html#Main.Genesys.AnticipativeGenerator","page":"Scenario","title":"Main.Genesys.AnticipativeGenerator","text":"mutable struct AnticipativeGenerator <: AbstractScenariosGenerator\n\nA structure representing an anticipative scenario generator (perfect foresight).\n\nFields\n\nforecast: The field to store perfect foresight information.\n\nExample\n\nanticipative_generator = AnticipativeGenerator()\n\n\n\n\n\n","category":"type"},{"location":"Scenario.html#Base-generic-function","page":"Scenario","title":"Base generic function","text":"","category":"section"},{"location":"Scenario.html#Generate","page":"Scenario","title":"Generate","text":"","category":"section"},{"location":"Scenario.html","page":"Scenario","title":"Scenario","text":"Genesys.generate","category":"page"},{"location":"Scenario.html#Main.Genesys.generate","page":"Scenario","title":"Main.Genesys.generate","text":"Generate scenarios using a Markov chain.\n\nParameters: generator: a MarkovGenerator object s0: a ny x generator.nstate matrix representing the initial state t0: a DateTime object representing the initial timestamp nstep: an integer representing the number of steps to generate ny: an integer representing the number of scenarios to generate ns: an integer representing the number of seeds for the generator\n\nReturns:\n\na list of ny ny x ns x nstep matrix representing the generated scenarios\na ny x ns matrix representing the probability associated with each generated scenario\n\n\n\n\n\ngenerate(generator::AnticipativeGenerator, s0, t0::DateTime, nstep::Int64; ny::Int64=1, ns::Int64=1, h::Int64=1)\n\nGenerate perfect forecast.\n\nArguments\n\ngenerator::AnticipativeGenerator: Anticipative generator struct.\ns0: Vector of initial state(s).\nt0::DateTime: Initial time.\nnstep::Int64: Number of steps to simulate.\nny::Int64=1: Number of outputs.\nns::Int64=1: Number of scenarios.\nh::Int64=1: Initial time step.\n\nReturns\n\nforecast: Matrix of shape (nstep, ny, ns) with the forecasted values.\nprobs: Array of shape (ny, ns) with the probability distribution of each scenario.\n\n\n\n\n\n","category":"function"},{"location":"Scenario.html#Reduce","page":"Scenario","title":"Reduce","text":"","category":"section"},{"location":"Scenario.html","page":"Scenario","title":"Scenario","text":"Genesys.reduce","category":"page"},{"location":"Scenario.html#Main.Genesys.reduce","page":"Scenario","title":"Main.Genesys.reduce","text":"function reduce(reducer::ManualReducer, ω::Scenarios)\n\nReduces the given Scenarios object using the specified ManualReducer.\n\nArguments\n\nreducer::ManualReducer: The reducer used to specify the reduction process.\nω::Scenarios: The Scenarios object to be reduced.\n\nReturns\n\nA new reduced Scenarios object.\nA probability vector representing the likelihood of each scenario.\n\nExample\n\nmanual_reducer = ManualReducer(h = 1:8760, y = 2:3, s = 1:1)\nreduced_scenarios, probabilities = reduce(manual_reducer, scenarios)\n\n\n\n\n\nfunction reduce(reducer::SAAReducer, ω::Scenarios; y::Int64 = 1, s::Int64 = 1)\n\nReduces the given Scenarios object using the specified SAAReducer, implementing the Sample Average Approximation scenario reduction method.\n\nArguments\n\nreducer::SAAReducer: The reducer used to specify the reduction process.\nω::Scenarios: The Scenarios object to be reduced.\n\nKeyword Arguments\n\ny::Int64 = 1: The initial year to be considered.\ns::Int64 = 1: The initial scenario to be considered.\n\nReturns\n\nA new reduced Scenarios object.\nA probability vector representing the likelihood of each scenario.\n\nExample\n\nsaa_reducer = SAAReducer(nsample = 100)\nreduced_scenarios, probabilities = reduce(saa_reducer, scenarios)\n\n\n\n\n\nfunction reduce(reducer::MeanValueReducer, ω::Scenarios; y::Int64 = 1, s::Int64 = 1)\n\nReduces the given Scenarios object using the specified MeanValueReducer, implementing the Expected Value scenario reduction method.\n\nArguments\n\nreducer::MeanValueReducer: The reducer used to specify the reduction process.\nω::Scenarios: The Scenarios object to be reduced.\n\nKeyword Arguments\n\ny::Int64 = 1: The initial year to be considered.\ns::Int64 = 1: The initial scenario to be considered.\n\nReturns\n\nA new reduced Scenarios object.\nA probability vector representing the likelihood of each scenario (in this case, a single element array containing 1).\n\nExample\n\nmean_value_reducer = MeanValueReducer()\nreduced_scenarios, probabilities = reduce(mean_value_reducer, scenarios)\n\n\n\n\n\nfunction reduce(reducer::FeatureBasedReducer, ω::Scenarios; y::Int64 = 1, s::Int64 = 1)\n\nReduces the given Scenarios object using the specified FeatureBasedReducer, implementing a clustering-based scenario reduction method.\n\nArguments\n\nreducer::FeatureBasedReducer: The reducer used to specify the reduction process, including transformation, dimension reduction, and clustering methods.\nω::Scenarios: The Scenarios object to be reduced.\n\nKeyword Arguments\n\ny::Int64 = 1: The initial year to be considered.\ns::Int64 = 1: The initial scenario to be considered.\n\nReturns\n\nA new reduced Scenarios object.\nA probability vector representing the likelihood of each scenario in the reduced set.\nAn array of assignments indicating which cluster each original scenario belongs to.\n\nExample\n\nfeature_based_reducer = FeatureBasedReducer(transformation = UnitRangeTransform,\n                                            reduction = StatsReduction(),\n                                            clustering = KmedoidsClustering())\nreduced_scenarios, probabilities, assignments = reduce(feature_based_reducer, scenarios)\n\n\n\n\n\n","category":"function"},{"location":"Tutorials/2-Operation_data.html#Operation-and-Input-data","page":"Operation and Input data","title":"Operation and Input data","text":"","category":"section"},{"location":"Tutorials/2-Operation_data.html#CM-(2H)","page":"Operation and Input data","title":"CM (2H)","text":"","category":"section"},{"location":"Tutorials/2-Operation_data.html#Intro","page":"Operation and Input data","title":"Intro","text":"","category":"section"},{"location":"Tutorials/2-Operation_data.html","page":"Operation and Input data","title":"Operation and Input data","text":"Si on considère un réseau déja installé. L'opération n'est alors fonction que des données d'entrée. ","category":"page"},{"location":"Tutorials/2-Operation_data.html","page":"Operation and Input data","title":"Operation and Input data","text":"Pour une Rule Based c'est simplement un comportement préprogrammé à chaque pas de temps fonction de la consommation et de la production.","category":"page"},{"location":"Tutorials/2-Operation_data.html","page":"Operation and Input data","title":"Operation and Input data","text":"Pour une méthode d'optimisation plus poussée c'est une réponse optimale aux données d'entrées sur la periode d'information considérée.","category":"page"},{"location":"Tutorials/2-Operation_data.html","page":"Operation and Input data","title":"Operation and Input data","text":"Dans les deux cas la gestion, qui doit formuler les decisions d'opération, est une réponse direct aux données d'entrée. ","category":"page"},{"location":"Tutorials/2-Operation_data.html","page":"Operation and Input data","title":"Operation and Input data","text":"Rule base (simple et rapide, mais une par réseau spécifique)\nAnticipative (complexe et eventuellement long, donne une borne inf de l'optimal)","category":"page"},{"location":"Tutorials/2-Operation_data.html#Scenarios","page":"Operation and Input data","title":"Scenarios","text":"","category":"section"},{"location":"Tutorials/2-Operation_data.html","page":"Operation and Input data","title":"Operation and Input data","text":"C'est quoi un scenario","category":"page"},{"location":"Tutorials/2-Operation_data.html","page":"Operation and Input data","title":"Operation and Input data","text":"Pourquoi avoir des données particulières","category":"page"},{"location":"Tutorials/2-Operation_data.html","page":"Operation and Input data","title":"Operation and Input data","text":"Comment construire la demande ","category":"page"},{"location":"Tutorials/2-Operation_data.html","page":"Operation and Input data","title":"Operation and Input data","text":"Comment construire la production","category":"page"},{"location":"Tutorials/2-Operation_data.html","page":"Operation and Input data","title":"Operation and Input data","text":"la question des prix","category":"page"},{"location":"Tutorials/2-Operation_data.html#Rule-base","page":"Operation and Input data","title":"Rule base","text":"","category":"section"},{"location":"Tutorials/2-Operation_data.html#Intro-à-la-programmation-mathématique","page":"Operation and Input data","title":"Intro à la programmation mathématique","text":"","category":"section"},{"location":"Tutorials/2-Operation_data.html#TP-Construction-de-scénarios-(2h)","page":"Operation and Input data","title":"TP Construction de scénarios (2h)","text":"","category":"section"},{"location":"Tutorials/2-Operation_data.html#TP-construction-d'une-rule-base-simple-(2h)","page":"Operation and Input data","title":"TP construction d'une rule base simple (2h)","text":"","category":"section"},{"location":"Tutorials/2-Operation_data.html","page":"Operation and Input data","title":"Operation and Input data","text":"","category":"page"}]
}
