var documenterSearchIndex = {"docs":
[{"location":"cours.html#Cours","page":"Cours","title":"Cours","text":"","category":"section"},{"location":"cours.html#Support","page":"Cours","title":"Support","text":"","category":"section"},{"location":"cours.html","page":"Cours","title":"Cours","text":"Un ensemble de cours est proposé sous forme de CM (diaporama + vidéo) et de TP (diaporama + vidéo + script)","category":"page"},{"location":"cours.html","page":"Cours","title":"Cours","text":"L'ensemble de ces documents est disponible dans le dossier cours sur github. ","category":"page"},{"location":"cours.html","page":"Cours","title":"Cours","text":"Ces cours et TP ont pour but de permettre la prise en main du code pour des utilisateurs déjà familié avec le langage Julia.","category":"page"},{"location":"cours.html#Contenu","page":"Cours","title":"Contenu","text":"","category":"section"},{"location":"cours.html","page":"Cours","title":"Cours","text":"Cours 1 : Prise en main, architectures, Rule Based Control, affichages et métriques\nCours 2 : Méthode de décisions optimales\nCours 2.1 : Programmation mathématique\nCours 2.2 : Métaheuristiques\nCours 3 : Gestion des modèles de composant\nCours 3.1 : Création de modèle pour un composant existant (batterie)\nCours 3.2 : Ajout d'un nouveau composant (barrage)\nCours 4 : Gestion des scénarios de données (et utilisation pour le barrage) ","category":"page"},{"location":"Examples.html#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"Examples.html#Table-of-Contents","page":"Examples","title":"Table of Contents","text":"","category":"section"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"Introduction\nGenerating Data Scenarios\nOptimizing and Simulating the Microgrid\nExtracting Metrics and Figures","category":"page"},{"location":"Examples.html#Introduction","page":"Examples","title":"Introduction","text":"","category":"section"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"This page provides example code snippets on how to use the main functionalities of our Julia package for modeling, optimizing and simulating microgrids. This package is designed to make it easy for users to design and analyze microgrid systems. The examples provided in this document cover the following key features:","category":"page"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"Generating data scenarios for simulation\nOptimizing and simulating the microgrid\nExtracting metrics and figures","category":"page"},{"location":"Examples.html#Generating-Data-Scenarios","page":"Examples","title":"Generating Data Scenarios","text":"","category":"section"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"In this section, we provide examples of how to generate data scenarios for the simulation of your microgrid system. These data scenarios will be used as input for the optimization and simulation processes.","category":"page"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"We here present two ways of generating scenarios :  A first way is to take directly the data from the Ausgrid dataset and for each client, each year create a scenario.  A second way is to build profils using a stochastic process detailed in this article.","category":"page"},{"location":"Examples.html#Deterministic-generation","page":"Examples","title":"Deterministic generation","text":"","category":"section"},{"location":"Examples.html","page":"Examples","title":"Examples","text":" # Import necessary libraries\nusing JLD, Dates, Seaborn\n\n# Include supplementary functions\ninclude(\"functions.jl\")\n\n# Define global constants\n# nh: number of hours in a year\n# ny: number of years to simulate\n# ns: number of scenarios to generate\nconst nh, ny, ns = 8760, 2, 60\n\n# Load data for Ausgrid network for the years 2010, 2011, 2012\ndata_2010 = load(joinpath(\"Examples\",\"build_scenarios\", \"data\", \"clean_dataset_ausgrid_2010_2011.jld\"), \"clean_dataset\")\ndata_2011 = load(joinpath(\"Examples\",\"build_scenarios\", \"data\", \"clean_dataset_ausgrid_2011_2012.jld\"), \"clean_dataset\")\ndata_2012 = load(joinpath(\"Examples\",\"build_scenarios\", \"data\", \"clean_dataset_ausgrid_2012_2013.jld\"), \"clean_dataset\")\n\n# Identify customers who have data for all three years\ncustomers = [k for k in keys(data_2010) if k in keys(data_2011) && k in keys(data_2012)]\n\n# Initialize empty arrays for Photovoltaic (PV) production, Electric Load (ld_E) and Heat Load (ld_H)\n_pv, _ld_E, _ld_H = [], [], []\n\n# Set up date format to be used\ndateformat = Dates.DateFormat(\"dd-u-yyyy\")\n\n# Loop over each customer and collect their data for all three years\nfor c in customers[1:20]\n    # Collect and format data for Electric Load\n    push!(_ld_E, (t = hcat(Dates.DateTime.(data_2010[c][\"GC\"][\"time\"][1:nh], dateformat), Dates.DateTime.(data_2011[c][\"GC\"][\"time\"][1:nh], dateformat), Dates.DateTime.(data_2012[c][\"GC\"][\"time\"][1:nh], dateformat)),\n            power = hcat(data_2010[c][\"GC\"][\"power\"][1:nh], data_2011[c][\"GC\"][\"power\"][1:nh], data_2012[c][\"GC\"][\"power\"][1:nh])))\n\n    # Collect and format data for Heat Load\n    push!(_ld_H, (t = hcat(Dates.DateTime.(data_2010[c][\"CL\"][\"time\"][1:nh], dateformat), Dates.DateTime.(data_2011[c][\"CL\"][\"time\"][1:nh], dateformat), Dates.DateTime.(data_2012[c][\"CL\"][\"time\"][1:nh], dateformat)),\n            power = hcat(data_2010[c][\"CL\"][\"power\"][1:nh], data_2011[c][\"CL\"][\"power\"][1:nh], data_2012[c][\"CL\"][\"power\"][1:nh])))\n\n    # Collect and format data for PV Production\n    push!(_pv, (t = hcat(Dates.DateTime.(data_2010[c][\"GG\"][\"time\"][1:nh], dateformat), Dates.DateTime.(data_2011[c][\"GG\"][\"time\"][1:nh], dateformat), Dates.DateTime.(data_2012[c][\"GG\"][\"time\"][1:nh], dateformat)),\n            power = hcat(data_2010[c][\"GG\"][\"power\"][1:nh], data_2011[c][\"GG\"][\"power\"][1:nh], data_2012[c][\"GG\"][\"power\"][1:nh])))\nend\n\n# Format data to be compatible with Genesys simulation system\ntimestamp = repeat(reshape(hcat([p.tfor p in _pv]...), nh, 1, ns), 1, ny, 1)\npv = repeat(reshape(hcat([p.power for p in _pv]...), nh, 1, ns), 1, ny, 1)\nld_E = repeat(reshape(hcat([ld.power for ld in _ld_E]...), nh, 1, ns), 1, ny, 1)\nld_H = repeat(reshape(hcat([ld.power for ld in _ld_H]...), nh, 1, ns), 1, ny, 1)\n\n# Define scenarios with costs\nω = Dict(\n    \"pv\" => (t = timestamp, power = pv, cost = 1300 * ones(ny, ns)),  # Scenario for PV with timestamp, power and cost\n    \"ld_E\" => (t = timestamp, power = ld_E),  # Scenario for Electric Load with timestamp and power\n    \"ld_H\" => (t = timestamp, power = ld_H),  # Scenario for Heat Load with timestamp and power\n    \"liion\" => (cost = 300 * ones(ny, ns),),  # Scenario for Lithium-ion batteries with cost\n    \"tes\" => (cost = 10 * ones(ny, ns),),  # Scenario for Thermal Energy Storage with cost\n    \"h2tank\" => (cost = 10 * ones(ny, ns),),  # Scenario for Hydrogen Storage Tank with cost\n    \"elyz\" => (cost = 1300 * ones(ny, ns),),  # Scenario for Electrolyzer with cost\n    \"fc\" => (cost = 1700 * ones(ny, ns),),  # Scenario for Fuel Cell with cost\n    \"heater\" => (cost = 0 * ones(ny, ns),),  # Scenario for Heater with cost\n    \"grid\" => (cost_in = 0.19 * ones(nh, ny, ns), cost_out = 0.0001 * ones(nh, ny, ns)),  # Scenario for Grid with cost_in and cost_out\n)\n\n# Save scenarios as .jld files\nsave(joinpath(\"data\", \"ausgrid_deterministic.jld\"), \"ω\", ω)","category":"page"},{"location":"Examples.html#Stochastic-generation","page":"Examples","title":"Stochastic generation","text":"","category":"section"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"include(\"..\\\\src\\\\Genesys.jl\")\n\nusing Main.Genesys\nusing Distributions, CSV, JLD, Dates, Seaborn, Statistics, ProgressMeter\n\n# Global constants\nconst nh, ny, ns = 8760, 1, 2000\n\n# Load data related to multiple clients over 3 years\ndata_2010 = load(joinpath(\"stage_scenario\", \"data\", \"clean_dataset_ausgrid_2010_2011.jld\"), \"clean_dataset\")\ndata_2011 = load(joinpath(\"stage_scenario\", \"data\", \"clean_dataset_ausgrid_2011_2012.jld\"), \"clean_dataset\")\ndata_2012 = load(joinpath(\"stage_scenario\", \"data\", \"clean_dataset_ausgrid_2012_2013.jld\"), \"clean_dataset\")\n\n# Find customers with 3 years of data\ncustomers = [k for k in keys(data_2010) if k in keys(data_2011) && k in keys(data_2012)]\n\n# Initialize\ndateformat = Dates.DateFormat(\"dd-u-yyyy\")\n_pv, _ld_E, _ld_H = [], [], []\ns0 = [0., 0., 0.]\nt0 = DateTime(2020,7,1,0)\n\n# For each customer with 3 years of data, we use the data to create three time series (photovoltaic production, electric consumption, heat consumption)\n# These time series are used to construct the states and probabilities of the Markov chains using the \"generator\"\n# We then use this generator to produce a set of ns scenarios at an hourly timestep using \"generate\"\n# The generated scenarios are stored in three lists (_pv, _ld_E, _ld_H)\n\n@showprogress for c in custumers[1:20]\n        # Retrieve the scenario\n        ld_E = (t = hcat(Dates.DateTime.(data_2010[c][\"GC\"][\"time\"][1:nh], dateformat), Dates.DateTime.(data_2011[c][\"GC\"][\"time\"][1:nh], dateformat), Dates.DateTime.(data_2012[c][\"GC\"][\"time\"][1:nh], dateformat)),\n                power = hcat(data_2010[c][\"GC\"][\"power\"][1:nh], data_2011[c][\"GC\"][\"power\"][1:nh], data_2012[c][\"GC\"][\"power\"][1:nh]))\n\n        ld_H = (t = hcat(Dates.DateTime.(data_2010[c][\"CL\"][\"time\"][1:nh], dateformat), Dates.DateTime.(data_2011[c][\"CL\"][\"time\"][1:nh], dateformat), Dates.DateTime.(data_2012[c][\"CL\"][\"time\"][1:nh], dateformat)),\n                power = hcat(data_2010[c][\"CL\"][\"power\"][1:nh], data_2011[c][\"CL\"][\"power\"][1:nh], data_2012[c][\"CL\"][\"power\"][1:nh]))\n\n        pv = (t = hcat(Dates.DateTime.(data_2010[c][\"GG\"][\"time\"][1:nh], dateformat), Dates.DateTime.(data_2011[c][\"GG\"][\"time\"][1:nh], dateformat), Dates.DateTime.(data_2012[c][\"GG\"][\"time\"][1:nh], dateformat)),\n                power = hcat(data_2010[c][\"GG\"][\"power\"][1:nh], data_2011[c][\"GG\"][\"power\"][1:nh], data_2012[c][\"GG\"][\"power\"][1:nh]))\n\n        # Initialize generator\n        generator = Genesys.initialize_generator!(MarkovGenerator(nstate = 20, algo = \"kmeans\"), pv, ld_E, ld_H)\n\n        # Generate\n        ω, proba = Genesys.generate(generator, s0, t0, nh, ny = ny, ns = ns)\n\n        # Store\n        push!(_pv, ω[1])\n        push!(_ld_E, ω[2])\n        push!(_ld_H, ω[3])\nend\n\n# After generating these time series, we will create scenarios for our case study\n# First by aggregating the consumption data to create a case of 5 consumers\n# Then by adding certain elements including pricing which will be necessary for our metrics\n# Finally, we will store all these elements in two dictionaries, one for sizing and one for analysis (resp. optim, simu)\n# These dictionaries will then be saved under the labels ω_optim and ω_simu\n\n\n# Aggregation\n# Randomly chose 5 among the 20 availables\nidx = rand(1:20, 5, ns)\n# Aggregate except for PV\npv = _pv[1]\nld_E = reshape(hcat([sum(ld[:,:,s] for ld in _ld_E[idx[:,s]]) for s in 1:ns]...), nh, ny, ns)\nld_H = reshape(hcat([sum(ld[:,:,s] for ld in _ld_H[idx[:,s]]) for s in 1:ns]...), nh, ny, ns)\n\n# Add first year\ntimestamp = repeat(t0:Hour(1):t0+Hour(nh-1), 1, 2, ns)\npv = cat(pv[:,1,1] .* ones(nh,1,ns), pv, dims=2)\nld_E = cat(ld_E[:,1,1] .* ones(nh,1,ns), ld_E, dims=2)\nld_H = cat(ld_H[:,1,1] .* ones(nh,1,ns), ld_H, dims=2)\n\n# Operating cost\n# Flat rate including taxes, etc. - from eurostat - projected evolution over 20 years\n_cost_in = compute_operating_cost_scenarios(0.19 * ones(nh), Normal(1.04, 0.04), nh, 20, ns)\n_cost_out = compute_operating_cost_scenarios(0.0001 * ones(nh), Normal(1., 0.), nh, 20, ns)\n# Averaged cost\ncost_in = mean(_cost_in, dims=2)\ncost_out = mean(_cost_out, dims=2)\n# Add first year\ncost_in = cat(0.19 * ones(nh, 1, ns), cost_in, dims=2)\ncost_out = cat(0.0001 * ones(nh, 1, ns), cost_out, dims=2)\n\n# Investment cost - from Petkov & Gabrielli, 2020\ncost_pv = 1300 * ones(2, ns)\ncost_liion = 300 * ones(2, ns)\ncost_tes = 10 * ones(2, ns)\ncost_h2tank = 10 * ones(2, ns)\ncost_elyz = 1300 * ones(2, ns)\ncost_fc = 1700 * ones(2, ns)\ncost_heater = 0 * ones(2, ns)\n\n# Here we can devide the set of scenario in two keeping one half for sizing and one for assessing\n# Scenarios\nω_optim = Dict(\n\"pv\" => (t = timestamp[:,:,2:2:end], power = pv[:,:,2:2:end], cost = cost_pv[:,2:2:end]),\n\"ld_E\" => (t = timestamp[:,:,2:2:end], power = ld_E[:,:,2:2:end]),\n\"ld_H\" => (t = timestamp[:,:,2:2:end], power = ld_H[:,:,2:2:end]),\n\"liion\" => (cost = cost_liion[:,2:2:end],),\n\"tes\" => (cost = cost_tes[:,2:2:end],),\n\"h2tank\" => (cost = cost_h2tank[:,2:2:end],),\n\"elyz\" => (cost = cost_elyz[:,2:2:end],),\n\"fc\" => (cost = cost_fc[:,2:2:end],),\n\"heater\" => (cost = cost_heater[:,2:2:end],),\n\"grid\" => (cost_in = cost_in[:,:,2:2:end], cost_out = cost_out[:,:,2:2:end]),\n)\n\n# ... and odd number scenarios for simulation\nω_simu = Dict(\n\"pv\" => (t = timestamp[:,:,1:2:end], power = pv[:,:,1:2:end], cost = cost_pv[:,1:2:end]),\n\"ld_E\" => (t = timestamp[:,:,1:2:end], power = ld_E[:,:,1:2:end]),\n\"ld_H\" => (t = timestamp[:,:,1:2:end], power = ld_H[:,:,1:2:end]),\n\"liion\" => (cost = cost_liion[:,1:2:end],),\n\"tes\" => (cost = cost_tes[:,1:2:end],),\n\"h2tank\" => (cost = cost_h2tank[:,1:2:end],),\n\"elyz\" => (cost = cost_elyz[:,1:2:end],),\n\"fc\" => (cost = cost_fc[:,1:2:end],),\n\"heater\" => (cost = cost_heater[:,1:2:end],),\n\"grid\" => (cost_in = cost_in[:,:,1:2:end], cost_out = cost_out[:,:,1:2:end]),\n)\n\n# Save scenarios as .jld files\nsave(joinpath(\"data\", \"ausgrid_5_twostage.jld\"), \"ω_optim\", ω_optim, \"ω_simu\", ω_simu)","category":"page"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"For more information on  initialize_generator and  generate see Scenario page","category":"page"},{"location":"Examples.html#Optimizing-and-Simulating-the-Microgrid","page":"Examples","title":"Optimizing and Simulating the Microgrid","text":"","category":"section"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"Once you have generated the data scenarios for your microgrid system, you can optimize and simulate its performance using the functions provided in our package. In this section, we demonstrate how to perform optimization and simulation using the data scenarios created in the previous section.","category":"page"},{"location":"Examples.html#Constructing-the-grid","page":"Examples","title":"Constructing the grid","text":"","category":"section"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"The first step is to build the microgrid get the data and add assets to it. The following code show this process for the case of a single energy grid with battery storage and Solar panel over 21 years for 1 scenario. For more details about the assets see Assets page","category":"page"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"\nusing JLD, Dates\n\nconst nh, ny, ns = 8760, 21, 1 #nh = number of timestep per year, ny = time horizon (in years), ns = number of scenario used\n\ndata = load(joinpath(\"example\",\"data\",\"ausgrid_5_twostage.jld\")) #Get the data for scenarios \n\nmicrogrid = Microgrid(parameters = GlobalParameters(nh, ny, ns, renewable_share = 1.)) # Instantiate a Microgrid \n\n\nadd!(microgrid, Demand(carrier = Electricity()),\n                Solar(),\n                Liion_electro_chimique(),\n                Grid(carrier = Electricity())) # Add assets to it\n\nω_d = Scenarios(microgrid, data[\"ω_optim\"]) # Build the right number of scenarios with the right length for the microgrid\n","category":"page"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"It is also possible to get 2 set of scenarios as explained in section Stochastic generation of this page. One for design and one for assessment.","category":"page"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"ω_d, ω_a = Scenarios(microgrid, data[\"ω_optim\"]), Scenarios(microgrid, data[\"ω_simu\"])","category":"page"},{"location":"Examples.html#Sizing-the-grid","page":"Examples","title":"Sizing the grid","text":"","category":"section"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"The sizing is performed by a component called designer. Several type of designer are implemented and their role is to determine the size of the asset. The simplest designer is the manual one where the user chose mannually the size of the assets. Other designer use optimization to provide a size, different optimization methods are implemented, exact and stochastic ones.","category":"page"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"Considering a grid mg, in order to determine the size of its assets, ","category":"page"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"one can use it's own design and use a Manual design.","category":"page"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"PV_size = 20.\nBAT_size = 40.                \ndesigner = initialize_designer!(mg, Manual(generations = [PV_size], storages = [BAT_size], subscribed_power = [5.]), ω_d)","category":"page"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"Manual design require a vector of values for the size of the generation assets, storage assets and grid assets.","category":"page"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"Other design methods can be used with the following code. Here an example for the MILP designer","category":"page"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"initialize_designer!(microgrid, MILP(options = MILPOptions(reducer = ManualReducer(y=1:1, s=1:1))), ω_d)","category":"page"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"Please note that the models used in the MILP formulation are linear models. Even if you added a more fine battery model.","category":"page"},{"location":"Examples.html#Operating-the-grid","page":"Examples","title":"Operating the grid","text":"","category":"section"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"To make the decisions during the simulation the grid need to be controlled. This role is taken by the Controller. A controller is going to operate the grid during the simulation, their is several type of controller implemented (Need to add reference or details) here. The simplest ones are Rule Based Controller RBC.  ","category":"page"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"controller = initialize_controller!(microgrid,  RBC(options = RBCOptions(policy_selection = 2 )), ω_d)","category":"page"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"More complexe controller using optimisation with varying range of sight can also be used.","category":"page"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"controller = initialize_controller!(microgrid, Anticipative(generations = [10.], storages = [20.], converters = []), designer, ω_d)","category":"page"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"Please note that the models used in the MILP formulation are linear models. Even if you added a more fine battery model.","category":"page"},{"location":"Examples.html#Simulating","page":"Examples","title":"Simulating","text":"","category":"section"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"Now that everything is declared the microgrid can be simulated to assess techno-economic indicators.","category":"page"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"@time simulate!(microgrid, controller, designer, ω_a, options = Genesys.Options(mode = \"serial\", firstyear = false))","category":"page"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"Here the microgrid will be simulated using the sizing stored in desginer, the operation stored in controller under the conditions of ω_a. The first year option can be use to compare a first year without any asset installed (as some kind of reference) to another year. ","category":"page"},{"location":"Examples.html#Extracting-Metrics-and-Figures","page":"Examples","title":"Extracting Metrics and Figures","text":"","category":"section"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"After optimizing and simulating your microgrid system, you may want to analyze its performance by extracting relevant metrics and creating visualizations. In this section, we provide examples of how to use our package to generate these metrics and figures.","category":"page"},{"location":"Examples.html","page":"Examples","title":"Examples","text":" #Example code: Generating Metrics and Figures","category":"page"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"Once you have completed the examples in this document, you should be familiar with the main functionalities of our Julia package for modeling, optimizing, and simulating microgrids. If you have any questions or need further assistance, please refer to our package documentation or contact us for support.","category":"page"},{"location":"index.html#Microgrid_Genesys.jl","page":"Microgrid_Genesys.jl","title":"Microgrid_Genesys.jl","text":"","category":"section"},{"location":"index.html","page":"Microgrid_Genesys.jl","title":"Microgrid_Genesys.jl","text":"A toolbox for modeling, optimizing and simulating microgrids developped by the Genesys team at LAPLACE laboratory, Toulouse, France","category":"page"},{"location":"index.html#Table-Of-Contents","page":"Microgrid_Genesys.jl","title":"Table Of Contents","text":"","category":"section"},{"location":"index.html","page":"Microgrid_Genesys.jl","title":"Microgrid_Genesys.jl","text":"","category":"page"},{"location":"index.html#Package-features","page":"Microgrid_Genesys.jl","title":"Package features","text":"","category":"section"},{"location":"index.html","page":"Microgrid_Genesys.jl","title":"Microgrid_Genesys.jl","text":"In this page, we'll provide an overview of the main components and features of the Genesys module.","category":"page"},{"location":"index.html#Main-Components","page":"Microgrid_Genesys.jl","title":"Main Components","text":"","category":"section"},{"location":"index.html","page":"Microgrid_Genesys.jl","title":"Microgrid_Genesys.jl","text":"The Genesys module includes the following main components:","category":"page"},{"location":"index.html","page":"Microgrid_Genesys.jl","title":"Microgrid_Genesys.jl","text":"Assets: Microgrid components, such as demand, solar, liion, thermal storage, and grid.\nScenarios: Tools for generating and reducing scenarios for simulations.\nOptimization: Design and operation optimization tools, including controllers and designers.\nSimulation: Functions for simulating microgrids over different time horizons and scenarios.\nUtils: Utilities for metrics, plotting, and data saving.","category":"page"},{"location":"index.html#Key-Features","page":"Microgrid_Genesys.jl","title":"Key Features","text":"","category":"section"},{"location":"index.html","page":"Microgrid_Genesys.jl","title":"Microgrid_Genesys.jl","text":"The Genesys module offers a wide range of features for microgrid simulations and optimizations:","category":"page"},{"location":"index.html","page":"Microgrid_Genesys.jl","title":"Microgrid_Genesys.jl","text":"A flexible and extensible structure that allows for the incorporation of different asset types, descriptive models and optimization algorithms.\nA comprehensive set of optimization tools, including dummy, anticipative, rule-based control, and online learning for frequency control.\nScenario generation and reduction techniques for efficient and accurate simulations.\nBuilt-in plotting and metrics utilities for easy analysis and visualization of results.","category":"page"},{"location":"index.html","page":"Microgrid_Genesys.jl","title":"Microgrid_Genesys.jl","text":"To learn more about how to use the Genesys module, please refer to the other pages in this documentation. To learn to use the key features of this module please refer to the example page.","category":"page"},{"location":"documentation.html#Structures-and-Functions","page":"Structures and Functions","title":"Structures and Functions","text":"","category":"section"},{"location":"documentation.html#Microgrid","page":"Structures and Functions","title":"Microgrid","text":"","category":"section"},{"location":"documentation.html","page":"Structures and Functions","title":"Structures and Functions","text":"Genesys.Microgrid\nGenesys.GlobalParameters","category":"page"},{"location":"documentation.html#Genesys.Microgrid","page":"Structures and Functions","title":"Genesys.Microgrid","text":"Microgrid()\n\nStructure containing every element/component of the microgrid including immaterial ones like electrical demands.\n\nFields:\n\nparameters::GlobalParameters\ndemands::Vector{AbstractDemand}\ngenerations::Vector{AbstractGeneration} \nstorages::Vector{AbstractStorage}\nconverters::Vector{AbstractConverter}\ngrids::Vector{AbstractGrid}\n\nElements are divided in 5 categories and stored in 5 vectors with one cell for each element of a type :\n\ndemands inheriting from AbstractDemand and containing a demand one or multiple Main.Genesys.EnergyCarrier (Electricity, Heat ,Hydrogen);\ngenerations inheriting from AbstractGeneration and containing energy production/generation element;\nstorages inheriting from AbstractStorage and containing element responsible for the storage of different energy vectors;\nconverters inheriting from AbstractConverter and containing any element that transform an energy vector into another one;\ngrids inheriting from AbstractGrid and containing elements that sell or buy energy vectors.\n\n(usually an external grid from which can be bought and sold energy);\n\nThese assets (components) can be later added with the add!(mg::Microgrid, assets...)  See also Main.Genesys.add! for a step by step declaration.\n\n\n\n\n\n","category":"type"},{"location":"documentation.html#Genesys.GlobalParameters","page":"Structures and Functions","title":"Genesys.GlobalParameters","text":"mutable struct GlobalParameters\n\nStructure containing global parameter for the simulation and optimization.\n\nThis struct is contained inside the Microgrid struct and provide global parameters for sizing and simulating.\n\nParameters :\n\n(in sizing context) the number of operation and investment stages (ny, nh) or \n\n(in simulation context) Time horizon and number of operation per year (ny, nh); \n\nthe number of scenario (ns);\noptionnal : the yearly and hourly time steps (Δh, Δy) [default = (1,1)];\noptionnal : the inlation rate (τ) [default = 0.045];\noptionnal : the minimum renewable_share [default = 0.]\n\n\n\n\n\n","category":"type"},{"location":"documentation.html#Storages","page":"Structures and Functions","title":"Storages","text":"","category":"section"},{"location":"documentation.html#Batteries","page":"Structures and Functions","title":"Batteries","text":"","category":"section"},{"location":"documentation.html","page":"Structures and Functions","title":"Structures and Functions","text":"Genesys.AbstractLiion\nGenesys.Liion","category":"page"},{"location":"documentation.html#Genesys.AbstractLiion","page":"Structures and Functions","title":"Genesys.AbstractLiion","text":"abstract type AbstractLiion <: AbstractStorage  end\n\nAn abstract type, parent of all Liion types\n\n\n\n\n\n","category":"type"},{"location":"documentation.html#Genesys.Liion","page":"Structures and Functions","title":"Genesys.Liion","text":"Liion\n\nA mutable struct representing a Li-ion battery model with state of charge (SoC) computation and aging models.\n\nParameters\n\neff_model::AbstractLiionEffModel: Model for state of charge computation.\nSoH_model::AbstractLiionAgingModel: Model for aging computation.\nα_soc_min::Float64: Minimum threshold of charge (normalized).\nα_soc_max::Float64: Maximum threshold of charge (normalized).\nbounds::NamedTuple{(:lb, :ub), Tuple{Float64, Float64}}: Lower and upper bounds for the battery capacity.\nSoH_threshold::Float64: State of health (SoH) level to replace the battery.\ncouplage::NamedTuple{(:E, :R), Tuple{Bool, Bool}}: Tuple to indicate if SoH should influence other parameters.\n\nInitial Conditions\n\nErated_ini::Float64: Initial capacity of the battery in Wh.\nsoc_ini::Float64: Initial state of charge for the beginning of the simulation.\nsoh_ini::Float64: Initial state of health for the beginning of the simulation.\n\nVariables\n\nErated::AbstractArray{Float64, 2}: Battery capacity.\ncarrier::Electricity: Type of energy.\nsoc::AbstractArray{Float64, 3}: 3-dimensional matrix (h, y, s) containing the state of charge [0-1].\nsoh::AbstractArray{Float64, 3}: 3-dimensional matrix (h, y, s) containing the state of health [0-1].\n\nEco\n\ncost::AbstractArray{Float64, 2}: Economic cost.\n\nExample\n\njulia Liion(eff_model = PolynomialLiionEfficiency(), SoH_model = FixedLifetimeLiion())\n\n\n\n\n\n","category":"type"},{"location":"documentation.html#Battery-Efficiency-Models","page":"Structures and Functions","title":"Battery Efficiency Models","text":"","category":"section"},{"location":"documentation.html","page":"Structures and Functions","title":"Structures and Functions","text":"Genesys.AbstractLiionEffModel\nGenesys.FixedLiionEfficiency\nGenesys.PolynomialLiionEfficiency","category":"page"},{"location":"documentation.html#Genesys.AbstractLiionEffModel","page":"Structures and Functions","title":"Genesys.AbstractLiionEffModel","text":"abstract type AbstractLiionEffModel end\n\nAn abstract type, parent of all Liion efficieny model types\n\n\n\n\n\n","category":"type"},{"location":"documentation.html#Genesys.FixedLiionEfficiency","page":"Structures and Functions","title":"Genesys.FixedLiionEfficiency","text":"FixedLiionEfficiency <: AbstractLiionEffModel\n\nA mutable struct that represents a Li-ion battery efficiency model for SoC computation. This model implement a fixed efficiency that can decrease linearly with battery aging.\n\nParameters:\n\nη_ch::Float64: Charging efficiency (default : 0.98)\nη_dch::Float64: Discharging efficiency (default : 0.98)\nα_p_ch::Float64: Maximum charging C-rate (default : 1.5)\nα_p_dch::Float64: Maximum discharging C-rate (default : 1.5)\nη_deg_coef::Float64: The efficiency degradation coefficient (default : 0.2303,  ref : Redondo Iglesias - Efficiency Degradation Model of Lithium-Ion Batteries for Electric Vehicles)\ncouplage::NamedTuple{(:E, :R), Tuple{Bool, Bool}}: Named tuple with two boolean values to indicate if the SoH should influence the other parameters (E stand for capacity coupling and R for efficiency coupling) (default : (E = true, R = true))\nη_self::Float64: Named tuple with two boolean values to indicate if the SoH should influence the other parameters (E stand for capacity coupling and R for efficiency coupling) (default : 0.0005)\n\nExample\n\nFixedLiionEfficiency()\n\n\n\n\n\n","category":"type"},{"location":"documentation.html#Genesys.PolynomialLiionEfficiency","page":"Structures and Functions","title":"Genesys.PolynomialLiionEfficiency","text":"PolynomialLiionEfficiency <: AbstractLiionEffModel\n\nA mutable struct that represents a Li-ion battery efficiency model with polynomial efficiency characteristics for SoC computation. This model implements an efficiency model based on polynomial coefficients of the form ax² + bx + c  that can be used to calculate efficiency.\n\nParameters:\n\na_η_ch::Float64: Coefficient 'a' for charging efficiency (default: 0.0033)\nb_η_ch::Float64: Coefficient 'b' for charging efficiency (default: 0.0297)\nc_η_ch::Float64: Coefficient 'c' for charging efficiency (default: 0.99814)\na_η_dch::Float64: Coefficient 'a' for discharging efficiency (default: 0.002232)\nb_η_dch::Float64: Coefficient 'b' for discharging efficiency (default: 0.0246)\nc_η_dch::Float64: Coefficient 'c' for discharging efficiency (default: 1)\nη_deg_coef::Float64: The efficiency degradation coefficient (default: 0.2303, ref: Redondo Iglesias - Efficiency Degradation Model of Lithium-Ion Batteries for Electric Vehicles)\ncouplage::NamedTuple{(:E, :R), Tuple{Bool, Bool}}: Named tuple with two boolean values to indicate if the SoH should influence the other parameters (E stands for capacity coupling and R for efficiency coupling) (default: (E = true, R = false))\nα_p_ch::Float64: Maximum charging C-rate (default: 1.5)\nα_p_dch::Float64: Maximum discharging C-rate (default: 1.5)\nη_self::Float64: Auto-discharge factor (default: 0.0005)\n\nExample\n\nPolynomialLiionEfficiency()\n\n\n\n\n\n","category":"type"},{"location":"documentation.html#Battery-Aging-Models","page":"Structures and Functions","title":"Battery Aging Models","text":"","category":"section"},{"location":"documentation.html","page":"Structures and Functions","title":"Structures and Functions","text":"Genesys.AbstractLiionAgingModel\nGenesys.EnergyThroughputLiion\nGenesys.FixedLifetimeLiion\nGenesys.RainflowLiion\nGenesys.SemiEmpiricalLiion","category":"page"},{"location":"documentation.html#Genesys.AbstractLiionAgingModel","page":"Structures and Functions","title":"Genesys.AbstractLiionAgingModel","text":"abstract type AbstractLiionAgingModel end\n\nAn abstract type, parent of all Liion aging model types\n\n\n\n\n\n","category":"type"},{"location":"documentation.html#Genesys.EnergyThroughputLiion","page":"Structures and Functions","title":"Genesys.EnergyThroughputLiion","text":"EnergyThroughputLiion <: AbstractLiionAgingModel\n\nA mutable struct that represents an aging model for Li-ion batteries based on energy throughput, which accounts for calendar aging and cycling aging. This model calculates aging based on the cumulative energy throughput and additionnaly calendar aging.\n\nParameters:\n\ncalendar::Bool: A boolean value to indicate whether to consider calendar aging (default: true)\nnCycle::Int64: An adjusted number of cycle to reach the SoH replacement threshold after nCycle_ini cycles (default: 6000)\nnCycle_ini::Int64: The total number of cycles achievable before reaching EOL(default: 6000). \nΔcal::Float64: The calendar aging parameter (default: 1 - exp(-4.14e-10 * 3600))\n\nExample\n\njulia EnergyThroughputLiion(;nCycle_ini = Int(floor(fatigue_data.cycle[findfirst(fatigue_data.DoD .> (0.6))])))\n\nThis set the feasible number of cycles corresponding to the number of 60% DoD cycles in the cycle-to-failure curve (named fatigue_data). Supposing that fatigue data is a dataframe with a cycle column and a DoD column\n\n\n\n\n\n","category":"type"},{"location":"documentation.html#Genesys.FixedLifetimeLiion","page":"Structures and Functions","title":"Genesys.FixedLifetimeLiion","text":"FixedLifetimeLiion <: AbstractLiionAgingModel\n\nA mutable struct that represents an aging model for Li-ion batteries with a fixed lifetime in years.\n\nParameters:\n\nlifetime::Int64: The fixed lifetime of the battery in years (default: 12)\n\nExample\n\nFixedLifetimeLiion()\n\n\n\n\n\n","category":"type"},{"location":"documentation.html#Genesys.RainflowLiion","page":"Structures and Functions","title":"Genesys.RainflowLiion","text":"RainflowLiion <: AbstractLiionAgingModel\n\nA mutable struct that represents an aging model for Li-ion batteries based on rainflow cycle counting, considering calendar aging and cycling aging.\n\nParameters:\n\ncalendar::Bool: A boolean value for the activation of calendar aging (default: true)\nupdate_by_year::Int64: Number of updates each year (default: 12)\nfatigue_data::DataFrames.DataFrame: Cycle to failure curve data (default: loaded from a CSV file with a DoD column and a nCycle column)\n\nExample\n\njulia RainflowLiion(fatigue_data = fatigue_data)\n\nsupposing that fatigue_data is a dataframe with a cycle column and a DoD column\n\n\n\n\n\n","category":"type"},{"location":"documentation.html#Genesys.SemiEmpiricalLiion","page":"Structures and Functions","title":"Genesys.SemiEmpiricalLiion","text":"SemiEmpiricalLiion <: AbstractLiionAgingModel\n\nA mutable struct that represents an aging model for Li-ion batteries based on a semi-empirical model, accounting for temperature and other parameters.\n\nParameters:\n\nupdate_by_year::Int64: Number of updates each year (default: 12)\nParameters for NMC bateries (as in Technoeconomic model of second-life batteries for utility-scale solar considering calendar and cycle aging Ian Mathews, Bolun Xu, Wei He, Vanessa Barreto, Tonio Buonassisi, Ian Marius Peters):\nalpha_sei::Float64\nbeta_sei::Float64\nk_delta1::Float64\nk_delta2::Float64\nk_sigma::Float64\nsigma_ref::Float64\nk_T::Float64\nT_ref::Float64\nk_t::Float64\ntemperature::Float64: Temperature of the battery in Kelvin (default: 298)\nSum_fd::AbstractArray{Float64,1}: Used as a memory of the cumulated fatigue of the battery\n\nExample\n\nSemiEmpiricalLiion()\n\n\n\n\n\n","category":"type"},{"location":"documentation.html#Thermal-Storage","page":"Structures and Functions","title":"Thermal Storage","text":"","category":"section"},{"location":"documentation.html","page":"Structures and Functions","title":"Structures and Functions","text":"Genesys.ThermalStorage","category":"page"},{"location":"documentation.html#Genesys.ThermalStorage","page":"Structures and Functions","title":"Genesys.ThermalStorage","text":"mutable struct ThermalStorage <: AbstractStorage\n\nA mutable struct representing a thermal energy storage model with various parameters, initial conditions, variables, and an inner constructor.\n\nParameters\n\nα_p_ch::Float64: Maximum charging power factor\nα_p_dch::Float64: Maximum discharging power factor\neff_model::AbstractTESEffModel: Efficiency model \nα_soc_min::Float64: Minimum state of charge factor\nα_soc_max::Float64: Maximum state of charge factor\nSoH_model::AbstractTESAgingModel: Storage aging model (fixed lifetime in years)\nbounds::NamedTuple{(:lb, :ub), Tuple{Float64, Float64}}: Lower and upper bounds of storage capacity\nErated_ini::Float64: Initial rated storage energy capacity\nsoc_ini::Float64: Initial state of charge\nsoh_ini::Float64: Initial state of health\nErated::AbstractArray{Float64,2}: Rated storage energy capacity over time and scenarios\ncarrier::Heat: Heat carrier for the thermal storage\nsoc::AbstractArray{Float64,3}: State of charge over time, years, and scenarios\ncost::AbstractArray{Float64,2}: Cost of the thermal storage over time and scenarios\n\n\n\n\n\n","category":"type"},{"location":"documentation.html#Hydrogen","page":"Structures and Functions","title":"Hydrogen","text":"","category":"section"},{"location":"documentation.html","page":"Structures and Functions","title":"Structures and Functions","text":"Genesys.H2Tank","category":"page"},{"location":"documentation.html#Genesys.H2Tank","page":"Structures and Functions","title":"Genesys.H2Tank","text":"mutable struct H2Tank  <: AbstractStorage\n\nA mutable struct representing a hydrogen tank storage model with various parameters, initial conditions, variables, and an inner constructor.\n\nParameters\n\nα_p_ch::Float64: Maximum charging power factor (default: 1.5)\nα_p_dch::Float64: Maximum discharging power factor (default: 1.5)\nη_ch::Float64: Charging efficiency (default: 1.0)\nη_dch::Float64: Discharging efficiency (default: 1.0)\nη_self::Float64: Self-discharge rate (default: 0.0)\nα_soc_min::Float64: Minimum state of charge factor (default: 0.0)\nα_soc_max::Float64: Maximum state of charge factor (default: 1.0)\nlifetime::Int64: Storage lifetime in years (default: 25)\nbounds::NamedTuple{(:lb, :ub), Tuple{Float64, Float64}}: Lower and upper bounds of storage capacity (default: (lb = 0., ub = 10000.))\nErated_ini::Float64: Initial rated storage energy capacity (default: 1e-6)\nsoc_ini::Float64: Initial state of charge (default: 0.5)\nsoh_ini::Float64: Initial state of health (default: 1.0)\nErated::AbstractArray{Float64,2}: Rated storage energy capacity over time and scenarios\ncarrier::Hydrogen: Hydrogen carrier for the H2 tank\nsoc::AbstractArray{Float64,3}: State of charge over time, years, and scenarios\ncost::AbstractArray{Float64,2}: Cost of the hydrogen storage over time and scenarios\n\n\n\n\n\n","category":"type"},{"location":"documentation.html#Generation","page":"Structures and Functions","title":"Generation","text":"","category":"section"},{"location":"documentation.html","page":"Structures and Functions","title":"Structures and Functions","text":"Genesys.Solar","category":"page"},{"location":"documentation.html#Genesys.Solar","page":"Structures and Functions","title":"Genesys.Solar","text":"mutable struct Solar <: AbstractGeneration\n\nA mutable struct representing a solar power generation source. It contains information about the lifetime, bounds, initial conditions, variables, and costs related to the solar generation.\n\nParameters\n\n-SoH_model::AbstractPVAgingModel (default: FixedLifetimeSolar(25)): The aging model with a fixed lifetime of the solar power generation system. -bounds::NamedTuple{(:lb, :ub), Tuple{Float64, Float64}} (default: (lb = 0., ub = 1000.)): The lower and upper bounds of the solar power generation system. -powerMax_ini::Float64 (default: 0.): The initial maximum power output of the solar power generation system. -soh_ini::Float64 (default: 1.): The initial state of health of the solar power generation system.\n\n\n\n\n\n","category":"type"},{"location":"documentation.html#Carrier","page":"Structures and Functions","title":"Carrier","text":"","category":"section"},{"location":"documentation.html","page":"Structures and Functions","title":"Structures and Functions","text":"Genesys.EnergyCarrier\nGenesys.Electricity\nGenesys.Heat\nGenesys.Hydrogen","category":"page"},{"location":"documentation.html#Genesys.EnergyCarrier","page":"Structures and Functions","title":"Genesys.EnergyCarrier","text":"abstract type EnergyCarrier end\n\nAn abstract type, parent of all energy carrier types (electricity, heat, hydrogen...)\n\n\n\n\n\n","category":"type"},{"location":"documentation.html#Genesys.Electricity","page":"Structures and Functions","title":"Genesys.Electricity","text":"Electricity\n\nA mutable struct representing electricity as an energy carrier. It is a subtype of EnergyCarrier.\n\nFields\n\npower::AbstractArray{Float64,3}: A 3-dimensional array of power values associated with electricity.\n\nExample\n\nElectricity()\n\n\n\n\n\n","category":"type"},{"location":"documentation.html#Genesys.Heat","page":"Structures and Functions","title":"Genesys.Heat","text":"Heat\n\nA mutable struct representing heat as an energy carrier. It is a subtype of EnergyCarrier.\n\nFields\n\npower::AbstractArray{Float64,3}: A 3-dimensional array of power values associated with heat.\n\nExample\n\nHeat()\n\n\n\n\n\n","category":"type"},{"location":"documentation.html#Genesys.Hydrogen","page":"Structures and Functions","title":"Genesys.Hydrogen","text":"Hydrogen\n\nA mutable struct representing hydrogen as an energy carrier. It is a subtype of EnergyCarrier.\n\nFields\n\npower::AbstractArray{Float64,3}: A 3-dimensional array of power values associated with hydrogen.\n\nHydrogen()\n\n\n\n\n\n","category":"type"},{"location":"documentation.html#Converter","page":"Structures and Functions","title":"Converter","text":"","category":"section"},{"location":"documentation.html","page":"Structures and Functions","title":"Structures and Functions","text":"Genesys.Electrolyzer\nGenesys.FuelCell\nGenesys.Heater","category":"page"},{"location":"documentation.html#Genesys.Electrolyzer","page":"Structures and Functions","title":"Genesys.Electrolyzer","text":"\n\n\n\n","category":"type"},{"location":"documentation.html#Genesys.FuelCell","page":"Structures and Functions","title":"Genesys.FuelCell","text":"FuelCell represents the main structure for modeling fuel cell behavior, including efficiency, aging, and other key parameters.\n\nFields\n\neff_model::AbstractFuelCellEffModel: The efficiency model used to calculate fuel cell efficiency.\nSoH_model::AbstractFuelCellAgingModel: The aging model used to track the State of Health (SoH) of the fuel cell over time.\ncouplage::Bool: Indicates whether the SoH should influence other parameters (e.g., efficiency, output voltage).\nbounds::NamedTuple{(:lb, :ub), Tuple{Float64, Float64}}: Bounds for operational parameters, such as voltage or power.\nSoH_threshold::Float64: SoH level at which the fuel cell should be replaced.\nV_J_ini::AbstractArray{Float64,2}: Initial voltage-current relationship for the fuel cell.\nsoh_ini::Float64: Initial SoH at the start of the simulation (default: 1.0, corresponding to 100% health).\nN_cell::Int64: Number of cells assembled in the fuel cell stack.\nsurface::Float64: Surface area of the fuel cell stack (unit should be documented if relevant).\nη::AbstractArray{Float64,3}: Efficiency evolution over time (hydrogen to electricity).\ncarrier::Vector{EnergyCarrier}: Vector of energy carriers used by the fuel cell (e.g., hydrogen, oxygen).\nsoh::AbstractArray{Float64,3}: Time-evolving State of Health for the fuel cell.\ncost::AbstractArray{Float64,2}: Economic metrics associated with fuel cell operation (e.g., cost per hour, maintenance).\n\nConstructor Parameters\n\neff_model::AbstractFuelCellEffModel=PolarizationFuelCellEfficiency(): Efficiency model to be used.\nSoH_model::AbstractFuelCellAgingModel=PowerAgingFuelCell(): Aging model to be used.\ncouplage::Bool=true: Whether SoH influences other parameters.\nbounds=(lb=0.0, ub=50.0): sizing power bounds for all-in-one design.\nSoH_threshold::Float64=0.9: SoH replacement threshold (default: 90%).\nV_J_ini::AbstractArray{Float64,2}: Initial voltage-current data (default loaded from a CSV file).\nsoh_ini::Float64=1.0: Initial SoH at the start of the simulation.\n\nExample\n\nfuel_cell = FuelCell(eff_model=PolarizationFuelCellEfficiency(),\n                     SoH_model=PowerAgingFuelCell(),\n                     couplage=true,\n                     bounds=(lb=0.0, ub=60.0),\n                     SoH_threshold=0.8,\n                     soh_ini=1.0)\n\nThis initializes a FuelCell structure with custom sizing power bounds and a lower SoH replacement threshold.\n\n\n\n\n\n","category":"type"},{"location":"documentation.html#Genesys.Heater","page":"Structures and Functions","title":"Genesys.Heater","text":"mutable struct Heater <: AbstractConverter\n\nA mutable struct representing a Heater, which is a subtype of AbstractConverter.\n\nParameters\n\neff_model::AbstractHeaterEffModel: The model for conversion efficiency of the heater.\nSoH_model::AbstractHeaterAgingModel: The aging model for the heater. The default model use a fixed expected lifetime for the heater (in years).\nbounds::NamedTuple{(:lb, :ub), Tuple{Float64, Float64}}: The lower and upper bounds of the heater's power.\npowerMax_ini::Float64: The initial maximum power output of the heater.\nsoh_ini::Float64: The initial state of health of the heater.\n\nVariables\n\npowerMax::AbstractArray{Float64,2}: The maximum power output of the heater.\ncarrier::Vector{Any}: The carrier vector.\ncost::AbstractArray{Float64,2}: The cost associated with the heater.\n\nExample\n\nheater = Heater(eff_model=ConstEfficiencyHeater(η_E_H=1.0), SoH_model=FixedLifetimeHeater(lifetime=25), bounds=(lb=30.0, ub=30.0), powerMax_ini=30.0, soh_ini=1.0)\n\n\n\n\n\n","category":"type"},{"location":"documentation.html#Demand","page":"Structures and Functions","title":"Demand","text":"","category":"section"},{"location":"documentation.html","page":"Structures and Functions","title":"Structures and Functions","text":"Genesys.Demand","category":"page"},{"location":"documentation.html#Genesys.Demand","page":"Structures and Functions","title":"Genesys.Demand","text":"Demand(; carrier = Electricity())\n\nA mutable struct representing energy demand in the grid. The struct is a subtype of AbstractDemand.\n\nParameters\n\ncarrier::EnergyCarrier: The type of energy carrier for the demand (e.g., Electricity, Heat, etc.) this structre also contains the quantity for each timestamp. see Main.Genesys.EnergyCarrier\ntimestamp::Array{DateTime,3}: A 3-dimensional array of DateTime objects representing timestamps associated with the demand.\n\nExample\n\ndemand = Demand(carrier = Electricity())\n\n\n\n\n\n","category":"type"},{"location":"documentation.html#grid","page":"Structures and Functions","title":"grid","text":"","category":"section"},{"location":"documentation.html","page":"Structures and Functions","title":"Structures and Functions","text":"Genesys.Grid","category":"page"},{"location":"documentation.html#Genesys.Grid","page":"Structures and Functions","title":"Genesys.Grid","text":"mutable struct Grid <: AbstractGrid\n\nA mutable struct representing a Grid, which is a subtype of AbstractGrid.\n\nParameters\n\npowerMax::Float64: The maximum power capacity of the grid.\n\nVariables\n\ncarrier::EnergyCarrier: The energy carrier associated with the grid, such as electricity.\ncost_in::AbstractArray{Float64,3}: The input cost associated with the grid.\ncost_out::AbstractArray{Float64,3}: The output cost associated with the grid.\ncost_exceed::AbstractArray{Float64,2}: The cost associated with exceeding the grid's capacity.\n\nExample\n\ngrid = Grid(powerMax=36.0, carrier=Electricity())\n\n\n\n\n\n","category":"type"},{"location":"documentation.html#Scenario","page":"Structures and Functions","title":"Scenario","text":"","category":"section"},{"location":"documentation.html","page":"Structures and Functions","title":"Structures and Functions","text":"Genesys.Scenarios","category":"page"},{"location":"documentation.html#Genesys.Scenarios","page":"Structures and Functions","title":"Genesys.Scenarios","text":"function Scenarios(mg::Microgrid, d::Dict{})\n\nConstructor function for creating a new Scenarios instance based on a given Microgrid and a Dict containing scenario data.\n\nArguments\n\nmg::Microgrid: A Microgrid instance.\nd::Dict{}: A dictionary containing scenario data.\n\nReturns\n\nScenarios: A Scenarios instance with the specified data.\n\nExample\n\nmicrogrid = ...\nscenario_data = ...\n\nscenarios = Scenarios(microgrid, scenario_data)\n\n\n\n\n\nfunction Scenarios(mg::Microgrid, d::Dict{}, same_year::Bool; seed = [])\n\nConstructor function for creating a new Scenarios instance based on a given Microgrid and a Dict containing scenario data. It allows for repetitive years for longer scenarios.\n\nArguments\n\nmg::Microgrid: A Microgrid instance.\nd::Dict{}: A dictionary containing scenario data.\nsame_year::Bool : If true, the function repeats the same year for all years in the microgrid.\nseed::Array=[]: An array specifying the seed for selecting the scenario number and offer reproductivity.\n\nReturns\n\nScenarios: A Scenarios instance with the specified data.\n\nExample\n\nmicrogrid = ...\nscenario_data = ...\n\nscenarios = Scenarios(microgrid, scenario_data, true; seed = [1, 2, 3])\n\n\n\n\n\n","category":"type"},{"location":"documentation.html#Scenarios-Reducer","page":"Structures and Functions","title":"Scenarios Reducer","text":"","category":"section"},{"location":"documentation.html","page":"Structures and Functions","title":"Structures and Functions","text":"Genesys.ManualReducer\nGenesys.SAAReducer\nGenesys.MeanValueReducer\nGenesys.FeatureBasedReducer","category":"page"},{"location":"documentation.html#Genesys.ManualReducer","page":"Structures and Functions","title":"Genesys.ManualReducer","text":"mutable struct ManualReducer <: AbstractScenariosReducer\n    h::Union{UnitRange{Int64}, Int64}\n    y::Union{UnitRange{Int64}, Int64}\n    s::Union{UnitRange{Int64}, Int64}\nend\n\nA mutable structure representing a manual scenario reduction. Inherits from the AbstractScenariosReducer abstract type.\n\nFields\n\nh::Union{UnitRange{Int64}, Int64}: The hours to be included in the reduced scenario.\ny::Union{UnitRange{Int64}, Int64}: The years to be included in the reduced scenario.\ns::Union{UnitRange{Int64}, Int64}: The scenarios to be included in the reduced scenario.\n\nConstructor\n\nManualReducer(; h = 1:8760, y = 2:3, s = 1:1) = new(h, y, s)\n\n\n\n\n\n","category":"type"},{"location":"documentation.html#Genesys.SAAReducer","page":"Structures and Functions","title":"Genesys.SAAReducer","text":"mutable struct SAAReducer <: AbstractScenariosReducer\n    nsample::Int64\nend\n\nA mutable structure representing a Sample Average Approximation (SAA) scenario reduction. Inherits from the AbstractScenariosReducer abstract type.\n\nFields\n\nnsample::Int64: The number of samples to be included in the reduced scenario.\n\nConstructor\n\nSAAReducer(; nsample = 100) = new(nsample)\n\n\n\n\n\n","category":"type"},{"location":"documentation.html#Genesys.MeanValueReducer","page":"Structures and Functions","title":"Genesys.MeanValueReducer","text":"mutable struct MeanValueReducer <: AbstractScenariosReducer\nend\n\nA mutable structure representing an Expected Value (Mean Value) scenario reduction. Inherits from the AbstractScenariosReducer abstract type.\n\nConstructor\n\nMeanValueReducer() = new()\n\n\n\n\n\n","category":"type"},{"location":"documentation.html#Genesys.FeatureBasedReducer","page":"Structures and Functions","title":"Genesys.FeatureBasedReducer","text":"mutable struct FeatureBasedReducer <: AbstractScenariosReducer\n    transformation::Union{UnionAll, Nothing}\n    reduction::Union{AbstractDimensionReducer, Nothing}\n    clustering::AbstractClusteringMethod\nend\n\nA mutable structure representing a Clustering scenario reduction using feature-based methods. Inherits from the AbstractScenariosReducer abstract type.\n\nFields\n\ntransformation: A transformation method to apply before clustering (default: UnitRangeTransform)\nreduction: A dimensionality reduction method to apply before clustering (default: StatsReduction())\nclustering: The clustering method to use (default: KmedoidsClustering())\n\nConstructor\n\nFeatureBasedReducer(; transformation = UnitRangeTransform,\n                    reduction = StatsReduction(),\n                    clustering = KmedoidsClustering()) = new(transformation, reduction, clustering)\n\n\n\n\n\n","category":"type"},{"location":"documentation.html#Dimention-Reducer","page":"Structures and Functions","title":"Dimention Reducer","text":"","category":"section"},{"location":"documentation.html","page":"Structures and Functions","title":"Structures and Functions","text":"Genesys.PCAReduction\nGenesys.StatsReduction","category":"page"},{"location":"documentation.html#Genesys.PCAReduction","page":"Structures and Functions","title":"Genesys.PCAReduction","text":"mutable struct PCAReduction <: AbstractDimensionReducer\n    n_components::Int64\nend\n\nA mutable structure representing Principal Component Analysis (PCA) dimensionality reduction. Inherits from the AbstractDimensionReducer abstract type.\n\nFields\n\nn_components: The number of principal components to use for dimensionality reduction (default: 2)\n\nConstructor\n\nPCAReduction(; n_components = 2) = new(n_components)\n\n\n\n\n\n","category":"type"},{"location":"documentation.html#Genesys.StatsReduction","page":"Structures and Functions","title":"Genesys.StatsReduction","text":"struct StatsReduction <: AbstractDimensionReducer\n\nA structure representing statistics-based dimensionality reduction. Inherits from the AbstractDimensionReducer abstract type.\n\nConstructor\n\nStatsReduction()\n\n\n\n\n\n","category":"type"},{"location":"documentation.html#Transformation","page":"Structures and Functions","title":"Transformation","text":"","category":"section"},{"location":"documentation.html","page":"Structures and Functions","title":"Structures and Functions","text":"Genesys.UnitRangeTransform\nGenesys.ZScoreTransform","category":"page"},{"location":"documentation.html#StatsBase.UnitRangeTransform","page":"Structures and Functions","title":"StatsBase.UnitRangeTransform","text":"Unit range normalization\n\n\n\n\n\n","category":"type"},{"location":"documentation.html#StatsBase.ZScoreTransform","page":"Structures and Functions","title":"StatsBase.ZScoreTransform","text":"Standardization (Z-score transformation)\n\n\n\n\n\n","category":"type"},{"location":"documentation.html#Custering","page":"Structures and Functions","title":"Custering","text":"","category":"section"},{"location":"documentation.html","page":"Structures and Functions","title":"Structures and Functions","text":"Genesys.KmedoidsClustering","category":"page"},{"location":"documentation.html#Genesys.KmedoidsClustering","page":"Structures and Functions","title":"Genesys.KmedoidsClustering","text":"mutable struct KmedoidsClustering <: AbstractClusteringMethod\n\nA structure representing K-medoids clustering method. Inherits from the AbstractClusteringMethod abstract type.\n\nFields\n\nn_clusters::Int64: Number of clusters to form.\ndistance::Distances.SemiMetric: Distance metric to use for calculating the dissimilarity between points.\nlog::Bool: Whether to print logs during the clustering process.\n\nConstructor\n\nKmedoidsClustering(; n_clusters = 20, distance = Distances.Euclidean(), log = true)\n\n\n\n\n\n","category":"type"},{"location":"documentation.html#Generator","page":"Structures and Functions","title":"Generator","text":"","category":"section"},{"location":"documentation.html","page":"Structures and Functions","title":"Structures and Functions","text":"Genesys.MarkovGenerator\nGenesys.AnticipativeGenerator","category":"page"},{"location":"documentation.html#Genesys.MarkovGenerator","page":"Structures and Functions","title":"Genesys.MarkovGenerator","text":"mutable struct MarkovGenerator <: AbstractScenariosGenerator\n\nA structure representing a Markov chain-based scenario generator.\n\nFields\n\nnstate::Int64: Number of states, which corresponds to the number of clusters per hour per month.\nalgo::String: Algorithm used for clustering the states.\nmarkovchains::NamedTuple{(:wk, :wkd), Tuple{MarkovChain, MarkovChain}}: A named tuple containing the Markov chains for weekdays and weekends.\n\nExample\n\nmarkov_generator = MarkovGenerator(nstate=10, algo=\"kmeans\")\n\n\n\n\n\n","category":"type"},{"location":"documentation.html#Genesys.AnticipativeGenerator","page":"Structures and Functions","title":"Genesys.AnticipativeGenerator","text":"mutable struct AnticipativeGenerator <: AbstractScenariosGenerator\n\nA structure representing an anticipative scenario generator (perfect foresight).\n\nFields\n\nforecast: The field to store perfect foresight information.\n\nExample\n\nanticipative_generator = AnticipativeGenerator()\n\n\n\n\n\n","category":"type"},{"location":"documentation.html#Base-generic-function","page":"Structures and Functions","title":"Base generic function","text":"","category":"section"},{"location":"documentation.html#Generate","page":"Structures and Functions","title":"Generate","text":"","category":"section"},{"location":"documentation.html","page":"Structures and Functions","title":"Structures and Functions","text":"Genesys.generate","category":"page"},{"location":"documentation.html#Genesys.generate","page":"Structures and Functions","title":"Genesys.generate","text":"Generate scenarios using a Markov chain.\n\nParameters: generator: a MarkovGenerator object s0: a ny x generator.nstate matrix representing the initial state t0: a DateTime object representing the initial timestamp nstep: an integer representing the number of steps to generate ny: an integer representing the number of scenarios to generate ns: an integer representing the number of seeds for the generator\n\nReturns:\n\na list of ny ny x ns x nstep matrix representing the generated scenarios\na ny x ns matrix representing the probability associated with each generated scenario\n\n\n\n\n\ngenerate(generator::AnticipativeGenerator, s0, t0::DateTime, nstep::Int64; ny::Int64=1, ns::Int64=1, h::Int64=1)\n\nGenerate perfect forecast.\n\nArguments\n\ngenerator::AnticipativeGenerator: Anticipative generator struct.\ns0: Vector of initial state(s).\nt0::DateTime: Initial time.\nnstep::Int64: Number of steps to simulate.\nny::Int64=1: Number of outputs.\nns::Int64=1: Number of scenarios.\nh::Int64=1: Initial time step.\n\nReturns\n\nforecast: Matrix of shape (nstep, ny, ns) with the forecasted values.\nprobs: Array of shape (ny, ns) with the probability distribution of each scenario.\n\n\n\n\n\n","category":"function"},{"location":"documentation.html#Reduce","page":"Structures and Functions","title":"Reduce","text":"","category":"section"},{"location":"documentation.html","page":"Structures and Functions","title":"Structures and Functions","text":"Genesys.reduce","category":"page"},{"location":"documentation.html#Genesys.reduce","page":"Structures and Functions","title":"Genesys.reduce","text":"function reduce(reducer::ManualReducer, ω::Scenarios)\n\nReduces the given Scenarios object using the specified ManualReducer.\n\nArguments\n\nreducer::ManualReducer: The reducer used to specify the reduction process.\nω::Scenarios: The Scenarios object to be reduced.\n\nReturns\n\nA new reduced Scenarios object.\nA probability vector representing the likelihood of each scenario.\n\nExample\n\nmanual_reducer = ManualReducer(h = 1:8760, y = 2:3, s = 1:1)\nreduced_scenarios, probabilities = reduce(manual_reducer, scenarios)\n\n\n\n\n\nfunction reduce(reducer::SAAReducer, ω::Scenarios; y::Int64 = 1, s::Int64 = 1)\n\nReduces the given Scenarios object using the specified SAAReducer, implementing the Sample Average Approximation scenario reduction method.\n\nArguments\n\nreducer::SAAReducer: The reducer used to specify the reduction process.\nω::Scenarios: The Scenarios object to be reduced.\n\nKeyword Arguments\n\ny::Int64 = 1: The initial year to be considered.\ns::Int64 = 1: The initial scenario to be considered.\n\nReturns\n\nA new reduced Scenarios object.\nA probability vector representing the likelihood of each scenario.\n\nExample\n\nsaa_reducer = SAAReducer(nsample = 100)\nreduced_scenarios, probabilities = reduce(saa_reducer, scenarios)\n\n\n\n\n\nfunction reduce(reducer::MeanValueReducer, ω::Scenarios; y::Int64 = 1, s::Int64 = 1)\n\nReduces the given Scenarios object using the specified MeanValueReducer, implementing the Expected Value scenario reduction method.\n\nArguments\n\nreducer::MeanValueReducer: The reducer used to specify the reduction process.\nω::Scenarios: The Scenarios object to be reduced.\n\nKeyword Arguments\n\ny::Int64 = 1: The initial year to be considered.\ns::Int64 = 1: The initial scenario to be considered.\n\nReturns\n\nA new reduced Scenarios object.\nA probability vector representing the likelihood of each scenario (in this case, a single element array containing 1).\n\nExample\n\nmean_value_reducer = MeanValueReducer()\nreduced_scenarios, probabilities = reduce(mean_value_reducer, scenarios)\n\n\n\n\n\nfunction reduce(reducer::FeatureBasedReducer, ω::Scenarios; y::Int64 = 1, s::Int64 = 1)\n\nReduces the given Scenarios object using the specified FeatureBasedReducer, implementing a clustering-based scenario reduction method.\n\nArguments\n\nreducer::FeatureBasedReducer: The reducer used to specify the reduction process, including transformation, dimension reduction, and clustering methods.\nω::Scenarios: The Scenarios object to be reduced.\n\nKeyword Arguments\n\ny::Int64 = 1: The initial year to be considered.\ns::Int64 = 1: The initial scenario to be considered.\n\nReturns\n\nA new reduced Scenarios object.\nA probability vector representing the likelihood of each scenario in the reduced set.\nAn array of assignments indicating which cluster each original scenario belongs to.\n\nExample\n\nfeature_based_reducer = FeatureBasedReducer(transformation = UnitRangeTransform,\n                                            reduction = StatsReduction(),\n                                            clustering = KmedoidsClustering())\nreduced_scenarios, probabilities, assignments = reduce(feature_based_reducer, scenarios)\n\n\n\n\n\n","category":"function"}]
}
